<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>5.1节日旅游攻略</title>
      <link href="/2019-3-31-5.1%E6%97%85%E6%B8%B8%E6%94%BB%E7%95%A5/"/>
      <url>/2019-3-31-5.1%E6%97%85%E6%B8%B8%E6%94%BB%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<p>5.1节日旅游攻略、未完待续</p><a id="more"></a><h3 id="5-1节日旅游攻略"><a href="#5-1节日旅游攻略" class="headerlink" title="5.1节日旅游攻略"></a>5.1节日旅游攻略</h3><h4 id="第一站：乌镇"><a href="#第一站：乌镇" class="headerlink" title="第一站：乌镇"></a>第一站：乌镇</h4><pre><code>出发站：杭州出发时间：5.1 动车：        G7572：9:57    ￥21.5*2    G7316：10:12  ￥21.5*2时间：5.1-5.2酒店：乌镇小宿 ￥468门票：西栅+东栅联票 ￥190*2景点：列举了主要景点    1、西栅：最适合夜游及住宿的区域，夜晚的水上莲花可以look look        1.1、中国邮政：光绪年间的邮局        1.2、草木本色染坊：拍照        1.3、白莲塔：乌镇最高建筑        1.4、三寸金莲馆：中国女性裹足史        1.5、月老庙：许愿        1.6、邵明书院：邵明太子读书处        1.7、囍庆堂：江南婚礼        1.8、西市河：最美夜景地        1.9、天下第一锅：申请吉尼斯纪录        1.10、乌镇大剧院/大戏院：感受当地人文生活        1.11、茅盾纪念堂：纪念馆    2、东栅        2.1、茅盾故居：文学大师茅盾故居        2.2、宏源泰染坊：拍照        2.3、三白酒坊：酿酒过程        2.4、江南百床馆：中国第一家收藏、展出江南古床的博物馆        2.5、逢源双桥：按男左女右走一遍可以左右逢源        2.6、江南民俗馆：江南民俗文化展示        2.7、江南木雕陈列馆：古代木雕展览        2.8、财神湾：发财啊，去去去。        2.9、立志书院：茅盾的手稿、作品、提字        2.10、修真观广场        2.11、余榴梁钱币馆：各个国家的钱币展示    3、南栅和北栅都属于未开发的地段，原生态美食：找找看</code></pre><h4 id="第二站：苏州"><a href="#第二站：苏州" class="headerlink" title="第二站：苏州"></a>第二站：苏州</h4><pre><code>出发站：乌镇出发时间：5.2动车：        G7586：10：04    ￥85.5*2    G7572：10:126 ￥90.5*2时间：5.2-5.4酒店：苏州小院  ￥530*2景点：苏州景点太多    1、观前街        1.1、拙政园：天下园林之母，门票：70*2        1.2、苏州博物馆：苏州园林风格        1.3、平江路：苏州保存最好的古街        1.4、狮子林：叠石最有名，四大名园之一        1.5、苏州古典园林：世界文化遗产        1.6、太平天国忠王符：苏式彩绘    2、十全街        2.1、网师园：苏州四大名园之一        2.2、沧浪亭：苏州最古老园林        2.3、苏州大学：中国十大最美校园之一        2.4、苏州云岩寺塔：中国第一斜塔    3、石路商圈        3.1、虎丘：吴中第一名胜        3.2、七里山塘：姑苏第一名街        3.3、留园：小家碧玉式，四大名园之一        3.4、剑池：虎丘最神秘的名胜        3.5、万景山庄：苏派盆景精品园        3.6、山塘书院：听苏州评弹        3.7、拥翠山庄：苏州唯一无水园林    4、金鸡湖：        4.1、金鸡湖：骑行、夜景        4.2、月光码头：苏州十大最美夜景之首    5、周庄        5.1、周庄古镇：中国第一水乡        5.2、双桥：故乡的回忆蓝本        5.3、沈万三故居：沈万三        5.4、沈厅：沈万三后人的宅子        5.5、南湖秋月园：水中佛国        5.6、周庄博物馆：了解周庄历史        5.7、富安桥：周庄最古老的桥    6、同里        6.1、同里古镇：江南六大古镇之一        6.2、退思园：世界文化遗产        6.3、珍珠塔：同里最大园林        6.4、耕乐堂：同里八景之一    7、阳澄湖        7.1阳澄湖半岛旅游度假区：阳澄湖大闸蟹    8、太湖        8.1、苏州东山景区：太湖山水第一镇        8.2、苏州西山景区：太湖第一大岛美食：找找</code></pre><h4 id="终点站：杭州"><a href="#终点站：杭州" class="headerlink" title="终点站：杭州"></a>终点站：杭州</h4><pre><code>时间：5.4</code></pre>]]></content>
      
      
      <categories>
          
          <category> 闲文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闲文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Me</title>
      <link href="/Me/"/>
      <url>/Me/</url>
      
        <content type="html"><![CDATA[<p>个人简历，更新中</p><a id="more"></a><script src="https://cdn1.lncld.net/static/js/av-mini-0.6.10.js"></script><script src="http://jerry-cdn.b0.upaiyun.com/hit-kounter/hit-kounter-lc-0.2.0.js"></script><p><span data-hk-page="current"> - </span></p><h3 id="个人简历"><a href="#个人简历" class="headerlink" title="个人简历"></a>个人简历</h3><ul><li><strong>姓名：</strong> 林志文</li><li><strong>花名：</strong> 沐白</li><li><strong>Email：</strong> <a href="mailto:quickly520@126.com" target="_blank" rel="noopener">quickly520@126.com</a></li></ul><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><p>…</p><h4 id="工作经历"><a href="#工作经历" class="headerlink" title="工作经历"></a>工作经历</h4><ul><li><strong>杭州筑家易网络科技股份有限公司 2016.8-至今</strong></li></ul><ul><li><strong>杭州一幅画网络科技有限公司 2016.4-2016.7</strong></li></ul><h4 id="项目经历"><a href="#项目经历" class="headerlink" title="项目经历"></a>项目经历</h4><p>…</p><h4 id="自我评价"><a href="#自我评价" class="headerlink" title="自我评价"></a>自我评价</h4><p>…</p>]]></content>
      
      
      
        <tags>
            
            <tag> 简历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>物联网设备-WiFi/Bluetooth/ZigBee配网方式</title>
      <link href="/2018-10-9-%E7%89%A9%E8%81%94%E7%BD%91%E9%80%9A%E4%BF%A1-WiFi:BT:ZigBee%E8%8A%AF%E7%89%87%E7%BA%A7%E6%96%B9%E6%A1%88%E8%A7%A3%E6%9E%90/"/>
      <url>/2018-10-9-%E7%89%A9%E8%81%94%E7%BD%91%E9%80%9A%E4%BF%A1-WiFi:BT:ZigBee%E8%8A%AF%E7%89%87%E7%BA%A7%E6%96%B9%E6%A1%88%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="一、WIFI设备配网"><a href="#一、WIFI设备配网" class="headerlink" title="一、WIFI设备配网"></a>一、WIFI设备配网</h3><p>智能家居的设备智能化，很多家电设备都安装上了WiFi模块, 方便用户通过手机控制和远程查看家里情况，典型的设备如智能插座，智能空调，智能空气净化器。<br>智能设备首次配置，这个过程简单来讲就是把WiFi设备初始化后，连到家里的无线路由器上。第一次配置成功后，基本就一劳永逸了。</p><h4 id="1、目前流行的wifi配置模式一般有以下2种"><a href="#1、目前流行的wifi配置模式一般有以下2种" class="headerlink" title="1、目前流行的wifi配置模式一般有以下2种:"></a>1、目前流行的wifi配置模式一般有以下2种:</h4><ul><li><p>AP模式：</p><p>  智能硬件处于AP模式，手机用于station模式,手机连接智能插座的AP后组成局域网,手机发送需要连接路由的SSID及密码至智能插座,智能硬件主动去连接指定路由后,完成连接</p></li></ul><pre><code>AP（兼容） 模式AP 是 (Wireless) Access Point 的缩写，即 (无线) 访问接入点。简单来讲就像是无线路由器一样，设备打开后进入 AP 模式，在手机的网络列表里面，可以搜索到类似 TPLINK_XXX 的名字（SSID）。连接步骤：1、连接路由器（获取路由器名称）2、请求配网token，用户输入 WiFi 名字和密码后3、初始化硬件设备，使设备进入 AP 模式，Wifi 灯慢闪4、手机切回 WiFi：接入上述 设备出现的 WiFi 名字（SSID）的网络 （类似 TPLINK_XXX）。连上设备后，通过 UDP 发送 经过 AES 加密过的 ssid/password/token5、设备通过 UDP 包获取配置信息，切换网络模式，连接上家里 WiFi，配置完成。断开设备热点。发送token，注册到服务端，登录MQTT服务器6、手机切回到家里面的 WiFi ，根据token，去服务端查找设备。7、服务器返回智能设备的信息</code></pre><ul><li><p>一键配置(smartconfig)模式:</p><p>  智能硬件处于混杂模式下,监听网络中的所有报文;手机APP将SSID和密码编码到UDP报文中,通过广播包或组播报发送,智能硬件接收到UDP报文后解码,得到正确的SSID和密码,然后主动连接指定SSID的路由,完成连接</p><p>  EZ（快捷）Easy-Connect 模式</p><p>  这种快速连接方式，相对于 AP 模式连接简化操作，省了很多步骤，首次配置速度更快。</p><p>  1、手机连上 WiFi，开启 APP 软件，点击”添加新设备”，进入配置界面，输入手机所在 WiFi 密码，请求配网token</p><p>  2、智能硬件开启混杂模式监听所有网络数据包，Wifi 灯快闪</p><p>  3、手机通过广播、组播循环发送 ssid/password/token</p><p>  4、硬件设备通过 UDP 包（长度）获取配置信息捕捉到ssid/password/token，Wifi灯熄灭，连接路由器，连接成功后Wifi灯常亮。发送token，注册到服务端，注册成功后登录MQTT服务器。（广播根据 UDP 包长度，组播根据 IP 地址信息）</p><p>  5、手机根据token，去服务端查找设备，返回设备信息</p></li></ul><h4 id="2、当前主流IOT的wifi方案有"><a href="#2、当前主流IOT的wifi方案有" class="headerlink" title="2、当前主流IOT的wifi方案有:"></a>2、当前主流IOT的wifi方案有:</h4><p>这个功能最早是TI提出并应用于CC3200上;不过从原理上讲,只要芯片驱动支持开启混杂模式(WiFi Promiscuous),就可以支持一键配网功能,只是各个厂家叫法及实现编码方式不同而已;</p><p>手机编码发送采用有UDP组播或广播,不同的发送方式和编码,对应的解码过程也不一样.,当前测试发现,微信是通过UDP广播包实现的;TI是通过往一固定IP地址发送udp包;其他芯片厂家提供的一般为UDP组播方式;</p><p>由于无线数据传播必定是广播的,所以必然可以被监听到;如果AP没有加密的话,UDP直接可以把相关的信息发送出来.但是路由器AP一般都是加密的,而且加密方式不固定.wifi模块在无法直接解析出数据包</p><p>1、广播：发送方可通过改变其所需要发送数据包的长度进行控制<br>所以只要指定出一套利用长度编码的通讯协议,就可利用数据包的Lenght字段进行数据传递</p><p>2、 组播：组播地址是保留的D类地址从224.0.0.0-239.255.255.255<br>IP地址与MAC地址映射关系为:将MAC地址的前25位设定为01.00.5e,而MAC地址的后23位对应IP地址的位;故发送端可以将数据编码在组播ip的后23bit中,通过组播包发送,接收端进行解码即可</p><h3 id="二、Bluetooth配网"><a href="#二、Bluetooth配网" class="headerlink" title="二、Bluetooth配网"></a>二、Bluetooth配网</h3><h3 id="三、Zjgbee"><a href="#三、Zjgbee" class="headerlink" title="三、Zjgbee"></a>三、Zjgbee</h3><hr><p>参考资料：</p><p>Wifi:</p><blockquote><p>WLAN(Wireless Local Area Network)无线局域网络，是一个概念，网络技术术语，IEEE802.11标准是无线局域网最通用的标准<br>Wifi(Wireless Fidelity)是设备商成立的一个联盟，负责测试认证，是使用802.11技术实现的</p></blockquote><p>ZjgBee:</p><blockquote><p>目前在国内采用ZigBee协议智能家居的有3家公司的芯片，恩智浦（NXP）公司（小米智能家居采用的就是该公司的ZigBee芯片），TI公司（德州仪器）CC2530芯片（国内95%以上的公司采用该ZigBee芯片），芯科（Silicon Labs）公司（国内只有极少数公司采用该公司芯片，如聪明屋智能家居采用的是该公司的EM357芯片），该芯片属于ZigBee芯片领域的工业级高性能级别，应用到智能家居居有绝对的优势，规避了传统ZigBee芯片智能家居组网规模小、易丢包不稳定的顽疾。事实证明芯科芯片的智能网关，在保证智能家居系统稳定运行的前提下可以携带120个以上的节点，TI和恩智浦的只能带30个以内的节点。<br>另外芯科（Silicon Labs）公司又发布EFR32MG系列ZigBee芯片，其中部分芯片能同时支持4种无线协议：ZigBee、Thread、BLE（蓝牙）、Proprietary（sub GHZ，小无线），说通俗一点就是用芯科（Silicon Labs）ZigBee芯片开发的ZigBee智能家居可以兼容Thread、BLE（蓝牙）、Proprietary（sub GHZ，小无线）这3种通讯协议的产品，能和这3种通信协议的设备互联互通，技术创新遥遥领先，所以说要做好ZigBee技术智能家居，芯片选择至关重要。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 物联网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 物联网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nexus+Maven搭建私有库</title>
      <link href="/2018-7-12-Nexus+Maven%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E5%BA%93/"/>
      <url>/2018-7-12-Nexus+Maven%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Maven：项目管理和自动构建的工具,maven包集中存放的地方就是maven仓库。这些仓库可以放在本地，也可以放在某个远程服务器上，可以是私有的，也可以是共有的。</p></blockquote><blockquote><p>Nexus：强大的maven仓库管理器，简化了本地仓库的维护和外部仓库的访问</p></blockquote><a id="more"></a><h5 id="1-下载安装Nexus3-0"><a href="#1-下载安装Nexus3-0" class="headerlink" title="1.下载安装Nexus3.0"></a>1.下载安装Nexus3.0</h5><p>nexus的下载地址：<strong><a href="https://blog.sonatype.com/" target="_blank" rel="noopener">https://blog.sonatype.com/</a></strong></p><h5 id="2-启动Nexus"><a href="#2-启动Nexus" class="headerlink" title="2.启动Nexus"></a>2.启动Nexus</h5><p>将下载后的zip解压到某个路径下执行</p><blockquote><p>/Users/***/nexus-3.12.1-01-mac/nexus-3.12.1-01/bin/nexus start</p></blockquote><p>执行成功后</p><blockquote><p>Starting nexus</p></blockquote><h5 id="3-浏览器打开Nexus"><a href="#3-浏览器打开Nexus" class="headerlink" title="3.浏览器打开Nexus"></a>3.浏览器打开Nexus</h5><p><strong><a href="http://127.0.0.1:8081/nexus/" target="_blank" rel="noopener">http://127.0.0.1:8081/nexus/</a></strong></p><blockquote><p>注：启动服务需要等待一会</p></blockquote><h5 id="4-用户登录"><a href="#4-用户登录" class="headerlink" title="4.用户登录"></a>4.用户登录</h5><p>默认的是游客身份，可以查看，但是不能配置<br>需要配置的时候使用管理员身份登录：</p><blockquote><p><strong>admin/admin123</strong></p></blockquote><h5 id="5-Blob-Stroes"><a href="#5-Blob-Stroes" class="headerlink" title="5.Blob Stroes"></a>5.Blob Stroes</h5><p>依赖index存储目录，默认存储在default下：</p><p>\sonatype-work\nexus3\blobs\default</p><p>也可以自己新建一个目录专门存在某个仓库的索引，在创建repository可以选择</p><h5 id="6-reponsitory"><a href="#6-reponsitory" class="headerlink" title="6.reponsitory"></a>6.reponsitory</h5><p>Nexus默认创建了几个仓库<br>group:是一个仓库组，包含了hosted和proxy两种库，下载时按配置顺序从中依次查找<br>hosted:一般是部署我们项目打包的jar，供内部人员下载<br>proxy：代理远程仓库，maven-central是默认maven中央仓库代理，通过代理从远程仓库中下载的依赖都会被缓存到nexus的proxy库中</p><h5 id="7-创建自己的reponsitory"><a href="#7-创建自己的reponsitory" class="headerlink" title="7.创建自己的reponsitory"></a>7.创建自己的reponsitory</h5><p>一般情况下我们会选择创建一个hosted仓库</p><p>步骤为<em>repositories –&gt; Add –&gt; hosted repository</em>，在页面的下半部分输入框中填入repository id和repository name即可，另外把deployment policy设置为Allow Redeploy，点击save就创建完成了</p><p>这边我们可以看到我们创建成功的reponsitory，这里有个仓库的地址<br><strong><a href="http://127.0.0.1:8081/repository/test-comment-release/" target="_blank" rel="noopener">http://127.0.0.1:8081/repository/test-comment-release/</a></strong><br>可以复制出来</p><h5 id="8-创建完成后我们在androidStudio创建一个项目，项目中创建一个model"><a href="#8-创建完成后我们在androidStudio创建一个项目，项目中创建一个model" class="headerlink" title="8.创建完成后我们在androidStudio创建一个项目，项目中创建一个model"></a>8.创建完成后我们在androidStudio创建一个项目，项目中创建一个model</h5><p>在根目录的build.gradle的repositories中添加：</p><p><strong>maven{ url ‘<a href="http://127.0.0.1:8081/repository/test-comment-release/&#39;}" target="_blank" rel="noopener">http://127.0.0.1:8081/repository/test-comment-release/&#39;}</a></strong></p><p>然后在model的build.gradle中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">uploadArchives &#123;</span><br><span class="line">    configuration = configurations.archives</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenDeployer &#123;</span><br><span class="line">            snapshotRepository(url: MAVEN_REPO_SNAPSHOT_URL) &#123;</span><br><span class="line">                authentication(userName: NEXUS_USERNAME, password: NEXUS_PASSWORD)</span><br><span class="line">            &#125;</span><br><span class="line">            repository(url: MAVEN_REPO_RELEASE_URL) &#123;</span><br><span class="line">                authentication(userName: NEXUS_USERNAME, password: NEXUS_PASSWORD)</span><br><span class="line">            &#125;</span><br><span class="line">            pom.project &#123;</span><br><span class="line">                version &apos;1.0.0&apos;//版本号可以直接指定</span><br><span class="line">                artifactId &apos;comment-sdk&apos;//这边的id我们可以指定</span><br><span class="line">                groupId GROUP_ID</span><br><span class="line">                packaging TYPE</span><br><span class="line">                description DESCRIPTION</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">artifacts &#123;</span><br><span class="line">    archives file(&apos;model名称.aar&apos;)//我们的model名.aar</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意的是需要在model的build.gradle中添加(使得这个model可以作为maven)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &apos;maven&apos;</span><br></pre></td></tr></table></figure><h5 id="9-在gradle-properties中添加："><a href="#9-在gradle-properties中添加：" class="headerlink" title="9.在gradle.properties中添加："></a>9.在gradle.properties中添加：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Maven仓库的URL</span><br><span class="line">MAVEN_REPO_RELEASE_URL=http://127.0.0.1:8081/repository/mubai-comment-release/  这边是正式的仓库的地址</span><br><span class="line">MAVEN_REPO_SNAPSHOT_URL=http://127.0.0.1:8081/repository/mubai-comment-snapshot/  这边是snapshot的仓库的地址</span><br><span class="line"></span><br><span class="line"># 对应maven的GroupId的值</span><br><span class="line">GROUP = com.comment.sdk  这边我们可以自己指定</span><br><span class="line">##### 登录nexus ossde的用户名</span><br><span class="line"></span><br><span class="line">NEXUS_USERNAME=admin</span><br><span class="line"># 登录nexus oss的密码</span><br><span class="line"></span><br><span class="line">NEXUS_PASSWORD=admin123</span><br><span class="line"></span><br><span class="line"># groupid</span><br><span class="line">GROUP_ID = com.comment.sdk  这边我们可以自己指定</span><br><span class="line"></span><br><span class="line"># type</span><br><span class="line">TYPE = aar</span><br><span class="line"></span><br><span class="line"># description</span><br><span class="line">DESCRIPTION = This is comment sdk 描述</span><br></pre></td></tr></table></figure><p>然后点击右侧的Gradle找到我们需要上传的model，然后里面的upload中的<strong>uploadArchives</strong>双击，然后等待上传aar成功</p><h5 id="10-上传成功后我们可以在nexus上看到我们的上传的aar"><a href="#10-上传成功后我们可以在nexus上看到我们的上传的aar" class="headerlink" title="10.上传成功后我们可以在nexus上看到我们的上传的aar"></a>10.上传成功后我们可以在nexus上看到我们的上传的aar</h5><h5 id="11-然后我们在需要用到的项目中，先去根目录build的地方添加："><a href="#11-然后我们在需要用到的项目中，先去根目录build的地方添加：" class="headerlink" title="11.然后我们在需要用到的项目中，先去根目录build的地方添加："></a>11.然后我们在需要用到的项目中，先去根目录build的地方添加：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">maven&#123; url &apos;http://可以换成服务器的ip地址:8081/repository/mubai-comment-release/&apos;&#125;</span><br></pre></td></tr></table></figure><p>然后在具体的app的build中添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#前面是我们GROUP_ID:ArtifactId:版本号(这些id我们都可以自己在配置的时候去指定)</span><br><span class="line">compile &apos;com.comment.sdk:comment-sdk-debug:1.1.0&apos;</span><br></pre></td></tr></table></figure><p>然后我们就可以引用我们aar包里面的东西</p><p><strong>实际上使用nexus只是作为一个管理aar包的托管服务器，我们在利用gradle将aar包上传到nexus上面</strong></p><hr><p>补充说明：</p><p>maven仓库地址和ID的命名规则</p><p>正式仓库地址：<br><strong>MAVEN_REPO_RELEASE_URL=<a href="http://192.168.1.20:8081/nexus/content/groups/app-public/" target="_blank" rel="noopener">http://192.168.1.20:8081/nexus/content/groups/app-public/</a></strong></p><p>快照仓库地址：<br><strong>MAVEN_REPO_SNAPSHOT_URL=<a href="http://192.168.1.20:8081/nexus/content/repositories/snapshots/" target="_blank" rel="noopener">http://192.168.1.20:8081/nexus/content/repositories/snapshots/</a></strong></p><p><strong>GroupId:  com.zjy.iot.app</strong></p><p><strong>artifactId ‘iot-app-xxx-sdk’</strong></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Gradle</title>
      <link href="/2018-2-26-Android%20Gradle%20%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2018-2-26-Android%20Gradle%20%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Failed to resolve: xxx.xxx.xxx:xxx:x.x.x Show in File Show in Project Structure dialog</span><br></pre></td></tr></table></figure><p>有时候在我们创建项目引入一个新的依赖或者打开一个从网上clone下来的项目的时候会遇到这样的问题</p><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android各大应用商店应用图标、截图尺寸</title>
      <link href="/2018-2-5-Android%E5%90%84%E5%A4%A7%E5%95%86%E5%BA%97%E5%BA%94%E7%94%A8%E5%9B%BE%E6%A0%87%E3%80%81%E6%88%AA%E5%9B%BE%E5%B0%BA%E5%AF%B8/"/>
      <url>/2018-2-5-Android%E5%90%84%E5%A4%A7%E5%95%86%E5%BA%97%E5%BA%94%E7%94%A8%E5%9B%BE%E6%A0%87%E3%80%81%E6%88%AA%E5%9B%BE%E5%B0%BA%E5%AF%B8/</url>
      
        <content type="html"><![CDATA[<h3 id="360"><a href="#360" class="headerlink" title="360"></a>360</h3><ul><li>应用图标：512 * 512png</li><li>应用截图：480 * 800 5张 png</li></ul><a id="more"></a><h3 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h3><ul><li>应用图标：512*512 png</li><li>应用截图：480 * 800 5张 </li></ul><h3 id="腾讯"><a href="#腾讯" class="headerlink" title="腾讯"></a>腾讯</h3><ul><li>应用图标：16 <em> 16一张，512 </em> 512一张 png</li><li>应用截图：480 * 800 5张 png</li></ul><h3 id="华为"><a href="#华为" class="headerlink" title="华为"></a>华为</h3><ul><li>应用图标：16 <em> 16一张，512 </em> 512一张 png</li><li>应用截图：480 * 800 5张 png</li></ul><h3 id="魅族"><a href="#魅族" class="headerlink" title="魅族"></a>魅族</h3><ul><li>应用图标：16 <em> 16一张，512 </em> 512一张 png</li><li>应用截图：480 * 800 5张 png</li></ul><h3 id="Oppo"><a href="#Oppo" class="headerlink" title="Oppo"></a>Oppo</h3><ul><li>应用图标：16 <em> 16一张，512 </em> 512一张 png</li><li>应用截图：480 * 800 5张 png</li></ul><h3 id="Vivo"><a href="#Vivo" class="headerlink" title="Vivo"></a>Vivo</h3><ul><li>应用图标：16 <em> 16一张，512 </em> 512一张 png</li><li>应用截图：480 * 800 5张 png</li></ul><h3 id="锤子"><a href="#锤子" class="headerlink" title="锤子"></a>锤子</h3><ul><li>应用图标：16 <em> 16一张，512 </em> 512一张 png</li><li>应用截图：480 * 800 5张 png</li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android9.0曝光新特性</title>
      <link href="/2018-2-5-Android9.0%E6%9B%9D%E5%85%89%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/2018-2-5-Android9.0%E6%9B%9D%E5%85%89%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<blockquote><p>安卓9.0将加入电话录音功能：提高通话安全性</p><p>通话录音是目前许多手机都有的功能，但安卓原生系统并没有自带这项功能。</p></blockquote><a id="more"></a><p>据外媒<strong>Android Headlines</strong>消息称，发现Google在下个安卓开放源代码（AOSP）中发现新的代码，(此代码可能指向记录录音功能)说明下个安卓版本将会具有记录录音功能。</p><p>据悉，原声<strong>Android9.0</strong>的版本可以提供通话录音，而且通过提示用户进行操作，并且双方在通话的过程中，手机系统每15秒钟会发出一次蜂鸣声(手机将会把频率为1400Hz、每15秒钟重复一次的提示音添加到通话中，该声音将会被通话双方都听到，让对方确认你正在录音)，这种声音是提示呼叫者他们的对话正在被录音。</p><p>为了保证安全性，这段录音文件极有可能会存在Google云服务器中(话说国内如何访问呢…)</p><p>另外，据说<strong>Android9.0</strong>会提高系统的封闭性，让一些高度自由化的操作断绝掉(比如高权限插件、自动签到、个性化UI定制等)，整体的系统机制向iOS靠拢，对于用户来说只能说是喜忧参半，采用封闭机制，APP自启动、高敏感权限申请，等不再会出现，安全性、流畅度、稳定性都将大幅提升，但是却要牺牲原本的可玩性，只能说鱼与熊掌不能兼得吧！</p><p>当然对于开发者来说，提高系统的封闭性后，缺点在于我们对于一些需要的权限、操作需要更多的实现代码，同时原本的一些功能需要通过不同的方式方法实现，好处在于我们可以开发出安全性、稳定性更高的App！</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TensorFlow入门</title>
      <link href="/2018-2-3-TensorFlow%E5%85%A5%E9%97%A8/"/>
      <url>/2018-2-3-TensorFlow%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h4 id="MNIST机器学习入门"><a href="#MNIST机器学习入门" class="headerlink" title="MNIST机器学习入门"></a><a href="http://wiki.jikexueyuan.com/project/tensorflow-zh/tutorials/mnist_beginners.html" target="_blank" rel="noopener">MNIST机器学习入门</a></h4><p>MNIST:机器学习的入门，是一个入门级的计算机视觉数据集，包含了2部分：</p><ul><li>手写的数字图片</li><li>数字图片对应的标签</li></ul><a id="more"></a><p>MNIST数据集：官网地址是<a href="http://yann.lecun.com/exdb/mnist/" target="_blank" rel="noopener">Yann LeCun’s website</a><br>下载下来的数据集被分成了2部分：60000行的训练数据集(mnist.train)和10000行的测试数据集(mnist.test)</p><blockquote><p>这么切分的好处在于：在机器学习模式设计时必须有一个单独的测试数据集不用与训练而是用来评估这个模型的性能，从而更加容易把设计的模型推广到其他数据集上(泛化)</p></blockquote><hr><p>参考链接</p><p><a href="http://tensorflow.org/" target="_blank" rel="noopener">英文官方网站</a></p><p><a href="http://wiki.jikexueyuan.com/project/tensorflow-zh/" target="_blank" rel="noopener">TensorFlow 官方文档中文版</a></p><p><a href="https://github.com/tensorflow/tensorflow" target="_blank" rel="noopener">英文版GithHub仓库</a></p><p><a href="https://github.com/jikexueyuanwiki/tensorflow-zh" target="_blank" rel="noopener">中文版GithHub仓库</a></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android仓库托管平台</title>
      <link href="/2018-2-1-Android%E4%BB%93%E5%BA%93%E6%89%98%E7%AE%A1%E5%B9%B3%E5%8F%B0/"/>
      <url>/2018-2-1-Android%E4%BB%93%E5%BA%93%E6%89%98%E7%AE%A1%E5%B9%B3%E5%8F%B0/</url>
      
        <content type="html"><![CDATA[<h4 id="Android-Library的托管平台介绍"><a href="#Android-Library的托管平台介绍" class="headerlink" title="Android Library的托管平台介绍"></a>Android Library的托管平台介绍</h4><blockquote><p>Android Studio是从build.gradle里面定义的Maven仓库服务器上下载library</p></blockquote><a id="more"></a><p>在build.gradle中会看到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()//使用Jcenter作为Maven</span><br><span class="line">        mavenCentral()//使用mavenCentral作为Maven</span><br><span class="line">        maven &#123;//自定义maven</span><br><span class="line">            url &apos;https://maven.google.com/&apos;</span><br><span class="line">            name &apos;Google&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过</p><ul><li><p>Jcenter</p><blockquote><p>Jcenter是一个由bintray.com维护的Maven仓库</p></blockquote></li><li><p>mavenCentral</p><blockquote><p>MavenCentral是由sonatype.org维护的Maven仓库</p></blockquote></li><li><p>maven { url ‘自己的仓库服务器地址’ }</p><blockquote><p>有时候会将library放在自己的服务器上，这时候就需要我们添加maven地址</p></blockquote></li></ul><p>但是一般来说我们只会使用<strong>Jcenter</strong>和<strong>mavenCentral</strong>，毕竟自己维护一个服务器地址成本较高，而且对于使用者来说他们只需要添加代码的依赖地址</p><blockquote><p>实际上除了Maven仓库外还有另外一种仓库：<a href="http://ant.apache.org/ivy/" target="_blank" rel="noopener">Ivy仓库</a></p></blockquote><h4 id="Jcenter和mavenCentral比较"><a href="#Jcenter和mavenCentral比较" class="headerlink" title="Jcenter和mavenCentral比较"></a>Jcenter和mavenCentral比较</h4><p>两个仓库都具有相同的使命：提供Java或者Android的Library服务</p><p>最开始的时候，AndroidStudio选择<strong>MavenCentral</strong>作为默认仓库，后来由于<strong>MavenCentral</strong>的不友好，对于开发者上传Library很难，同时由于其他的种种原因，AndroidStudio决定把<strong>MavenCentral</strong>换成<strong>Jcenter</strong></p><pre><code>* jcenter通过CDN发送library，开发者可以享受到更快的下载体验。* jcenter是全世界最大的Java仓库，因此在Maven Central 上有的 在jcenter上也极有可能有。换句话说jcenter是Maven Central的超集。* 上传library到仓库很简单，不需要像在 Maven Central上做很多复杂的事情* 友好的用户界面</code></pre><hr><blockquote><p>其他相关问题</p></blockquote><ul><li>如果要了解如何发布自己的library到Jcenter，可以查看<a href="http://mubai.site/%E9%A1%B9%E7%9B%AE%E5%8F%91%E5%B8%83%E5%88%B0%E5%85%AC%E5%85%B1%E7%9A%84jcenter%E4%BB%93%E5%BA%93/" target="_blank" rel="noopener">发布Library到Jcenter</a></li><li>有时候我们通过Jcenter依赖Library的时候加载很慢，可以查看<a href="http://blog.csdn.net/xiongbatianxia30146/article/details/63686359" target="_blank" rel="noopener">解决JCenter下载太慢的问题</a>来解决</li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目发布到jcenter仓库</title>
      <link href="/2018-1-25-Jcenter%20/"/>
      <url>/2018-1-25-Jcenter%20/</url>
      
        <content type="html"><![CDATA[<h3 id="项目所需的步骤"><a href="#项目所需的步骤" class="headerlink" title="项目所需的步骤"></a>项目所需的步骤</h3><h4 id="一、添加插件"><a href="#一、添加插件" class="headerlink" title="一、添加插件"></a>一、添加插件</h4><h5 id="在项目目录的build-gradle-中的-dependencies-添加："><a href="#在项目目录的build-gradle-中的-dependencies-添加：" class="headerlink" title="在项目目录的build.gradle 中的 dependencies 添加："></a>在项目目录的build.gradle 中的 dependencies 添加：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">classpath &quot;com.jfrog.bintray.gradle:gradle-bintray-plugin:1.5&quot; </span><br><span class="line">classpath &apos;com.github.dcendents:android-maven-gradle-plugin:1.4.1&apos;</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="二、配置gradle"><a href="#二、配置gradle" class="headerlink" title="二、配置gradle"></a>二、配置gradle</h4><h5 id="同时在需要添加到jcenter的libary的build-gradle根目录添加："><a href="#同时在需要添加到jcenter的libary的build-gradle根目录添加：" class="headerlink" title="同时在需要添加到jcenter的libary的build.gradle根目录添加："></a>同时在需要添加到jcenter的libary的build.gradle根目录添加：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &apos;com.github.dcendents.android-maven&apos; </span><br><span class="line">apply plugin: &apos;com.jfrog.bintray&apos;</span><br><span class="line">version = &quot;1.0.1&quot; //这里的version是可以更新的版本号*</span><br></pre></td></tr></table></figure><h5 id="1-在local-properties添加用户名和key"><a href="#1-在local-properties添加用户名和key" class="headerlink" title="(1)在local.properties添加用户名和key"></a>(1)在local.properties添加用户名和key</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bintray.user=openproject </span><br><span class="line">// your bintrayuser name </span><br><span class="line">bintray.apikey=****** </span><br><span class="line">// your bintray api key`</span><br></pre></td></tr></table></figure><h5 id="2-继续在根目录添加："><a href="#2-继续在根目录添加：" class="headerlink" title="(2)继续在根目录添加："></a>(2)继续在根目录添加：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def siteUrl = &apos;https://github.com/MoMuBai/Test&apos; </span><br><span class="line">// #修改# // 项目的主页地址，我这里是我的PickerView项目在github的链接地址 </span><br><span class="line">def gitUrl = &apos;https://github.com/MoMuBai/Test.git&apos; </span><br><span class="line">// #修改# // 项目 git 地址，我这里同样是用Github上的git地址 </span><br><span class="line">group = &quot;com.mubai&quot; </span><br><span class="line">// #修改# // 组名称</span><br></pre></td></tr></table></figure><h5 id="3-打包javadocjar和sourcejar"><a href="#3-打包javadocjar和sourcejar" class="headerlink" title="(3)打包javadocjar和sourcejar"></a>(3)打包javadocjar和sourcejar</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">install &#123; </span><br><span class="line">    repositories.mavenInstaller &#123;</span><br><span class="line">        // This generates POM.xml with proper parameters</span><br><span class="line">        pom &#123;</span><br><span class="line">            project &#123;</span><br><span class="line">                packaging &apos;aar&apos;</span><br><span class="line">                name &apos;Less Code For Android&apos;</span><br><span class="line">                url siteUrl</span><br><span class="line">                licenses &#123;</span><br><span class="line">                    license &#123;</span><br><span class="line">                        name &apos;The Apache Software License, Version 2.0&apos;</span><br><span class="line">                        url &apos;http://www.apache.org/licenses/LICENSE-2.0.txt&apos;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                developers &#123;</span><br><span class="line">                    developer &#123;</span><br><span class="line">                        id &apos;mubai&apos;</span><br><span class="line">                        name &apos;mubai.lzw&apos;</span><br><span class="line">                        email &apos;quickly520@126.com&apos;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                scm &#123;</span><br><span class="line">                    connection gitUrl</span><br><span class="line">                    developerConnection gitUrl</span><br><span class="line">                    url siteUrl</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-打包javadocjar和sourcejar"><a href="#4-打包javadocjar和sourcejar" class="headerlink" title="(4)打包javadocjar和sourcejar"></a>(4)打包javadocjar和sourcejar</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">task sourcesJar(type: Jar) &#123;</span><br><span class="line">    from android.sourceSets.main.java.srcDirs</span><br><span class="line">    classifier = &apos;sources&apos;</span><br><span class="line">&#125;</span><br><span class="line">task javadoc(type: Javadoc) &#123;</span><br><span class="line">    source = android.sourceSets.main.java.srcDirs</span><br><span class="line">    classpath += project.files(android.getBootClasspath().join(File.pathSeparator))</span><br><span class="line">&#125;</span><br><span class="line">task javadocJar(type: Jar, dependsOn: javadoc) &#123;</span><br><span class="line">    classifier = &apos;javadoc&apos;</span><br><span class="line">    from javadoc.destinationDir</span><br><span class="line">&#125;</span><br><span class="line">artifacts &#123;</span><br><span class="line">    archives javadocJar</span><br><span class="line">    archives sourcesJar</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-上传到Jcenter仓库-需要去从local-properties中读取"><a href="#5-上传到Jcenter仓库-需要去从local-properties中读取" class="headerlink" title="(5)上传到Jcenter仓库 需要去从local.properties中读取"></a>(5)上传到Jcenter仓库 需要去从local.properties中读取</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Properties properties = new Properties()</span><br><span class="line">properties.load(project.rootProject.file(&apos;local.properties&apos;).newDataInputStream())</span><br><span class="line">bintray &#123;</span><br><span class="line">    user = properties.getProperty(&quot;bintray.user&quot;)</span><br><span class="line">    key = properties.getProperty(&quot;bintray.apikey&quot;)</span><br><span class="line">    configurations = [&apos;archives&apos;]</span><br><span class="line">    pkg &#123;</span><br><span class="line">        repo = &quot;maven&quot;</span><br><span class="line">        name = &quot;test-library&quot;                // project name in jcenter</span><br><span class="line">        websiteUrl = siteUrl</span><br><span class="line">        vcsUrl = gitUrl</span><br><span class="line">        licenses = [&quot;Apache-2.0&quot;]</span><br><span class="line">        publish = true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三、执行命令"><a href="#三、执行命令" class="headerlink" title="三、执行命令"></a>三、执行命令</h4><h5 id="通过命令进入项目目录执行命令"><a href="#通过命令进入项目目录执行命令" class="headerlink" title="通过命令进入项目目录执行命令"></a>通过命令进入项目目录执行命令</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./gradlew javadocJar</span><br><span class="line">./gradlew sourcesJar</span><br><span class="line">./gradlew install</span><br><span class="line">./gradlew bintrayUpload</span><br></pre></td></tr></table></figure><h3 id="Bintray所需的步骤"><a href="#Bintray所需的步骤" class="headerlink" title="Bintray所需的步骤"></a><a href="https://bintray.com/" target="_blank" rel="noopener">Bintray</a>所需的步骤</h3><h4 id="一、注册账号也可以通过Git直接登录"><a href="#一、注册账号也可以通过Git直接登录" class="headerlink" title="一、注册账号也可以通过Git直接登录"></a>一、注册账号也可以通过Git直接登录</h4><h4 id="二、添加一个新的Repository-名字跟在gradle配置的一样"><a href="#二、添加一个新的Repository-名字跟在gradle配置的一样" class="headerlink" title="二、添加一个新的Repository(名字跟在gradle配置的一样)"></a>二、添加一个新的Repository(名字跟在gradle配置的一样)</h4><h4 id="三、在gradle命令执行完成后可以到Bintray进行提交审核-一般几个小时"><a href="#三、在gradle命令执行完成后可以到Bintray进行提交审核-一般几个小时" class="headerlink" title="三、在gradle命令执行完成后可以到Bintray进行提交审核(一般几个小时)"></a>三、在gradle命令执行完成后可以到Bintray进行提交审核(一般几个小时)</h4><h4 id="四、审核通过之后就可以进行依赖的添加使用了"><a href="#四、审核通过之后就可以进行依赖的添加使用了" class="headerlink" title="四、审核通过之后就可以进行依赖的添加使用了"></a>四、审核通过之后就可以进行依赖的添加使用了</h4><p><code>compile &#39;com.mubai:library:1.0.1&#39;</code></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android反编译</title>
      <link href="/2018-1-18-%E5%8F%8D%E7%BC%96%E8%AF%91/"/>
      <url>/2018-1-18-%E5%8F%8D%E7%BC%96%E8%AF%91/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android屏幕适配</title>
      <link href="/2018-1-11-Android%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D/"/>
      <url>/2018-1-11-Android%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<blockquote><p>实际上很早就想写关于Android屏幕适配的总结了，但是由于各种各样的理由推迟了</p></blockquote><a id="more"></a><h4 id="什么是屏幕适配"><a href="#什么是屏幕适配" class="headerlink" title="什么是屏幕适配"></a>什么是屏幕适配</h4><p>屏幕适配即在不同分辨率、尺寸、比例的设备上显示达到一样的效果</p><h4 id="为什么要屏幕适配"><a href="#为什么要屏幕适配" class="headerlink" title="为什么要屏幕适配"></a>为什么要屏幕适配</h4><p>由于Android系统的开放性，任何用户、开发者、OEM厂商、运营商都可以对Android进行定制，修改成他们想要的样子，这种情况下导致了Android系统的碎片化严重</p><blockquote><p>碎片化：系统碎片化(小米MIUI、华为EMUI、魅族flyme)、屏幕大小碎片化(5.0、5.5、6.0)、屏幕分辨率碎片化(320x480、480x800、720x1280、1080x1920)</p><p>这里有Android碎片化的数据：<a href="https://opensignal.com/reports/2014/android-fragmentation/" target="_blank" rel="noopener">戳这里</a></p></blockquote><h4 id="如何进行屏幕适配"><a href="#如何进行屏幕适配" class="headerlink" title="如何进行屏幕适配"></a>如何进行屏幕适配</h4><h5 id="在屏幕适配开始前，我们需要对Android的一些屏幕相关单位有所了解"><a href="#在屏幕适配开始前，我们需要对Android的一些屏幕相关单位有所了解" class="headerlink" title="在屏幕适配开始前，我们需要对Android的一些屏幕相关单位有所了解"></a>在屏幕适配开始前，我们需要对Android的一些屏幕相关单位有所了解</h5><ul><li>像素：单位px，屏幕上的点，我们看到的图像都是由一个个小点构成的</li><li>屏幕尺寸：屏幕上对角线的长度，单位是英寸，一英寸为2.54厘米，现在市场上常见的有4.7、5.0、5.5、6.0等尺寸的手机</li><li>屏幕分辨率：横纵方向上的像素点数，如1920*1080，即纵向上有1920个像素点，横向上有1080个像素点</li><li>屏幕每英寸点数：单位dpi，为屏幕分辨率/屏幕尺寸所得的值，如一个1920*1080的手机，它的纵向尺寸为3英寸，横向尺寸为5.3英寸，那么它的像素密度为1080/3=360dpi，屏幕分辨率越高，尺寸越小，那么它的像素密度就越高</li><li>屏幕像素密度：density = dpi/160</li><li>屏幕像素无关密度：单位dp或者是dip，与物流像素点无关，是Android特有的单位，是为了保证在不同屏幕像素密度的设备上显示相同的效果</li><li>屏幕独立比例像素：单位sp，类似dp，一般是用来设置文字大小</li></ul><p>这里用张表格来各个单位之间的关系</p><table><thead><tr><th>密度类型</th><th style="text-align:center">代表的分辨率（px）</th><th style="text-align:right">屏幕每英寸点数（dpi）</th><th style="text-align:right">屏幕密度（density）</th><th style="text-align:right">换算（px/dp）</th><th style="text-align:right">比例</th></tr></thead><tbody><tr><td>低密度（ldpi）</td><td style="text-align:center">240x320</td><td style="text-align:right">120</td><td style="text-align:right">0.75</td><td style="text-align:right">1dp = 0.75px</td><td style="text-align:right">3</td></tr><tr><td>中密度（mdpi）</td><td style="text-align:center">320x480</td><td style="text-align:right">160</td><td style="text-align:right">1</td><td style="text-align:right">1dp = 1px</td><td style="text-align:right">4</td></tr><tr><td>高密度（hdpi）</td><td style="text-align:center">480x800</td><td style="text-align:right">240</td><td style="text-align:right">1.5</td><td style="text-align:right">1px = 1.5dp</td><td style="text-align:right">6</td></tr><tr><td>超高密度（xhdpi）</td><td style="text-align:center">720x1280</td><td style="text-align:right">320</td><td style="text-align:right">2</td><td style="text-align:right">1dp = 2px</td><td style="text-align:right">8</td></tr><tr><td>超超高密度（xxhdpi）</td><td style="text-align:center">1080x1920</td><td style="text-align:right">480</td><td style="text-align:right">3</td><td style="text-align:right">1dp = 3px</td><td style="text-align:right">12</td></tr></tbody></table><h5 id="如何适配"><a href="#如何适配" class="headerlink" title="如何适配"></a>如何适配</h5><hr><p>参考链接</p><p><a href="https://www.jianshu.com/p/ec5a1a30694b" target="_blank" rel="noopener">Android 屏幕适配：最全面的解决方案</a></p><p><a href="http://blog.csdn.net/zhaokaiqiang1992/article/details/45419023#%E5%B1%8F%E5%B9%95%E5%B0%BA%E5%AF%B8" target="_blank" rel="noopener">Android屏幕适配全攻略(最权威的官方适配指导)</a></p><p><a href="http://stormzhang.com/android/2014/05/16/android-screen-adaptation/" target="_blank" rel="noopener">Android 屏幕适配</a></p><p><a href="http://blog.csdn.net/guolin_blog/article/details/8830286" target="_blank" rel="noopener">Android官方提供的支持不同屏幕大小的全部方法</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里云大使</title>
      <link href="/2018-1-10-%E9%98%BF%E9%87%8C%E4%BA%91%E5%A4%A7%E4%BD%BF%E8%A1%8C%E8%B5%B0%E4%B8%AD/"/>
      <url>/2018-1-10-%E9%98%BF%E9%87%8C%E4%BA%91%E5%A4%A7%E4%BD%BF%E8%A1%8C%E8%B5%B0%E4%B8%AD/</url>
      
        <content type="html"><![CDATA[<p>💰💰💰💰💰💰💰💰💰💰💰💰💰💰💰💰💰💰💰💰💰💰💰</p><p><strong>满满的$$$镇楼</strong></p><blockquote><p>在使用阿里云提供的域名服务中偶然发现云大使这个组织，然后发现这是个让其他的人通过使用你的幸运券去购买阿里云产品，你就可以获得对应的返佣比例，最高可达30%(如被推荐的人新购买或者是升级了自己的域名服务。支付了10000元，则云大使就可以获得3000元的返佣)</p></blockquote><p>说的简单点，云大使就是<strong>分享幸运券-&gt;坐等返佣</strong>的过程，通俗点就是个<strong>赚钱，钱，钱</strong>的过程，重要的话要说三遍</p><a id="more"></a><blockquote><p>当然是要有人使用了你分享的幸运券的前提下</p></blockquote><p>我们现在就来说说如何用云大使实现我们的目标：<strong>月入百万、荣登CEO、迎娶白富美</strong>我的<strong><a href="https://promotion.aliyun.com/ntms/act/ambassador/sharetouser.html?userCode=2j1udai5&amp;utm_source=2j1udai5" target="_blank" rel="noopener">幸运券</a></strong></p><h5 id="1-加入云大使"><a href="#1-加入云大使" class="headerlink" title="1.加入云大使"></a>1.加入云大使</h5><p>首先需要你有<a href="https://www.aliyun.com/?utm_medium=text&amp;utm_source=bdbrand&amp;utm_campaign=bdbrand&amp;utm_content=se_32492" target="_blank" rel="noopener">阿里云</a>的账号，然后你就可以通过<a href="https://promotion.aliyun.com/ntms/yunparter/zhaomu.html?spm=5176.bbsr569878.0.0.ZUuEom" target="_blank" rel="noopener">云大使报名入口</a>加入云大使</p><h5 id="2-分享使用幸运券及好处"><a href="#2-分享使用幸运券及好处" class="headerlink" title="2.分享使用幸运券及好处"></a>2.分享使用幸运券及好处</h5><ul><li><p>网页端：加入云大使后会对应的<strong><a href="https://expense.console.aliyun.com/#/ambassador/ticket/product" target="_blank" rel="noopener">生成你的幸运券</a></strong>，然后你可以通过复制<strong><a href="https://promotion.aliyun.com/ntms/act/ambassador/sharetouser.html?userCode=2j1udai5&amp;utm_source=2j1udai5" target="_blank" rel="noopener">你的幸运券</a></strong>分享出去</p></li><li><p>App端：<strong>阿里云App-&gt;我的-&gt;推开奖励-&gt;分享全部产品幸运券</strong>然后就可以通过其他方式分享到支付宝、钉钉、微信、QQ等</p></li></ul><h5 id="3-使用幸运券"><a href="#3-使用幸运券" class="headerlink" title="3.使用幸运券"></a>3.使用幸运券</h5><ul><li><p>如何使用幸运券：其他人在选择<strong>阿里云产品-&gt;购买-&gt;确认订单的环节-&gt;使用云大使的幸运券-&gt;提交订单-&gt;完成支付</strong>，整个流程后即可认为幸运券被使用</p></li><li><p>使用幸运券的好处：</p><ul><li>幸运券实际上是有优惠的，只是它的优惠金额是随机的</li><li>订单支付大于0元可参与抽奖</li><li>首购ecs大于1000元可参与抽奖</li></ul></li></ul><blockquote><p>当前阿里云可以使用幸运券的产品共29款</p></blockquote><h5 id="4-坐等返佣"><a href="#4-坐等返佣" class="headerlink" title="4.坐等返佣"></a>4.坐等返佣</h5><p>18年1月返利新规<strong>【返佣率高达30%无封顶返利】</strong></p><p><img src="http://p0sgkjh7x.bkt.clouddn.com/47499416-AC74-4B5C-A057-CFB5E0D3F738.png" alt="1月份新规图"></p><ul><li><p>返利时间：一般情况下当月的奖励将会在下下月的20号左右返利，如1月月份推荐的返利将在18年3月20日左右发放，（一般情况下只会提前不会延后）返利将会发放到绑定的支付宝账号中</p></li><li><p>需要注意:要完成<strong>1实名认证-&gt;2.绑定支付宝-&gt;3.现金购云产品&gt;=100元(第3条在校学生通过学生认证除外)</strong>才能够完成返利提现</p></li></ul><hr><blockquote><p>附上阿里云可以使用幸运券产品图(18年1月份新图)，总有一款适合你，</p></blockquote><p><img src="http://p0sgkjh7x.bkt.clouddn.com/8406A892-DDBD-4345-83C8-24A9AE3D26A7.png" alt="图1"><br><img src="http://p0sgkjh7x.bkt.clouddn.com/32693FE6-4454-4440-B48B-BAEB2A81FCA4.png" alt="图2"><br><img src="http://p0sgkjh7x.bkt.clouddn.com/D7D61595-2640-4918-B4AC-1FB3A86C485C.png" alt="图3"></p><p>可以根据自己的需要选择云产品，使用我的<strong><a href="https://promotion.aliyun.com/ntms/act/ambassador/sharetouser.html?userCode=2j1udai5&amp;utm_source=2j1udai5" target="_blank" rel="noopener">幸运券</a></strong>来实现你的幸运产品</p><p>参考链接</p><p><a href="https://bbs.aliyun.com/read/325184.html?spm=5176.2020520127.100133.6.niQOZ8" target="_blank" rel="noopener">大神引路–新手云大使入门导引</a></p>]]></content>
      
      
      <categories>
          
          <category> 闲文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闲文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谈谈Android中的JNI和NDK</title>
      <link href="/2018-1-9-Android%20JNI%E5%92%8CNDK/"/>
      <url>/2018-1-9-Android%20JNI%E5%92%8CNDK/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近发现光看源码的过程是在太枯燥了，准备开始以博客的形式来解读源码，一方面是为了能让自己更好的巩固知识点，一方面是为了能展(zhuang)现(bi)下自己</p></blockquote><p>今天要来说说<strong>JNI</strong>和<strong>NDK</strong>，最近发现使用<strong>NDK</strong>开发的需求正在不断增加啊，不管是为了能<strong>与本地的代码交互</strong>或者是为了<strong>更好的体验(使用C、C++的so)</strong>都在不断的促使我们使用<strong>NDK</strong>。</p><a id="more"></a><h4 id="什么是JNI"><a href="#什么是JNI" class="headerlink" title="什么是JNI"></a>什么是JNI</h4><ul><li>定义：<strong>JNI(Java Native Interface)</strong> Java本地接口</li><li>作用：我们可以通过<strong>JNI</strong>来使<strong>Java</strong>能与<strong>本地的其他语言(C、C++)</strong>进行<strong>交互</strong></li><li>优势：实际开发中，有时候会遇到一些性能要求的功能，而<strong>Java</strong>代码在处理性能方面远远不如<strong>C、C++</strong>，所以我们可以通过<strong>C、C++</strong>开发功能，然后通过<strong>JNI</strong>来使得<strong>Java</strong>代码与<strong>C、C++代码</strong>的交互(很多人都会举例一大堆JNI的应用场景，实际上不管是什么使用场景都是基于<strong>Java</strong>代码和<strong>其他语言</strong>的交互)，所以说JNI可以扩展JVM的能力，可以进行驱动开发，复用已有的一些开源库，而且一些产品的核心技术一般也是采用JNI开发，不易被破解</li><li>劣势：尽管<strong>JNI</strong>带来了很多的使用场景，提高了与本地语言交互的能力，但是它也带来了一些不足，我们都知道Java火爆的原因之一就是它的<strong>跨平台</strong>，但是现在<strong>JNI</strong>与本地的语言的交互导致我们需要为不同的系统的本地语言来实现不同的代码，削弱了Java的<strong>跨平台性</strong>，而且有一点就是通过JNI调用还是会比C、C++编写的原生应用要慢一点</li></ul><h4 id="什么是NDK"><a href="#什么是NDK" class="headerlink" title="什么是NDK"></a>什么是NDK</h4><ul><li>定义：NDK(Native Development Kit)，Google对其定义为一套允许您使用原生代码语言(例如C和C++)实现部分应用的工具集</li><li>作用：能让我们快速的开发C、C++的so动态库，并且将so和应用一起打包成APK</li></ul><h4 id="JNI和NDK的关系"><a href="#JNI和NDK的关系" class="headerlink" title="JNI和NDK的关系"></a>JNI和NDK的关系</h4><p>NDK为我们生成了C、C++的so动态库，JNI又提供了Java代码和其他语言(C、C++)交互的能力，这两者之间可以实现互补，可以说JNI是目的，而NDK是实现JNI的手段，通过NDK来实现JNI的功能，最后达到“Java+C”的开发方式</p><h4 id="NDK的使用"><a href="#NDK的使用" class="headerlink" title="NDK的使用"></a>NDK的使用</h4><blockquote><p>开发环境：Mac OS 10.13.2 + Android Studio 3.0</p></blockquote><h5 id="NDK的添加配置"><a href="#NDK的添加配置" class="headerlink" title="NDK的添加配置"></a>NDK的添加配置</h5><p>打开<strong>Preferences-&gt;Appearance&amp;Behavior-&gt;SystemSettings-&gt;AndroidSDK-&gt;SDKTools</strong>勾选<strong>NDK</strong>下载</p><p><img src="http://p0sgkjh7x.bkt.clouddn.com/58B7EDC0-46FF-493F-BE65-937F00D93CEF.png" alt="NDK配置添加"></p><p>等待安装完毕</p><p>我这边已经安装完毕可以在<strong>local.properties</strong>中看到</p><blockquote><p>这些是Android Studio自动生成的</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ndk.dir=/Users/lzw/Library/Android/sdk/ndk-bundle</span><br><span class="line">sdk.dir=/Users/lzw/Library/Android/sdk</span><br></pre></td></tr></table></figure><h5 id="项目中添加JNI支持"><a href="#项目中添加JNI支持" class="headerlink" title="项目中添加JNI支持"></a>项目中添加JNI支持</h5><blockquote><p>我不添加好像也可以…</p></blockquote><p>在<strong>gradle.properties</strong>中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android.useDeprecatedNdk=true</span><br></pre></td></tr></table></figure><p>然后在app的<strong>build.gradle</strong>中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &apos;com.android.application&apos;</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion 23</span><br><span class="line">    buildToolsVersion &quot;26.0.2&quot;</span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        minSdkVersion 15</span><br><span class="line">        targetSdkVersion 23</span><br><span class="line">        versionCode 1</span><br><span class="line">        versionName &quot;1.0&quot;</span><br><span class="line"></span><br><span class="line">        testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot;</span><br><span class="line"></span><br><span class="line">        ndk &#123;</span><br><span class="line">        //要支持的CPU都有哪些，可以自己选择添加</span><br><span class="line">            abiFilters &quot;armeabi-v7a&quot;,&quot;armeabi&quot;,&quot;arm64-v8a&quot;,&quot;mips&quot;,&quot;mips64&quot;</span><br><span class="line">            //生成的so名称</span><br><span class="line">            moduleName &quot;MuBaiYs7&quot;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled false</span><br><span class="line">            proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])</span><br><span class="line">    compile &apos;com.android.support:appcompat-v7:23.1.0&apos;</span><br><span class="line">    testCompile &apos;junit:junit:4.12&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点在于添加了注释的那2句话：</p><h5 id="项目中添加Java访问C的接口类"><a href="#项目中添加Java访问C的接口类" class="headerlink" title="项目中添加Java访问C的接口类"></a>项目中添加Java访问C的接口类</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class AndroidJni &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 要与C层交互的方法</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static native String getString();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 加载so，要跟build.gradle中自己定义so名称保持一致</span><br><span class="line">     */</span><br><span class="line">    static &#123;</span><br><span class="line">        System.loadLibrary(&quot;MuBaiYs7&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们会根据方法<figure class="highlight plain"><figcaption><span>function Java_com_lzw_ys7_jni_AndroidJni_getString```创建方法，然后Studio会为我们在根目录中生成一个cpp的文件夹，里面有一个.c文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![C层中的方法](http://p0sgkjh7x.bkt.clouddn.com/D618011D-DB8B-4A1A-92F5-2702CEC7FB76.png)</span><br><span class="line"></span><br><span class="line">这个文件的名称是可以自己修改的，我们查看这个文件可以发现，它就提供了一个方法，返回一个字符串，这边我们让它返回&quot;MuBaiYs7Jni&quot;</span><br></pre></td></tr></table></figure></p><p>#include &lt;jni.h&gt;</p><p>JNIEXPORT jstring JNICALL<br>Java_com_lzw_ys7_jni_AndroidJni_getString(JNIEnv *env, jobject instance) {</p><pre><code>return (*env)-&gt;NewStringUTF(env, &quot;MuBaiYs7Jni&quot;);</code></pre><p>}</p><p><code>`</code></p><h5 id="调用Java代码"><a href="#调用Java代码" class="headerlink" title="调用Java代码"></a>调用Java代码</h5><ul><li>调用Jni的方法</li></ul><p><img src="http://p0sgkjh7x.bkt.clouddn.com/A66025A1-356E-414D-9CEE-E9FC8592584E.png" alt="具体调用"></p><ul><li>运行成功后我们可以看到，说明我们调用成功</li></ul><p><img src="http://p0sgkjh7x.bkt.clouddn.com/84E09BA1-1855-4685-8439-CCD1146227B6.png" alt="运行结果"></p><h5 id="得到so文件"><a href="#得到so文件" class="headerlink" title="得到so文件"></a>得到so文件</h5><blockquote><p>这边我们是自己使用项目中的C方法，但是实际项目中很多时候都是把方法封装成so文件进行开发，类似于jar包和arr包</p></blockquote><p>我们这边直接切换项目的展示形式：<strong>Android-&gt;Project</strong><br>然后查看build-&gt;intermediates-&gt;ndk-&gt;debug-&gt;lib</p><p><img src="http://p0sgkjh7x.bkt.clouddn.com/4421444A-9F7A-427E-AF44-B12D012804AF.png" alt="ndk"></p><p>这边的<strong>libMuBaiYs7.so</strong>就是我们根据项目中的<code>jnitest.c</code>文件封装出来的<strong>so</strong>文件</p><p>我们可以把这里的<strong>so</strong>文件复制到其他项目中的<strong>lib</strong>或者是<strong>jniLibs</strong>文件中进行使用</p><blockquote><p>需要注意的是不能单独复制<strong>so</strong>文件，要将各个CPU对应的<strong>so</strong>文件分别复制出来到文件中</p></blockquote><p>这边只是NDK和Jni的入门使用，关于Jni常用的类型和方法会在其他的时间进行学习介绍</p><p>未完待续</p><hr><p>参考链接：</p><p><a href="https://developer.android.google.cn/ndk/index.html" target="_blank" rel="noopener">Android NDK</a></p><p><a href="https://www.jianshu.com/p/aba734d5b5cd" target="_blank" rel="noopener">Android JNI编程—JNI基础</a></p><p><a href="https://www.jianshu.com/p/ac00d59993aa" target="_blank" rel="noopener">Android NDK开发：JNI基础篇</a></p><p><a href="http://www.jcodecraeer.com/a/anzhuokaifa/2017/0401/7769.html" target="_blank" rel="noopener">Android Studio jni开发入门——看我就够了！</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从比特币中浅谈区块链技术</title>
      <link href="/2018-1-5-%E6%B5%85%E8%B0%88%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/"/>
      <url>/2018-1-5-%E6%B5%85%E8%B0%88%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<blockquote><p>昨天的<strong>CPIH</strong>(中国医药控股有限公司)疯狂的涨幅566%，瞬间看懵了，有消息称是因为被收购了才导致的暴涨，(到后来已经慢慢下跌，最后收盘时涨幅137%），说实话真的是跟过山车一样，心脏病都能给你吓出来😶</p></blockquote><a id="more"></a><h3 id="比特币"><a href="#比特币" class="headerlink" title="比特币"></a>比特币</h3><blockquote><p>比特币(bitcoin)的概念是中本聪在09年提出的，它是数字货币</p></blockquote><p>17年的比特币 比特币就跟过山车一样</p><p>我们想通过比特币的交易来谈谈什么是区块链</p><h3 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h3><p>来自维基百科对区块链的定义</p><blockquote><p>区块链：(英语：blockchain)是用分布式数据库识别、传播和记载信息的智能化对等网络，也称为价值互联网，中本聪在08年与《比特币白皮书》中提出了”区块链”概念，并在09年创立了比特币社会网络，开发出第一个区块，即”创世区块”。</p></blockquote><p>区块链的本质是解决信任问题，降低信任成本的技术方案，目的是为了<strong>去中心化</strong>，<strong>去信用中介</strong>，它的核心是<strong>一堆个体</strong>，是通过<strong>去中心化</strong>和<strong>去信任</strong>的方式<strong>集体</strong>维护一个可靠数据库(加密安全性)，简单来说就是<strong>分布式记账</strong>，这个账本<strong>不可撤销</strong>，<strong>不能修改</strong>，它实际上也是比特币的底层技术。</p><p><em>任意节点损坏，不会影响其他节点(损坏的节点不需要理他)</em></p><p>大数据：数据的来源维度多，不是数据多</p><p>共识机制：所有人都是认可的</p><p>大数据是牺牲一致性来换取可用性和分区容忍性的，而区块链却先优先保证一致性</p><p>去中心化和共识机制的矛盾，需要注意平衡</p><h3 id="区块链的发展"><a href="#区块链的发展" class="headerlink" title="区块链的发展"></a>区块链的发展</h3><h4 id="比特币-（1-0）"><a href="#比特币-（1-0）" class="headerlink" title="比特币 （1.0）"></a>比特币 （1.0）</h4><h4 id="数字资产和智能合约-（2-0）"><a href="#数字资产和智能合约-（2-0）" class="headerlink" title="数字资产和智能合约 （2.0）"></a>数字资产和智能合约 （2.0）</h4><h4 id="区块链大社会-3-0"><a href="#区块链大社会-3-0" class="headerlink" title="区块链大社会  (3.0)"></a>区块链大社会  (3.0)</h4><h4 id="ICO金融"><a href="#ICO金融" class="headerlink" title="ICO金融"></a>ICO金融</h4><h4 id="新能源模式"><a href="#新能源模式" class="headerlink" title="新能源模式"></a>新能源模式</h4><h4 id="智能社区"><a href="#智能社区" class="headerlink" title="智能社区"></a>智能社区</h4><h4 id="供应链管理"><a href="#供应链管理" class="headerlink" title="供应链管理"></a>供应链管理</h4><h3 id="区块链的问题"><a href="#区块链的问题" class="headerlink" title="区块链的问题"></a>区块链的问题</h3><h4 id="性能和容量问题："><a href="#性能和容量问题：" class="headerlink" title="性能和容量问题："></a>性能和容量问题：</h4><ul><li><p>去中心化和共识机制的矛盾</p></li><li><p>账本存储容量和处理性能的矛盾</p></li></ul><h4 id="安全性问题"><a href="#安全性问题" class="headerlink" title="安全性问题"></a>安全性问题</h4><ul><li><p>51%攻击</p></li><li><p>私钥与终端安全</p></li><li><p>共识机制的安全</p></li></ul><h4 id="尚未建议统一的标准"><a href="#尚未建议统一的标准" class="headerlink" title="尚未建议统一的标准"></a>尚未建议统一的标准</h4><h4 id="衍生市场混乱"><a href="#衍生市场混乱" class="headerlink" title="衍生市场混乱"></a>衍生市场混乱</h4><h3 id="从企业的角度："><a href="#从企业的角度：" class="headerlink" title="从企业的角度："></a>从企业的角度：</h3><ul><li>没有找到大的落地应用场景</li><li>区块链急速目前不够成熟，无法支撑某些业务领域</li><li>行业人才匮乏，一般公司无法组建区块链技术团队开发产品</li><li>公众的认知相对较少，接受度不高</li><li>高能耗</li><li>数据库存储空间</li><li>处理大规模交易的抗压能力</li></ul>]]></content>
      
      
      <categories>
          
          <category> 闲文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闲文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AttachInfo的初步了解和解析</title>
      <link href="/2017-12-30-AttachInfo%E7%9A%84%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3%E5%92%8C%E8%A7%A3%E6%9E%90/"/>
      <url>/2017-12-30-AttachInfo%E7%9A%84%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3%E5%92%8C%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">View&#123;</span><br><span class="line"> ...</span><br><span class="line">  /**</span><br><span class="line">   * A set of information given to a view when it is attached to its parent window.</span><br><span class="line">   */</span><br><span class="line">     final static class AttachInfo &#123;</span><br><span class="line">    interface Callbacks &#123;</span><br><span class="line">            void playSoundEffect(int effectId);</span><br><span class="line">            boolean performHapticFeedback(int effectId, boolean always);</span><br><span class="line">        &#125;</span><br><span class="line">         static class InvalidateInfo &#123;</span><br><span class="line">         ...</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        final IWindowSession mSession;</span><br><span class="line"></span><br><span class="line">        final IWindow mWindow;</span><br><span class="line"></span><br><span class="line">        final IBinder mWindowToken;</span><br><span class="line"></span><br><span class="line">        final Display mDisplay;</span><br><span class="line"></span><br><span class="line">        final Callbacks mRootCallbacks;</span><br><span class="line"></span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>View</strong>的显示过程是需要依附在<strong>Window</strong>窗口上的，而<strong>View</strong>和<strong>Window</strong>的关系是通过<strong>AttachInfo</strong>来管理的，但是实际上这个类我们使用的很少，它是View的内部类而且不是公开的，我们一般只有在ViewRootImpl等类中使用到</p><blockquote><p>我们可以通过AttachInfo来获取当前View依附的是哪个Window窗口</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从项目需求到PopupWindow在到Window的过程浅析</title>
      <link href="/2017-12-27-%E4%BB%8EPopupWindow%E5%88%B0Window%E7%9A%84%E8%BF%87%E7%A8%8B%E6%B5%85%E6%9E%90/"/>
      <url>/2017-12-27-%E4%BB%8EPopupWindow%E5%88%B0Window%E7%9A%84%E8%BF%87%E7%A8%8B%E6%B5%85%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><blockquote><p>项目中有这么个需求，底部是5个Tab选项，中间那个是一个圆形的高位按钮选项，点击中间选项会从底部弹出个布局，并且这个布局的视觉效果是要在这个圆形选项的底部…这么说有点混乱，来张效果图看看</p></blockquote><a id="more"></a><p><img src="http://p0sgkjh7x.bkt.clouddn.com/3BD32333-AE0F-4F31-8D8A-596D12178F9B.png" height="220" width="150"><strong>点击场景后</strong><br><img src="http://p0sgkjh7x.bkt.clouddn.com/388EEDFA-1AFB-4DA1-9DDD-D605717110B0.png" height="220" width="150"></p><h4 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h4><blockquote><p>看到这2个设计图的时候第一想法是底部3个<strong>tab</strong>选项然后点击场景后弹出个<strong>PopupWindow</strong>，因为用过而且用的场景还挺多的。</p></blockquote><p>然后啪啦啪啦的一堆代码出现了，下面的3个<strong>tab</strong>选项用简单的实现了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    android:background=&quot;#4FC3F3&quot;</span><br><span class="line">    android:orientation=&quot;vertical&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;RelativeLayout</span><br><span class="line">        android:id=&quot;@+id/layout&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;50dp&quot;</span><br><span class="line">        android:layout_alignParentBottom=&quot;true&quot;</span><br><span class="line">        android:background=&quot;#D8D8D8&quot;</span><br><span class="line">        android:orientation=&quot;horizontal&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;TextView</span><br><span class="line">            android:layout_width=&quot;50dp&quot;</span><br><span class="line">            android:layout_height=&quot;40dp&quot;</span><br><span class="line">            android:layout_centerVertical=&quot;true&quot;</span><br><span class="line">            android:layout_marginLeft=&quot;15dp&quot;</span><br><span class="line">            android:background=&quot;#9F79EE&quot;</span><br><span class="line">            android:gravity=&quot;center&quot;</span><br><span class="line">            android:text=&quot;智控&quot; /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &lt;TextView</span><br><span class="line">            android:layout_width=&quot;50dp&quot;</span><br><span class="line">            android:layout_height=&quot;40dp&quot;</span><br><span class="line">            android:layout_alignParentRight=&quot;true&quot;</span><br><span class="line">            android:layout_centerVertical=&quot;true&quot;</span><br><span class="line">            android:layout_marginRight=&quot;15dp&quot;</span><br><span class="line">            android:background=&quot;#9F79EE&quot;</span><br><span class="line">            android:gravity=&quot;center&quot;</span><br><span class="line">            android:text=&quot;个人&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/RelativeLayout&gt;</span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">    android:id=&quot;@+id/noun_text&quot;</span><br><span class="line">        android:layout_width=&quot;60dp&quot;</span><br><span class="line">        android:layout_height=&quot;60dp&quot;</span><br><span class="line">        android:layout_alignParentBottom=&quot;true&quot;</span><br><span class="line">        android:layout_centerHorizontal=&quot;true&quot;</span><br><span class="line">        android:background=&quot;#FFFFFF&quot;</span><br><span class="line">        android:gravity=&quot;center&quot;</span><br><span class="line">        android:text=&quot;场景&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/RelativeLayout&gt;</span><br></pre></td></tr></table></figure><p>大概的效果就是这样的，只是个初步的布局，毕竟这边是为了演示效果</p><p><img src="http://p0sgkjh7x.bkt.clouddn.com/B8E680CD-11EC-4870-9D2B-C5B1F2EDDB7E.png" height="250" width="150"></p><p>然后添加中间场景的点击事件，刚也说了想用到<strong>PopupWindow</strong>从底部弹出，然后就开始去实现设计图的效果</p><p>下面就是PopupWindow的实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private PopupWindow mPopupWindow;</span><br><span class="line">/**</span><br><span class="line"> * PopupWindow的View</span><br><span class="line"> */</span><br><span class="line">private View popView;</span><br><span class="line">/**</span><br><span class="line"> *场景TextView</span><br><span class="line"> */</span><br><span class="line">private TextView nounText;</span><br><span class="line">/**</span><br><span class="line"> *底部Layout</span><br><span class="line"> */</span><br><span class="line">private LinearLayout layout;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">super.onCreate(savedInstanceState);</span><br><span class="line">setContentView(R.layout.activity_popup);</span><br><span class="line">nounText = (TextView) findViewById(R.id.noun_text);</span><br><span class="line">layout = (LinearLayout) findViewById(R.id.layout);</span><br><span class="line">popView = LayoutInflater.from(this).inflate(R.layout.popup_layout, null);</span><br><span class="line">mPopupWindow = new PopupWindow(popView, WindowManager.LayoutParams.MATCH_PARENT, WindowManager.LayoutParams.WRAP_CONTENT);</span><br><span class="line">mPopupWindow.setOutsideTouchable(true);</span><br><span class="line"></span><br><span class="line">nounText.setOnClickListener(v -&gt; &#123;</span><br><span class="line">    mPopupWindow.showAtLocation(nounText, Gravity.CENTER_HORIZONTAL | Gravity.BOTTOM, 0, layout.getHeight());</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而想法是美好的，但是现实往往是残酷的…</p><p>最后的实现效果却是这样的</p><p><img src="http://p0sgkjh7x.bkt.clouddn.com/912830D1-3B7D-4391-BB8C-6829D68213D1.png" height="250" width="150"><strong>对比下这2个图</strong><img src="http://p0sgkjh7x.bkt.clouddn.com/B8E680CD-11EC-4870-9D2B-C5B1F2EDDB7E.png" height="250" width="150"></p><p>咋一看是没有问题，但是实际上中间的那个场景选项并没有盖在底部的那个popView上面，当时的想法就是让设计改下(😶，然而就是想想而已)</p><p>后来开始思考如果让这个<strong>PopView</strong>在场景的下面，当时有2个思路：</p><ul><li>1.通过在<strong>PopView</strong>的底部中间加个半圆形衔接下面的场景选项，营造出遮盖的视觉效果</li><li>2.因为<strong>PopupWindow</strong>是需要依附在某个组件上的，想能不能再场景的底层在添加个组件(被场景选项遮盖着)，然后让<strong>PopupWindow</strong>去依附这个看不见的组件</li></ul><p>有了思路就开始动手试试看，然而现实是这2个都不能很好实现要的效果，第一个是因为添加半圆形的时候位置很容易出错，特别是适配的时候，第二个思路的结果发现结果还是跟原来的一样，尽管<strong>PopupWindow</strong>依附的是在场景下的组件，但是效果还是跟依附场景的时候一样😓…</p><blockquote><p><strong>Why(当时想法只剩下这个了…)</strong></p></blockquote><p>要想知道原因，我们就要从<strong>PopupWindow</strong>的内部实现方法来分析</p><h4 id="PopupWindow内部方法的初步分析"><a href="#PopupWindow内部方法的初步分析" class="headerlink" title="PopupWindow内部方法的初步分析"></a>PopupWindow内部方法的初步分析</h4><blockquote><p><strong>PopupWindow</strong>它不是一个<strong>View</strong>或者是<strong>ViewGroup</strong>，所以在使用的时候需要的传入我们的布局View,这边需要注意的是它既不是<strong>View</strong>也不是<strong>ViewGroup</strong>，那么它是什么呢？</p></blockquote><ul><li><strong>PopupWindow</strong>的创建</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private PopupWindow mPopupWindow;</span><br><span class="line">/**</span><br><span class="line"> * PopupWindow的View</span><br><span class="line"> */</span><br><span class="line">private View popView;</span><br><span class="line">popView = LayoutInflater.from(this).inflate(R.layout.popup_layout, null);</span><br><span class="line">mPopupWindow = new PopupWindow(popView, WindowManager.LayoutParams.MATCH_PARENT, WindowManager.LayoutParams.WRAP_CONTENT);</span><br></pre></td></tr></table></figure><p>代码中创建<strong>PopupWindow</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public PopupWindow(View contentView, int width, int height, boolean focusable) &#123;</span><br><span class="line">/**</span><br><span class="line"> * 如果contentView不为空，通过contentView获取WindowManager对象</span><br><span class="line"> * 所以这边我们可以想到了window窗口这个对象，进而popupWindow可能跟window有关，实际上从它的命名也能猜到了</span><br><span class="line"> */</span><br><span class="line">    if (contentView != null) &#123;</span><br><span class="line">        mContext = contentView.getContext();</span><br><span class="line">        mWindowManager = (WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE);</span><br><span class="line">    &#125;</span><br><span class="line">//设置contentView</span><br><span class="line">    setContentView(contentView);</span><br><span class="line">    //设置宽度</span><br><span class="line">    setWidth(width);</span><br><span class="line">    //设置高度</span><br><span class="line">    setHeight(height);</span><br><span class="line">    //默认focusable为false</span><br><span class="line">    setFocusable(focusable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建的过程实际上很简单,通过<strong>PopupWindow</strong>的构造方法传入需要的contentView、宽、高就能够得到一个<strong>PopupWindow</strong>对象，但是我们刚也说了它不是<strong>View</strong>也不是<strong>ViewGroup</strong>那它是如何能够显示的呢</p><p>在项目使用<strong>PopupWindow</strong>的时候是通过<strong>showAtLocation</strong>方法来设置具体的显示位置的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mPopupWindow.showAtLocation(nounText, Gravity.CENTER_HORIZONTAL | Gravity.BOTTOM, 0, layout.getHeight());</span><br></pre></td></tr></table></figure><p><strong>PopupWindow</strong>还有其他的设置显示的方法，这里我们就不具体的说明，但是实际上最后都是需要用到下面这几个方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//获取WindowManager的布局参数</span><br><span class="line">final WindowManager.LayoutParams p = createPopupLayoutParams(anchor.getWindowToken());</span><br><span class="line"></span><br><span class="line">//准备Pop</span><br><span class="line">preparePopup(p);</span><br><span class="line"></span><br><span class="line">//引用Pop</span><br><span class="line">invokePopup(p);</span><br></pre></td></tr></table></figure><p>所以我们最需要关注的还是这几个方法的实现过程</p><p>返回<strong>Window</strong>的布局参数<strong>WindowManager.LayoutParams</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private WindowManager.LayoutParams createPopupLayoutParams(IBinder token) &#123;</span><br><span class="line">    final WindowManager.LayoutParams p = new WindowManager.LayoutParams();</span><br><span class="line">...//这边省略了一些关于设置布局参数p的方法</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>准备<strong>PopupWindow</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private void preparePopup(WindowManager.LayoutParams p) &#123;</span><br><span class="line"> ...</span><br><span class="line">    if (mDecorView != null) &#123;</span><br><span class="line">        mDecorView.cancelTransitions();</span><br><span class="line">    &#125;</span><br><span class="line">    if (mBackground != null) &#123;//如果mBackground不为空即设置了popupWindow的背景图片</span><br><span class="line">        mBackgroundView = createBackgroundView(mContentView);</span><br><span class="line">        mBackgroundView.setBackground(mBackground);</span><br><span class="line">    &#125; else &#123;//如果没有设置背景图片的话，让contentView==背景View</span><br><span class="line">        mBackgroundView = mContentView;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mDecorView = createDecorView(mBackgroundView);</span><br><span class="line">    mBackgroundView.setElevation(mElevation);</span><br><span class="line">    p.setSurfaceInsets(mBackgroundView, true /*manual*/, true /*preservePrevious*/);</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引用<strong>PopupWindow</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private void invokePopup(WindowManager.LayoutParams p) &#123;</span><br><span class="line">    if (mContext != null) &#123;</span><br><span class="line">        p.packageName = mContext.getPackageName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final PopupDecorView decorView = mDecorView;</span><br><span class="line">    decorView.setFitsSystemWindows(mLayoutInsetDecor);</span><br><span class="line">    </span><br><span class="line">    setLayoutDirectionFromAnchor();</span><br><span class="line">//这边通过addView方法添加我们的PopupView</span><br><span class="line">    mWindowManager.addView(decorView, p);</span><br><span class="line"></span><br><span class="line">    if (mEnterTransition != null) &#123;</span><br><span class="line">        decorView.requestEnterTransition(mEnterTransition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<strong>WindowManager</strong>的<strong>addView()</strong>把我们的<strong>PopupDecorView</strong>以及布局的参数P添加到<strong>Window</strong>上</p><hr><p>未完待续…</p><h4 id="PopupWindow延伸问题"><a href="#PopupWindow延伸问题" class="headerlink" title="PopupWindow延伸问题:"></a>PopupWindow延伸问题:</h4><blockquote><p>这里会添加一些popupWindow常见的问题，陆续更新中…</p></blockquote><ul><li><p><strong>isShowing失效问题</strong></p><p>  在实现popupWindow的过程中，点击按错出现popupWindow，然后再次点击按钮的时候，需要把popupWindow dismiss掉，实现的方法为判断是否显示isShowing，为false才让popupWindow显示</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (!popupWindow.isShowing()) &#123;</span><br><span class="line">    popupWindow.showAsDropDown(view);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul><pre><code>但是发现不管怎么样，**isShowing**一直返回为**false**，所以每次点击按钮popupWindow都会重新显示，断点查看后，发现每次点击出现popupWindow的按钮的时候都会去执行dismiss方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 这里一直返回为false</span><br><span class="line"> */</span><br><span class="line">public boolean isShowing() &#123;</span><br><span class="line">       return mIsShowing;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">public void dismiss() &#123;</span><br><span class="line">       if (!isShowing() || isTransitioningToDismiss()) &#123;</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line">       ...省略</span><br><span class="line">       </span><br><span class="line">       mIsShowing = false;//每次点击都会改变mIsShowing为false</span><br><span class="line">       </span><br><span class="line">       ...省略</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>然后又发现代码中有这么一句话<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">popupWindowLogin.setOutsideTouchable(true);</span><br></pre></td></tr></table></figure>这是为了能实现点击popupWindow外部能消失的效果，然后这里突然想到我们点击按钮的时候也属于点击popupWindow外部，所以这里先调用了**dismiss**方法改变了我们的**mIsShowing**的值知道了具体的原因后，我们发现这里主要是要让按钮的点击变成popupWindow的点击效果，所以我们只要让popupWindow在显示的时候把焦点先抢过来，然后我们点击按钮的时候，实际上就是点击popupWindow，想起来以前焦点问题的时候有这么一句话：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">popupWindowLogin.setFocusable(true);</span><br></pre></td></tr></table></figure>将焦点设置给popupWindow，然后我们再次点击按钮的时候由于焦点在popupWindow上，所以我们就可以正常的获取**mIsShowing**的值，在来执行我们的判断了。&gt; 加上代码了试了下效果，果然可行，Nice！</code></pre>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeakCancary的使用和原理</title>
      <link href="/2017-12-23-LeakCancary%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86/"/>
      <url>/2017-12-23-LeakCancary%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="目录："><a href="#目录：" class="headerlink" title="目录："></a>目录：</h3><ul><li>为什么会有<em>LeakCancary</em></li><li>什么是<em>LeakCancary</em></li><li><em>LeakCancary</em>的使用</li><li><em>LeakCancary</em>的实现过程</li></ul><a id="more"></a><hr><h4 id="Why-LeakCancary"><a href="#Why-LeakCancary" class="headerlink" title="Why LeakCancary"></a>Why LeakCancary</h4><blockquote><p><strong>Square</strong>在开源项目<strong>LeakCancary</strong>的前言就提到了</p><p><strong>“A small leak will sink a great ship”</strong></p><p>我们可以翻译过来用一句名言来表示：<br><strong>“千里之堤溃于蚁穴”</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError</span><br><span class="line">        at android.graphics.Bitmap.nativeCreate(Bitmap.java:-2)</span><br><span class="line">        at android.graphics.Bitmap.createBitmap(Bitmap.java:689)</span><br><span class="line">        at com.squareup.ui.SignView.createSignatureBitmap(SignView.java:121)</span><br></pre></td></tr></table></figure><p><strong>OOM</strong> 项目中最让人头疼的一个异常，它不像一些其他异常很显示的给你指出并且容易解决，它的产生原因一般都是内存对象的不正确使用导致GC无法正常的回收对象，进而产生内存泄露，让系统的内存空间逐渐的不够，然后导致内存溢出。</p><p><strong>Square</strong>公司有篇文章说过他们在使用Bitmap进行签名页面进行绘制过程中，创建的bitmap对象经常性的产生OOM。<br>为了解决这个问题，<strong>Square</strong>做出了很多的对策，包括：</p><ul><li>使用<strong>Bitmap.Config.ALPHA_8</strong>节省内存</li><li>手动捕获<strong>OOM</strong>，调用<strong>GC</strong></li></ul><p>但是实际上效果并不好，后来他们发现是方向错了，当系统中分配的内存已经不够了，这时候OOM可以发生在任何的地方，特别是一些大对象的使用，比如Bitmap的创建。OOM只是表象，更深层次的问题可能是：<strong>内存泄露</strong></p><p>但是在原来的时候排查内存泄露是个全手工的过程,为了解决这个问题，<strong>LeakCancary</strong>出现了。</p><h4 id="What-LeakCancary"><a href="#What-LeakCancary" class="headerlink" title="What LeakCancary"></a>What LeakCancary</h4><p><strong><a href="https://github.com/square/leakcanary" target="_blank" rel="noopener">LeakCancary</a></strong>是<strong>Square</strong>公司推出的一款Java和Android内存泄露检查框架，如果检测到某个地方产生了内存泄露，LeakCancary会生成一个显示的通知，并且在Locat会有相应的log日志提醒，通过显示的通知和log日志我们可以对内存泄露进行准确的定位并去解决它。</p><h4 id="Use-LeakCancary"><a href="#Use-LeakCancary" class="headerlink" title="Use LeakCancary"></a>Use LeakCancary</h4><p><img src="http://p0sgkjh7x.bkt.clouddn.com/374F4D1C-CDAA-4FA1-BD09-1EFEE81C4B81.png" alt="LeakCancary显示通知图"></p><p><em>LeakCancary显示通知图镇楼</em></p><p>关于<strong>LeakCancary</strong>的开源和使用，Square最初的目的是为了能更好的对app进行内存泄露的检测，而且是为了能更简的入手，所以它的使用就不会很复杂，实际上用法也是很简单：</p><ul><li>在build.gradle添加引用：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">debugCompile &apos;com.squareup.leakcanary:leakcanary-android:1.5.4&apos;</span><br><span class="line">releaseCompile &apos;com.squareup.leakcanary:leakcanary-android-no-op:1.5.4&apos;</span><br></pre></td></tr></table></figure><blockquote><p>当前最新版本为1.5.4，可以根据git上的最新版本进行升级</p></blockquote><ul><li>在<strong>自定义继承Application</strong>中添加<strong>RefWatcher</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Ys7App extends Application &#123;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * RefWatcher对象</span><br><span class="line">   */</span><br><span class="line">    private RefWatcher refWatcher;</span><br><span class="line"></span><br><span class="line">    public static RefWatcher getRefWatcher(Context context) &#123;</span><br><span class="line">        Ys7App application = (Ys7App) context.getApplicationContext();</span><br><span class="line">        return application.refWatcher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate() &#123;</span><br><span class="line">        super.onCreate();</span><br><span class="line">        refWatcher = LeakCanary.install(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>不要忘记把自定义继承的<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">然后我们就可以去写**内存泄露**了(咳咳，说错了，是去发现内存泄露)</span><br><span class="line"></span><br><span class="line">说个很常见的内存泄露问题：*关于Context对象的使用*</span><br><span class="line"></span><br><span class="line">项目中很多地方都需要用到**Context**对象,有时候我们会直接使用**Activity**的**Context**对象，有时候会使用全局的**Context**对象。关于这个我们要说说关于在**Activity**中使用单例模式的问题，很多时候我们需要去维护一个全局的方法，很容易想到用单例模式，它也是设计模式中最简单易懂的一个，但是它如果使用不好就会产生**内存泄露**问题。</span><br><span class="line"></span><br><span class="line">* TextView的一个单例实现类</span><br></pre></td></tr></table></figure></p></blockquote><p>public class TextHelper {<br>    private static TextHelper mTextHelper;<br>    private Context mContext;<br>    private TextView mTextView;</p><pre><code>private TextHelper(Context context) {    this.mContext = context;}public static TextHelper getTextHelper(Context context) {    if (null == mTextHelper) {        mTextHelper = new TextHelper(context);    }    return mTextHelper;}/** * 设置TextView的大小和颜色 * * @param textView */@SuppressLint(&quot;NewApi&quot;)public void setText(TextView textView) {    this.mTextView = textView;    this.mTextView.setTextSize(20f);    this.mTextView.setTextColor(mContext.getColor(R.color.black));}</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 这里因为我们需要引用到资源文件中的color文件，所以需要个**Context**对象</span><br><span class="line"></span><br><span class="line">* 在Activity中使用：</span><br></pre></td></tr></table></figure><p> TextHelper.getTextHelper(SDKActivity.this).setText(nameText);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt; 这里我们使用了当前**Activity**的**Context**对象</span><br><span class="line"></span><br><span class="line">这里因为在**Activity**中使用了当前的**Context**对象，看上去没什么问题，但是如果我们退出当前Activity后(引入了**LeakCancary**的前提)，会在通知栏看到产生了个内存泄露通知</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;http://p0sgkjh7x.bkt.clouddn.com/D879CC01A4E508F2835F89036A03A0A6.jpg&quot; height=&quot;250&quot; width=&quot;150&quot;/&gt;</span><br><span class="line"></span><br><span class="line">然后我们通过查看**Leaks**中的列表问题</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;http://p0sgkjh7x.bkt.clouddn.com/F6A127ED4F1BAA1DFD5CE4F6B3C8012A.jpg&quot; height=&quot;250&quot; width=&quot;150&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&gt; Leaks:由于App运行中产生了内存泄露然后显示在手机上，在这边是一个内存泄露的问题列表，然后我们可以通过查看每一项进行问题的查看</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;http://p0sgkjh7x.bkt.clouddn.com/94088C38003714DBF648267A164FF6B4.jpg&quot; height=&quot;250 &quot; width=&quot;150&quot; /&gt;</span><br><span class="line"></span><br><span class="line">这边就是我们通过leaked5.8查看的具体问题，可以看到Leaks已经帮我们把内存泄露的地方指出来了，这是因为我们的**Activity**在退出后它的**Context**对象被单例模式中的方法持有 着，但是**Activity**已经不存在了，这里就产生了内存泄露。</span><br><span class="line">&gt; 实际上这是个很简单但是又很容易犯的问题</span><br><span class="line">&gt; </span><br><span class="line">&gt; 同时我们也可以通过点击Leaks边上的**+**来进行更多信息的查看</span><br><span class="line"></span><br><span class="line">所以我们这里的话要解决这个内存泄露就要传入一个全局的**Context**对象</span><br></pre></td></tr></table></figure><p>TextHelper.getTextHelper(Application.getInstance()).setText(nameText);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">或者是直接在单例模式中直接获取全局的**Context**对象</span><br></pre></td></tr></table></figure><p>public class TextHelper {<br>    private static TextHelper mTextHelper;<br>    private Context mContext;<br>    private TextView mTextView;</p><pre><code>private TextHelper(Context context) {    this.mContext = Application.getInstance();}public static TextHelper getTextHelper() {    if (null == mTextHelper) {        mTextHelper = new TextHelper();    }    return mTextHelper;}/** * 设置TextView的大小和颜色 * * @param textView */@SuppressLint(&quot;NewApi&quot;)public void setText(TextView textView) {    this.mTextView = textView;    this.mTextView.setTextSize(20f);    this.mTextView.setTextColor(mContext.getColor(R.color.black));}</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">这里就能避免由于**Context**对象的被持有导致的**内存泄露**。</span><br><span class="line"></span><br><span class="line">&gt; 实际上我们项目开发过程中会或多或少的产生**内存泄露**，这里只是举了一个简单的例子，我们只能通过去发现然后排查解决。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### Behind LeakCancary</span><br><span class="line">&gt; 在使用框架的同时也要关注下背后的实现过程和原理</span><br><span class="line">&gt; 我们通过对源码进行一步步的分解</span><br><span class="line"></span><br><span class="line">* 返回**RefWatcher**的过程</span><br></pre></td></tr></table></figure><p>private RefWatcher refWatcher;<br>refWatcher = LeakCanary.install(this);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; 通过**install()**方法</span><br></pre></td></tr></table></figure><p>public static RefWatcher install(Application application) {<br>        return ((AndroidRefWatcherBuilder)refWatcher(application).listenerServiceClass(DisplayLeakService.class).excludedRefs(AndroidExcludedRefs.createAppDefaults().build())).buildAndInstall();<br>    }</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; 继续对**buildAndInstall()**进行分析</span><br></pre></td></tr></table></figure><p>public RefWatcher buildAndInstall() {<br>        RefWatcher refWatcher = this.build();<br>        if(refWatcher != RefWatcher.DISABLED) {<br>            LeakCanary.enableDisplayLeakActivity(this.context);<br>            ActivityRefWatcher.install((Application)this.context, refWatcher);<br>        }</p><pre><code>    return refWatcher;}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; 在这里会返回一个**AndroidRefWatcher**，所以我们在对**Activity**进行内存泄露检查的时候，不需要专门添加代码，这里的**AndroidRefWatcher**会自动的帮我们进行检查</span><br></pre></td></tr></table></figure><p>public final class ActivityRefWatcher {<br>    private final ActivityLifecycleCallbacks lifecycleCallbacks = new ActivityLifecycleCallbacks() {<br>        public void onActivityCreated(Activity activity, Bundle savedInstanceState) {<br>        }</p><pre><code>    public void onActivityStarted(Activity activity) {    }    public void onActivityResumed(Activity activity) {    }    public void onActivityPaused(Activity activity) {    }    public void onActivityStopped(Activity activity) {    }    public void onActivitySaveInstanceState(Activity activity, Bundle outState) {    }    public void onActivityDestroyed(Activity activity) {      //调用ActivityRefWatcher的watch方法       ActivityRefWatcher.this.onActivityDestroyed(activity);    }};</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 在**ActivityRefWatcher**中我们发现会有关于**Activity**生命周期的回调监听并且在**onDestroy()**中会去添加**ActivityRefWatcher**的**watch**方法，但是这里也需要注意的是**registerActivityLifecycleCallbacks()**是在Api14以后才添加的方法，所以如果要在Api14以前检测就需要自己去重写onDestory并在里面添加RefWatcher.watch()方法</span><br><span class="line"></span><br><span class="line">如果是在**Fragment**中需要检查内存泄露情况的话需要我们自己实现**RefWatcher**的**watch**方法</span><br></pre></td></tr></table></figure><p>public class BaseFragment extends Fragment {</p><pre><code>@Overridepublic void onDestroy() {    super.onDestroy();    //返回一个RefWatcher对象    RefWatcher refWatcher = Ys7App.getRefWatcher(getActivity());    refWatcher.watch(this);}</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; 在这里有个疑问，为什么**Square**公司在设计**LeakCancary**的时候，考虑到了**Activity**，添加了对应的**ActivityRefWatcher**，但是对于碎片**Fragment**并没有去设计对应的**FragmentRefWatcher**方法,不知道是因为Fragment的生命周期过多还是其他的原因，也许我们可以自己根据**ActivityRefWatcher**的实现方法设计一套自己的**FragmentRefWatcher**，先留个想法...</span><br><span class="line"></span><br><span class="line">* RefWatcher是如何能够对内存泄露进行检测的</span><br><span class="line"></span><br><span class="line">通过观察RefWatcher的watch()方法</span><br></pre></td></tr></table></figure><p>public void watch(Object watchedReference, String referenceName) {<br>if(this != DISABLED) {<br>…<br>long watchStartNanoTime = System.nanoTime();<br>String key = UUID.randomUUID().toString();<br>this.retainedKeys.add(key);<br>//创建一个KeyedWeakReference弱引用对象<br>KeyedWeakReference reference = new KeyedWeakReference(watchedReference, key, referenceName, this.queue);<br>this.ensureGoneAsync(watchStartNanoTime, reference);<br>}<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里创建了一个**KeyedWeakReference**对象，这是个弱引用的对象</span><br></pre></td></tr></table></figure><p>private void ensureGoneAsync(final long watchStartNanoTime, final KeyedWeakReference reference) {<br>//执行操作，检查弱引用对象是否被清除<br>this.watchExecutor.execute(new Retryable() {<br>    public Result run() {<br>        return RefWatcher.this.ensureGone(reference, watchStartNanoTime);<br>    }<br>});<br>}</p><p>Result ensureGone(KeyedWeakReference reference, long watchStartNanoTime) {<br>…<br>if(this.debuggerControl.isDebuggerAttached()) {<br>    return Result.RETRY;<br>} else if(this.gone(reference)) {<br>    return Result.DONE;<br>} else {<br>    //手动调用GC<br>    this.gcTrigger.runGc();<br>    this.removeWeaklyReachableReferences();<br>    //如果弱引用对象还存在，则说明内存泄露了，生成hprof文件<br>     if(!this.gone(reference)) {<br>                File heapDumpFile = this.heapDumper.dumpHeap();<br>                …<br>                this.heapdumpListener.analyze(new HeapDump(heapDumpFile, reference.key, reference.name, this.excludedRefs, watchDurationMs, gcDurationMs, heapDumpDurationMs));<br>            }<br>     }<br>    return Result.DONE;<br>}<br>//retainedKeys中是否包含弱引用对象的key<br>private boolean gone(KeyedWeakReference reference) {<br>        return !this.retainedKeys.contains(reference.key);<br>    }<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在**WatchExector**的后台线程中执行检查弱引用对象是否被清除，如果没有清除，则调用一次GC，(这边能够检查弱引用对象还是根据**KeyedWeakReference**是以key-value形式存在的对象)</span><br><span class="line">如果弱引用对象没有被清除，则说明内存泄露了，系统就导出hprof文件,保存在app系统目录下</span><br></pre></td></tr></table></figure><p>final class KeyedWeakReference extends WeakReference<object> {<br>        //key-value形式存在<br>    public final String key;<br>    public final String name;</object></p><pre><code>KeyedWeakReference(Object referent, String key, String name, ReferenceQueue&lt;Object&gt; referenceQueue) {    super(Preconditions.checkNotNull(referent, &quot;referent&quot;),     ...</code></pre><p>}</p><p><code>`</code></p><hr><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>根据<strong>Square</strong>公司的数据说明他们在使用了<strong>LeakCancary</strong>后，减少了<strong>94%</strong>由OOM导致的cash。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2017年年度总结+2018年目标展望</title>
      <link href="/2017-12-22-2017%E5%B9%B4%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
      <url>/2017-12-22-2017%E5%B9%B4%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<blockquote><p>2017年转眼也只剩下几天了，想想是该对自己的一年进行个总结了，还有对2018年进行一个延伸。</p><p>话说2017年感觉自己过得有点乱，想来最多的原因还是没有一个很好的规划</p></blockquote><p>2017年的自己可以总结为：<strong>工作</strong>、<strong>技术学习</strong>、<strong>业务学习</strong>、<strong>其他业余学习</strong></p><a id="more"></a><h4 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h4><blockquote><p><em>工作是主要的重点，毕竟作为一名公司人，上班才是最重要的一个环节</em></p></blockquote><ul><li><p>经纪通：</p><blockquote><p>经纪通App是一款经纪人联动软件，支持在线报备客户、跟踪客户进度，坚持三天结佣、七天到账，让天下没有难卖的房</p></blockquote><p>  未公开内容…</p></li><li><p>筑家易：</p><blockquote><p>筑家易App提供全新的购房体验，充分考虑到投资、自住、置换以及家装家居等需求，致力构建从房到家的移动互联网的产业链平台</p></blockquote><p>  未公开内容…</p></li><li><p>中策通：</p><blockquote><p>中策通App是基于经纪通延伸出来的提供给第三方使用的产品</p></blockquote><p>  未公开内容…</p></li><li><p>经纪通重构：</p><blockquote><p>主要是重构老版经纪通的代码，原有的项目代码结构混乱，耦合性太高</p></blockquote><p>  未公开内容…</p></li><li><p>楼掌柜分销：</p><blockquote><p>楼掌柜分销是房产分销App，提供房产信息联动自由经纪人和企业用户，包括佣金结佣、房贷计算器、客户报备等</p></blockquote><p>  未公开内容…</p></li></ul><h5 id="工作总结："><a href="#工作总结：" class="headerlink" title="工作总结："></a>工作总结：</h5><p>17年中主要是负责了5个App的功能迭代和产品优化，整个开发过程中尽管磕磕碰碰遇到了不同的问题，但是总体上来说还是朝着一个向上的趋势不断的进行着，而且最重要的是在问题中成长，一个问题的产生往往代表着自己某块知识点的缺失，解决问题的过程就是补充知识的过程，所以说整个17年工作中还是收获很大。</p><h4 id="技术学习"><a href="#技术学习" class="headerlink" title="技术学习"></a>技术学习</h4><blockquote><p><em>作为一名软件开发人员(码农)，不断学习是必须的，不管是为了更好的工作还是更进一步的成长,下面是17年学习的语言，有些是有了初步的接入项目中使用，有些还是停留在学习中</em></p></blockquote><ul><li><p>Kotlin</p><blockquote><p>Kotlin是一个基于JVM的新的编程语言，由JetBrains开发，已正式成为Android官方支持开发语言。</p><ul><li>楼掌柜分销App中用Kotlin语言开发</li><li>其他项目中简单的页面初步使用Kotlin进行开发</li></ul></blockquote></li><li><p>RxJava+RxAndroid</p><blockquote><p>实现异步操作的库</p><ul><li>筑家易App利用RxJava+RxAndroid封装网络请求框架</li></ul></blockquote></li><li><p>Python</p><blockquote><p>大数据、机器学习的兴起，导致Python语言一度成为热门，而且Python入门简单、易读、易维护的风格更加受到开发者的欢迎和使用</p><ul><li>利用Python获取最近天气情况</li><li>利用Python实现从网络获取图片并保存到本地</li></ul></blockquote></li><li><p>R语言</p><blockquote><p>R 用于统计分析、绘图的语言和操作环境，R是属于GNU系统的一个自由、免费、源代码开放的软件，它是一个用于统计计算和统计制图的优秀工具</p><ul><li>目前正处于学习中，后期可以使用R进行数据的统计分析</li></ul></blockquote></li><li><p>React Native</p><blockquote><p>Facebook推出的跨平台移动应用开发框架，使用Jsx、Css来开发移动应用支持iOS和Android。</p><ul><li>目前关于React Native还停留在学习的阶段，后续学习更多后会在项目中接入使用</li></ul></blockquote></li><li><p>Groovy</p><blockquote><p>Groovy是一种基于JVM(Java虚拟机)的敏捷开发语言，它结合了Python、Ruby和Smalltalk的许多强大的特性,能够和Java代码很好的结合。</p><ul><li>build.gradle中的多渠道打包</li><li>apk批量上传</li></ul></blockquote></li><li><p>利用Git+Jekyll搭建个人博客</p><blockquote><p>写个人博客不仅仅是展示自我的时候，更是反问自己和提高自己的机会</p><ul><li>通过git+jekyll初步搭建</li><li>使用jekyll的theme来使得博客更加人性化</li><li>陆陆续续维护个人博客20多篇</li></ul></blockquote></li></ul><h5 id="技术学习总结"><a href="#技术学习总结" class="headerlink" title="技术学习总结"></a>技术学习总结</h5><p>17年接触了很多的新技术，一些是新的语言，一些是项目中可以用到的新技术，在使用新技术的过程中发现了很多的问题，通过资料和文档一个个都解决了，解决的过程更是对新技术的进一步学习，总体来说新技术的学习才是避免自己不被淘汰的原因</p><h4 id="业务学习"><a href="#业务学习" class="headerlink" title="业务学习"></a>业务学习</h4><blockquote><p><em>励志成为全栈，不能只会技术，业务方面也要去学习和了解</em></p></blockquote><ul><li><p>新房产业务</p><blockquote><p>新房产业务既从线下转到线上在到线上转到线下最后是线上线下，形成一个闭环，基于移动互联网和大数据给房产服务形成一个完整的体系结构，原有的线下销售转到线上进行，线上的虚拟服务在到线下的真实服务最后到线上线下的的结合服务</p></blockquote></li><li><p>CRM业务</p><blockquote><p>CRM,既客户关系管理系统，是企业为提高核心竞争力，利用相应的信息技术以及互联网技术来协调企业与顾客之间在销售、营销和服务上的交互，从而提升其管理方式，向客户提高创新式的个性化的客户交互和服务的过程</p></blockquote></li></ul><h5 id="业务学习总结"><a href="#业务学习总结" class="headerlink" title="业务学习总结"></a>业务学习总结</h5><p>一个开发不能只满足与自己的代码，要去兼顾业务方面的学，而且更重要的是要去学习业务的流程这样才能更好的开发出稳定、优秀的产品。最主要的是了解业务后能对自己的产品产生更多的情感，能对产品开发投入更多的精力，所以说一个开发学习业务是一个很重要的环节</p><h4 id="其他业余学习"><a href="#其他业余学习" class="headerlink" title="其他业余学习"></a>其他业余学习</h4><blockquote><p><em>面对日涨愈高的房价，单靠工资想买得起房子真的很难</em></p></blockquote><ul><li><p>理财</p><blockquote><p>理财包括：基金、股票、黄金、买房、p2p等</p></blockquote><ul><li>基金</li><li>股票</li><li>黄金</li><li>买房</li><li>p2p</li></ul></li><li><p>新媒体</p><blockquote><p>新媒体作为一种新的媒体形态，是相对于报刊、广播、电视等传统媒体以后发展起来的，通过互联网、无线通信网、有限网等渠道以及电脑、手机、数字电视剧等终端，向用户提供信息和娱乐的传播形态和媒体形态。</p><ul><li>个人公众号</li><li>个人博客</li></ul></blockquote></li></ul><h5 id="业余学习总结"><a href="#业余学习总结" class="headerlink" title="业余学习总结"></a>业余学习总结</h5><p>业余学习一方面是为了提高自己的生活质量，一方面是为了扩充自己的知识面</p><hr><h3 id="2018年规划"><a href="#2018年规划" class="headerlink" title="2018年规划"></a>2018年规划</h3><p>2018年目标会在17年总结的基础上进一步的延伸</p><h4 id="工作-1"><a href="#工作-1" class="headerlink" title="工作"></a>工作</h4><blockquote><p>从目前的中级开发向高级开发迈进，以及向更高的专家级展望</p></blockquote><ul><li>解耦原来的项目代码</li><li>完成项目功能的迭代和优化</li><li>优化项目、提高稳定性、减少内存泄露、减少apk大小</li><li>项目中添加热修复，使用热更新提高用户体验</li><li>组件开发+模块开发+插件化开发等开发模式的引入和使用</li><li>敏捷开发+单元测试</li></ul><h4 id="技术学习-1"><a href="#技术学习-1" class="headerlink" title="技术学习"></a>技术学习</h4><blockquote><p>不断完善自己的技术学习栈</p></blockquote><ul><li>数据结构和算法</li><li>Html5+JavaScript+Css</li><li>Php</li><li>Java后台</li><li>Linux</li></ul><h4 id="业务学习-1"><a href="#业务学习-1" class="headerlink" title="业务学习"></a>业务学习</h4><blockquote><p>业务学习是体现自己和其他开发人员的优势区别之一</p></blockquote><ul><li>产品理念</li><li>用户体验</li><li>线上线下</li></ul><h4 id="其他业余学习-1"><a href="#其他业余学习-1" class="headerlink" title="其他业余学习"></a>其他业余学习</h4><blockquote><p>业余学习是为了更好的满足自己的生活</p></blockquote><ul><li>ps</li><li>设计</li></ul>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安卓的进程保活</title>
      <link href="/2017-12-21-%E8%BF%9B%E7%A8%8B%E4%BF%9D%E6%B4%BB/"/>
      <url>/2017-12-21-%E8%BF%9B%E7%A8%8B%E4%BF%9D%E6%B4%BB/</url>
      
        <content type="html"><![CDATA[<blockquote><p><em>安卓进程保活真的好烦啊…</em></p><p>我想每一个在实现安卓的进程保的开发者都是这样的想法吧(什么，你没有这个想法，那你就收下我的膝盖吧…)</p><p>在我们的应用开发中有时候需要我们的app时刻的运行着，比如IM类的、屏幕保护等等,这些都需要一直运行在后台中，如果被系统Kill了就没有<br>办法提服务,所以就有了进程保活</p></blockquote><a id="more"></a><h4 id="进程的分类：-根据优先级排列"><a href="#进程的分类：-根据优先级排列" class="headerlink" title="进程的分类：(根据优先级排列)"></a>进程的分类：(根据优先级排列)</h4><ul><li>前台进程</li></ul><p>进程持有这些：可见的并且与用户交互的Activity、绑定在可见并且与用户交互的Activity的Service、通过startForeground()启动的Service、一个Service正在执行它的onCreat、onStart、onDestory、一个BroatcastReceiver正在执行它的onReceiver方法</p><blockquote><p>一般系统不会去杀死这些前台进程</p></blockquote><ul><li>可见进程</li></ul><p>进程持有这些：不在前台，但是可见的Activity、绑定在不在前台，可见Activity的Service</p><blockquote><p>用户看得见，但是不能操作，一般系统也不会去杀死这些可见进程</p></blockquote><ul><li>服务进程</li></ul><p>进程持有这些：通过startService启动的Service</p><blockquote><p>在内存不足维持前台进程和可见进程的时候，服务进程会被杀死</p></blockquote><ul><li>后台进程</li></ul><p>用户按了Home键和back键，程序不可见了，但是其实还是在运行的程序</p><blockquote><p>系统很容易去杀死这些进程</p></blockquote><ul><li>空进程</li></ul><blockquote><p>这种进程里面不包含任何的东西，没有实际作用，最容易被杀死的进程，没有之一…</p></blockquote><h4 id="进程为什么被杀死"><a href="#进程为什么被杀死" class="headerlink" title="进程为什么被杀死"></a>进程为什么被杀死</h4><p>进程被杀死的原因：</p><ul><li>被系统杀死了</li></ul><blockquote><p>安卓系统是基于Linux系统的，继承了Linux的内存管理策略，进程退出后不会立马杀死，会在内存不够的时候在去按照进程的优先级去杀死进程腾出内存</p></blockquote><ul><li>被第三方软件杀死</li></ul><blockquote><p>360之类的</p></blockquote><ul><li>被用户手动杀死</li></ul><blockquote><p>系统自带的一键清理、手机设置应用管理器的ForceClose</p></blockquote><h4 id="进程保活的方法"><a href="#进程保活的方法" class="headerlink" title="进程保活的方法"></a>进程保活的方法</h4><ul><li>提高进程的优先级</li></ul><blockquote><p>开启一个像素的Activity(QQ的保活方案)</p><p>启动前台Service</p></blockquote><ul><li>在进程杀死后，进行拉起</li></ul><blockquote><p>监听系统的广播，拉起进程(网络变化、解锁屏幕、开机等但是已经被N了)</p><p>双进程相互唤起</p><p>依靠系统唤起</p><p>多个app之间相互唤醒，阿里系列的app、腾讯系列的app</p></blockquote><ul><li>依靠第三方</li></ul><blockquote><p>各个终端对应的推送，小米的小米推送、华为的华为推送，其他的可以接入其他的其他推送</p></blockquote><ul><li>JobScheduler</li></ul><blockquote><p>5.0之后推出的进程死后复活一种方式</p></blockquote><ul><li><p>粘性服务与系统服务捆绑</p></li><li><p>账号同步唤醒，利用android自身的同步进制进行拉活</p></li></ul><hr><p>附：网上一个大神的关于<a href="http://blog.csdn.net/marswin89/article/details/48015453" target="_blank" rel="noopener">进程保活的方案</a>，通过对进程的分析、常见的进程保活以及到最后的nvtive实现的进程保活(从Android到Linux，从Java到C，看的我一脸懵逼…)</p><blockquote><p>妈妈问我为什么跪着看 囧…</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>插件化的必然</title>
      <link href="/2017-12-17-%E4%B8%BA%E4%BD%95%E4%BC%9A%E6%9C%89%E6%8F%92%E4%BB%B6%E5%8C%96%E7%9A%84%E5%BF%85%E7%84%B6/"/>
      <url>/2017-12-17-%E4%B8%BA%E4%BD%95%E4%BC%9A%E6%9C%89%E6%8F%92%E4%BB%B6%E5%8C%96%E7%9A%84%E5%BF%85%E7%84%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>一个项目，随着时间和业务的推移，会变得越来越庞大和臃肿，越来越多的功能堆积导致我们一次编译运行要等上半天，像我们公司的一个线上项目，原来打包发布的时候只有10M的apk，后来为了接入一个第三方的SDK，导致项目apk活生生撸到了40M，每次编译运行都要等个半天！囧…所以这时候产生了插件化,插件化使我们可以通过动态的加载、删除，那些独立的插件apk可以在线下载安装，有利于减少apk的体积同时也可以通过插件化时实现热修复。现在有很多热门的插件化方案：阿里的Atlas,滴滴的VirtualApk，360的RePlugin等。</p></blockquote><a id="more"></a><p>说到<strong>插件化</strong>我们就不得不说说2个跟它很类似的<strong>模块化</strong>和<strong>组件化</strong></p><h5 id="模块化："><a href="#模块化：" class="headerlink" title="模块化："></a>模块化：</h5><p>模块化是根据业务对项目进行分离成莫干个模块的过程，例如一个消息模块、城市查询模块等。</p><h5 id="组件化："><a href="#组件化：" class="headerlink" title="组件化："></a>组件化：</h5><p>组件化是根据功能来实现分离，例如一个下拉刷新组件、上拉加载组件等。</p><blockquote><p>一个模块可以依赖多个组件，组件一般不会去依赖其他组件</p></blockquote><p>然后我们在来说说<strong>插件化</strong></p><h5 id="插件化"><a href="#插件化" class="headerlink" title="插件化"></a>插件化</h5><p>插件化和模块化差不多，但是它跟模块化的最大区别在于它可以打独立的apk包，而模块化不会去打成独立的apk，只会去生成model然后依赖到主app中</p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安卓组件化到模块化</title>
      <link href="/2017-12-15-%E8%81%8A%E8%81%8A%E4%BB%8E%E5%AE%89%E5%8D%93%E7%BB%84%E4%BB%B6%E5%8C%96%E5%88%B0%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E8%BF%87%E7%A8%8B/"/>
      <url>/2017-12-15-%E8%81%8A%E8%81%8A%E4%BB%8E%E5%AE%89%E5%8D%93%E7%BB%84%E4%BB%B6%E5%8C%96%E5%88%B0%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初步解读安卓组件化</title>
      <link href="/2017-12-13-%E5%88%9D%E6%AD%A5%E8%A7%A3%E8%AF%BB%E5%AE%89%E5%8D%93%E7%BB%84%E4%BB%B6%E5%8C%96/"/>
      <url>/2017-12-13-%E5%88%9D%E6%AD%A5%E8%A7%A3%E8%AF%BB%E5%AE%89%E5%8D%93%E7%BB%84%E4%BB%B6%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<blockquote><p>以下的内容纯属个人理解，不对之处…</p></blockquote><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>项目开发中，我们会用到许许多多系统的组件、自定义的组件，也许刚开始的时候我们只是重复的使用的组件(<em>往往这些组件会在多个项目中重复的使用，毕竟国内的App说实话创意真的是挺少的</em>)，但是随着我们开发经验的增加，有一天也许就有想能不能把这些组件进行封装出来，可以满足多个项目的需求呢，这时候就产生了<em>组件化</em>。</p><a id="more"></a><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p><strong>组件化</strong>，就是根据组件将项目进行分离成若干个组件，比如<strong>下拉刷新组件</strong>、<strong>上拉加载组件</strong>等等。这些组件不能单独的运行，必须依赖于主App中才能运行，但是可以依赖到不同项目的主App中。避免了重复的造轮子，提高了开发的效率(对于外包的项目有组件化简直不能再舒服了…)</p><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>这里先引一张个人项目的图</p><p><img src="http://p0sgkjh7x.bkt.clouddn.com/5BD17723-39D7-4AE9-A01C-F44C4930A428.png" width="150" height="200"></p><p>这里的<strong>lib_load</strong>和<strong>lib_refresh</strong>就是项目的刷新和加载的组件(关于上图的那几个mode可以去<a href="https://momubai.github.io/2017/12/15/%E8%81%8A%E8%81%8A%E4%BB%8E%E5%AE%89%E5%8D%93%E7%BB%84%E4%BB%B6%E5%8C%96%E5%88%B0%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E8%BF%87%E7%A8%8B.html" target="_blank" rel="noopener">关于安卓的模块化</a>进行查看)，它们是依附在app里的，只需要在build导入lib</p><p><img src="http://p0sgkjh7x.bkt.clouddn.com/879E01F0-E625-49C7-B36A-F217887E3228.png" width="150"></p><p>就可以在app中使用</p><p>xw</p><blockquote><p>未完待续</p></blockquote><hr><h4 id="附言"><a href="#附言" class="headerlink" title="附言"></a>附言</h4><blockquote><p>组件化说是根据组件进行分离，但是有时候也可以根据功能进行分离(<strong><a href="https://momubai.github.io/2017/12/15/%E8%81%8A%E8%81%8A%E4%BB%8E%E5%AE%89%E5%8D%93%E7%BB%84%E4%BB%B6%E5%8C%96%E5%88%B0%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E8%BF%87%E7%A8%8B.html" target="_blank" rel="noopener">模块化</a></strong>：模块是根据功能进行分离的)，比如一个日间夜间模式切换、轮播图功能(轮播图说它是功能呢也可以，说是组件呢也没错)，所以说这里很多时候不会去那么的计较，毕竟每个人对组件的概念都是不一样的,有可能在你这里认为是一个组件，但是到他那里可能就是个模块了</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈安卓项目中的从MVC到MVP在到MVVM架构模式</title>
      <link href="/2017-12-9-%E6%B5%85%E8%B0%88%E5%AE%89%E5%8D%93%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E4%BB%8EMVC%E5%88%B0MVP%E5%9C%A8%E5%88%B0MVVM%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/"/>
      <url>/2017-12-9-%E6%B5%85%E8%B0%88%E5%AE%89%E5%8D%93%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E4%BB%8EMVC%E5%88%B0MVP%E5%9C%A8%E5%88%B0MVVM%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h5 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h5><blockquote><p>MVC(模型Model-视图View-控制器Controller)的缩写，是一种软件的设计典范。主要是用来将业务逻辑和数据以及界面进行分离的架构方式。MVC最早是用来桌面程序上的，已经发展了几十年了，可以说得上是最经典的框架模式。</p></blockquote><a id="more"></a><p>实际上MVC没有一个具体标准的说法，每个人都有着不同的理解！具体可以看下<a href>混乱的MVC架构</a></p><ul><li>View：对应布局文件.xml</li><li>Model：业务逻辑和实体模型</li><li>Controller：对应于Activity</li></ul><p>View可以与Model直觉交互<br>Controller是基于行为的，并且可以被多个View共享，可以负责决定显示哪个View</p><h5 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h5><blockquote><p>MVP(模型Model-视图View-主持者Presenter)是MVC的进一步改进，原来的MVC的三层结构之间的联系性较高，对View和Model层来说分离的不够彻底。MVP中的P层则是完全起到连接V-M的作用，M和V层之间没有相互操作的关系。</p></blockquote><p>在项目中，mvp是需要我们自己去封装</p><h5 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h5><blockquote><p>MVVM(模型Model-视图View-视图模型ViewModel)</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>混乱的MVC架构模式相关</title>
      <link href="/2017-12-5-%E6%B7%B7%E4%B9%B1%E7%9A%84MVC%E6%9E%B6%E6%9E%84/"/>
      <url>/2017-12-5-%E6%B7%B7%E4%B9%B1%E7%9A%84MVC%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<blockquote><p>MVC(模型Model-视图View-控制器Controller，1982年)是一种软件设计的典范，它采用将业务逻辑、数据、界面进行分离的方式组织代码。但是它作为最基本的架构模式，至今已经发展了几十年，却没有一个明确的标准，每个人都有着自己的看法，对于它的实现方式也有着许多的不同。今天我们就来谈谈MVC是怎么混乱的。</p></blockquote><a id="more"></a><p><img src alt="MVC图片"></p><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><ul><li>Model：模型，对应的在我们的项目中就是数据类(数据的存储、操作等)</li><li>View：视图，可以理解为用来显示数据的界面，对于用户来说是最直观能看到的东西(一般对应项目中的布局xml)</li><li>Controller：控制器，用来处理用户交互的部分，通常是从视图读取数据，控制用户的输入，想Model发送数据等等(具体可以去看我们的Activity，一般来说我们在项目中把Controoler对应我们Activity，它的作用我想大家都能够说出个一二三四来,我在这里就不多加内容)</li></ul><h5 id="关于混乱"><a href="#关于混乱" class="headerlink" title="关于混乱"></a>关于混乱</h5><p><strong>一千个读者就有一千个哈利波特，一千个乘客就有一千个老司机</strong></p><p>ASP.NET MVC</p><p>这是<a href="https://msdn.microsoft.com/en-us/library/dd381412(v=vs.108" target="_blank" rel="noopener">ASP.NET MVC</a>.aspx)中对于MVC的描述定义。</p><p><img src="https://i-msdn.sec.s-msft.com/dynimg/IC263184.png" alt="MVC示意图"></p><p>原谅我直接盗图…</p><p><em>ASP.NET</em> 对于这个示意图仅仅是通过几个箭头来表示之间的关系，但是我们可以从图片从得到我们所能看到的关系：</p><ul><li>1.Controller即控制器它负责对View和Model进行管理，它能直接操作到View和Model</li><li>2.View来显示Model的数据</li></ul>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2017-12-3-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2017-12-3-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h4 id="设计模式的分类："><a href="#设计模式的分类：" class="headerlink" title="设计模式的分类："></a>设计模式的分类：</h4><ul><li>创建型模式：</li></ul><blockquote><p>工厂模式、抽象工厂模式、单例模式、建造者模式、原型模式</p></blockquote><ul><li>结构型模式：</li></ul><blockquote><p>适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式</p></blockquote><ul><li>行为型模式：</li></ul><blockquote><p>策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式</p></blockquote><a id="more"></a><h4 id="设计模式的六大原则："><a href="#设计模式的六大原则：" class="headerlink" title="设计模式的六大原则："></a>设计模式的六大原则：</h4><blockquote><p>核心思想还是<strong>高内聚低耦合</strong></p></blockquote><ul><li><p>开闭原则</p><blockquote><p>对扩展开放，对修改关闭</p></blockquote></li><li><p>里氏代换原则</p></li></ul><blockquote></blockquote><ul><li>依赖倒转原则</li><li><p>接口隔离原则</p><blockquote><p>使用多个隔离的接口，比使用单个接口要好，其实还是要降低耦合性</p></blockquote></li><li><p>迪米特原则(最少知道原则)</p><blockquote><p>一个类或者接口应该尽量少的和其他类或接口相互知道，使得系统功能模块相对独立</p></blockquote></li><li><p>合成复用原则</p><blockquote><p>尽量使用合成/聚合的方式，而不是使用继承</p></blockquote></li></ul><h5 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a><strong>工厂模式</strong></h5><p>工厂模式：把对象的创建放到一个工厂类中，通过参数或者是不同的方法来创建不同的对象，缺点在于每添加一个对象，都要去修改原来的工厂。</p><ul><li>普通工厂模式</li></ul><blockquote><p>建立一个工厂类，对实现了同一接口的一些类进行实例的创建</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class RunFactory &#123;</span><br><span class="line">    </span><br><span class="line">    public RunInterface runType(String type) &#123;</span><br><span class="line">        if (&quot;A&quot;.endsWith(type)) &#123;</span><br><span class="line">            return new ARuning();</span><br><span class="line">        &#125; else if (&quot;B&quot;.endsWith(type)) &#123;</span><br><span class="line">            return new BRuning();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>多个工厂模式</li></ul><blockquote><p>对普通工厂模式的改进，在普通工厂模式中如果传递的参数出错，则不能正确创建对象，而多个工厂模式是提供了多个工厂方法，分别创建对象</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class RunMoreFactory &#123;</span><br><span class="line">    public RunInterface runA() &#123;</span><br><span class="line">        return new ARuning();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public RunInterface runB() &#123;</span><br><span class="line">        return new BRuning();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>静态工厂模式</li></ul><blockquote><p>对普通工厂模式和多个工厂模式的扩展，在静态工厂中提供静态的工厂方法，不需要创建实例，直接调用就可以</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class RunStaticFactory &#123;</span><br><span class="line"></span><br><span class="line">    public static RunInterface runA() &#123;</span><br><span class="line">        return new ARuning();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static RunInterface runB() &#123;</span><br><span class="line">        return new BRuning();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>好处</li></ul><blockquote><p>工厂模式看上去就是把new封装出来，虽然看上去很简单，但是实际上这恰恰就是通往架构师路上必须要学会的！因为我们要new一个实体对象实际上是一件需要非常谨慎的事情，不要随便的new，最好不要自己去new，让别人去new，传给你去调用。让谁去new，让专门的一个工厂去new。这就是工厂模式！<strong>new 其实是一种硬编码</strong></p></blockquote><h5 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a><strong>抽象工厂</strong></h5><p>抽象工厂：创建多个工厂类，每个对象的创建都由专门的一个工厂去创建，一个工厂保存一个new，符合<strong>不改代码</strong>原则</p><ul><li>需要实现的接口：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface FlyInterface &#123;</span><br><span class="line">    void fly();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>专门生产工厂的类：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface FlyFactoryProduce &#123;</span><br><span class="line">    FlyInterface produce();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>工厂A：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class AFlyFactory implements FlyFactoryProduce &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public FlyInterface produce() &#123;</span><br><span class="line">        return new AFly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>工厂B：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class BFlyFactory implements FlyFactoryProduce &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public FlyInterface produce() &#123;</span><br><span class="line">        return new BFly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>A实现：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class AFly implements FlyInterface &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void fly() &#123;</span><br><span class="line">        Log.d(&quot;AFly&quot;, &quot;AFly&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>B实现：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class BFly implements FlyInterface &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void fly() &#123;</span><br><span class="line">        Log.d(&quot;BFly&quot;, &quot;BFly&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>调用：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FlyInterface AflyInterface = new AFlyFactory().produce();</span><br><span class="line">AflyInterface.fly();</span><br><span class="line"></span><br><span class="line">FlyInterface BflyInterface = new BFlyFactory().produce();</span><br><span class="line">BflyInterface.fly();</span><br></pre></td></tr></table></figure><h5 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a><strong>单例模式</strong></h5><p>单例模式：有时候，我们在程序中只需要某个类同时保留一个对象，不希望有更多的对象</p><h5 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h5><ul><li><p>单例模式只能有一个实例</p></li><li><p>单例类必须创建自己的唯一实例</p></li><li><p>单例类必须向其他对象提供这一实例</p></li></ul><p>常见的单例模式实现方式：</p><ul><li>懒汉，线程不安全</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class SingletonHelper &#123;</span><br><span class="line"></span><br><span class="line">    private static SingletonHelper ourInstance = null;</span><br><span class="line"></span><br><span class="line">    private SingletonHelper() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 懒汉，线程不安全</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static SingletonHelper getInstance() &#123;</span><br><span class="line">        if (ourInstance == null) &#123;</span><br><span class="line">            ourInstance = new SingletonHelper();</span><br><span class="line">        &#125;</span><br><span class="line">        return ourInstance;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>缺点在于多线程不能正常工作</p><ul><li>懒汉，线程安全</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class SingletonHelper &#123;</span><br><span class="line"></span><br><span class="line">    private static SingletonHelper ourInstance = null;</span><br><span class="line"></span><br><span class="line">    private SingletonHelper() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 懒汉，线程安全</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static SingletonHelper getInstance() &#123;</span><br><span class="line">        if (ourInstance == null) &#123;</span><br><span class="line">            synchronized (ourInstance) &#123;</span><br><span class="line">                if (ourInstance == null) &#123;</span><br><span class="line">                    ourInstance = new SingletonHelper();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ourInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法能在多线程中很好的工作，但是实际情况下，需要同步的时候非常少，因此会耗费一定资源</p><ul><li>饿汉</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class SingletonHelper &#123;</span><br><span class="line"></span><br><span class="line">    private static SingletonHelper inInstance = new SingletonHelper();</span><br><span class="line"></span><br><span class="line">    private SingletonHelper() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static SingletonHelper getInInstance()&#123;</span><br><span class="line">        return inInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点一开始就进行实例化，没有能做到lazy-loading</p><ul><li>饿汉，变种</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class SingletonHelper &#123;</span><br><span class="line"></span><br><span class="line">    private static SingletonHelper ourInstance = null;</span><br><span class="line">    </span><br><span class="line">    static &#123;</span><br><span class="line">        inInstance = new SingletonHelper();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private SingletonHelper() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static SingletonHelper getInInstance()&#123;</span><br><span class="line">        return inInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上跟饿汉没有什么很大区别，都是在类初始化的时候就进行实例化对象</p><ul><li>静态内部类</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class SingletonHelper &#123;</span><br><span class="line"></span><br><span class="line">    private static SingletonHelper ourInstance = null;</span><br><span class="line"></span><br><span class="line">    private SingletonHelper() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 静态内部类</span><br><span class="line">     */</span><br><span class="line">    private static class SingletonHolder &#123;</span><br><span class="line">        private static final SingletonHelper SINGLETON_HELPER = new SingletonHelper();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static final SingletonHelper getOurInstance() &#123;</span><br><span class="line">        return SingletonHolder.SINGLETON_HELPER;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>枚举</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public enum SingleEnumHelper &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    public void otherMethod() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式是Effective Java作者Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象，但是有个缺点在于枚举的使用</p><ul><li>双重校验锁</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class SingletonHelper &#123;</span><br><span class="line"></span><br><span class="line">    private volatile static SingletonHelper singletonHelper;</span><br><span class="line"></span><br><span class="line">    private SingletonHelper() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 双重加锁</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static SingletonHelper getSingletonHelper() &#123;</span><br><span class="line">        if (null == singletonHelper) &#123;</span><br><span class="line">            synchronized (SingletonHelper.class) &#123;</span><br><span class="line">                if (null == singletonHelper) &#123;</span><br><span class="line">                    singletonHelper = new SingletonHelper();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return singletonHelper;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>关于单例参考：</p><p><a href="http://www.blogjava.net/kenzhh/archive/2016/03/28/357824.html" target="_blank" rel="noopener">Java：单例模式的七种写法</a></p><p><a href="https://www.cnblogs.com/cielosun/p/6582333.html" target="_blank" rel="noopener">Java单例模式(Singleton)以及实现</a></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Retrofit相关</title>
      <link href="/2017-11-27-Retrofit%E7%9B%B8%E5%85%B3/"/>
      <url>/2017-11-27-Retrofit%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h5 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h5><blockquote><p> 在用Retrofit+RxJava向服务端请求数据的时候出现了异常</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Caused by: java.io.EOFException: End of input at line 1 column</span><br></pre></td></tr></table></figure><a id="more"></a><h5 id="问题所在"><a href="#问题所在" class="headerlink" title="问题所在"></a>问题所在</h5><p>原来的时候在请求其他接口的时候见过类似的<strong>Exception</strong>，是因为请求返回的数据跟接口定位需要返回的数据不匹配导致的(为什么不匹配就会导致异常，下面的问题分析会给出答案)。</p><blockquote><p>然后就利用<a href="https://paw.cloud/" target="_blank" rel="noopener">Paw</a>去进行接口调试，发现服务端就是返回成功状态了，没有响应体Body！最重要的是服务端是接入第三方的不好让人去改他们的返回逻辑,然后只能客户端自己去处理这种情况。</p></blockquote><h5 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h5><p>为什么定义的返回类型不匹配就会导致异常呢，查看了Retrofit的配置方法发现在初始化的时候通过<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>Retrofit retrofit = new Retrofit.Builder()<br>                .baseUrl(“”)<br>                .client(OkHttpManager.getOkHttpClient())<br>                .addConverterFactory(GsonConverterFactory.create(GsonUtil.getGson()))<br>                .addCallAdapterFactory(RxJavaCallAdapterFactory.create())<br>                .build();</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">##### 问题解决</span><br><span class="line"></span><br><span class="line">既然问题发现了，那就想着如何去解决了</span><br><span class="line">&gt; (当初第一个想法就是Gson解析错误，那就不用Gson了，但是项目已经开发了这么多，现在换个解析框架肯定来不及，而且成本也太高，最主要的是没法保证其他的解析框架就不好出现这个问题，所以这个想法也就是个想法)</span><br><span class="line"></span><br><span class="line">然后通过某度查找解决方法</span><br><span class="line">&gt; 虽然一直吐槽它，但是它的使用频率还是很高的，特别是在被墙的世界里</span><br><span class="line"></span><br><span class="line">这边也发现了几篇解决方案：</span><br><span class="line">&gt; [Retrofit 响应体无body时解析EOFException](http://blog.csdn.net/u011374875/article/details/51956113)</span><br><span class="line">&gt; </span><br><span class="line">&gt; [Android retrofit End of input at line 1 column 1 path](http://blog.csdn.net/it_talk/article/details/60767060)</span><br><span class="line"></span><br><span class="line">其中都给出了具体的解决方案</span><br><span class="line"></span><br><span class="line">* 自定义无Body的解析转换器，判断如果是无Body的时候调用此转换类</span><br><span class="line"></span><br><span class="line">* 1.自定义无Body转换器</span><br></pre></td></tr></table></figure><pre><code>public class NullOnEmptyConverterFactory extends Converter.Factory {public static final NullOnEmptyConverterFactory create() {    return new NullOnEmptyConverterFactory();}public NullOnEmptyConverterFactory() {}@MethodInfo(date = &quot;2017-12-06 22:14:20&quot;, Desc = &quot;需要重写这里的responseBodyConverter&quot;)@Overridepublic Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations, Retrofit retrofit) {    Converter&lt;ResponseBody, ?&gt; delegate = retrofit.nextResponseBodyConverter(this, type, annotations);    return new Converter&lt;ResponseBody, Object&gt;() {        @Override        public Object convert(ResponseBody value) throws IOException {            /**             * 当Body的Content-Length为0的时候就是没有Body的时候直接返回null             */            if (value.contentLength() == 0) {                return null;            }            /**             * 这里如果有Body的时候正常返回             */            return delegate.convert(value);        }    };}@MethodInfo(date = &quot;2017-12-06 22:15:49&quot;, Desc = &quot;这里的requestBodyConverter不需要重写&quot;)@Overridepublic Converter&lt;?, RequestBody&gt; requestBodyConverter(Type type, Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {    return super.requestBodyConverter(type, parameterAnnotations, methodAnnotations, retrofit);}@MethodInfo(date = &quot;2017-12-06 22:16:36&quot;, Desc = &quot;这里的stringConverter不需要重写&quot;)@Overridepublic Converter&lt;?, String&gt; stringConverter(Type type, Annotation[] annotations, Retrofit retrofit) {    return super.stringConverter(type, annotations, retrofit);}</code></pre><p>}</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 2.配置到Retrofit的Build过程中</span><br></pre></td></tr></table></figure> Retrofit retrofit = new Retrofit.Builder()            .baseUrl(&quot;&quot;)            .client(OkHttpManager.getOkHttpClient())            /**             * 这里需要注意要加在Gson解析器之前，否则还是会导致异常             */            .addConverterFactory(NullOnEmptyConverterFactory.create())            .addConverterFactory(GsonConverterFactory.create(GsonUtil.getGson()))            .addCallAdapterFactory(RxJavaCallAdapterFactory.create())            .build();<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 利用String接收无Body，添加```ScalarsConverterFactory</span><br></pre></td></tr></table></figure>* 这里只需要添加<figure class="highlight plain"><figcaption><span>```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure> Retrofit retrofit = new Retrofit.Builder()                .baseUrl(&quot;&quot;)                .client(OkHttpManager.getOkHttpClient())                .addConverterFactory(ScalarsConverterFactory.create())                .addConverterFactory(GsonConverterFactory.create(GsonUtil.getGson()))                .addCallAdapterFactory(RxJavaCallAdapterFactory.create())                .build();```</code></pre><h5 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h5>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>加密算法初探</title>
      <link href="/2017-11-20-%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
      <url>/2017-11-20-%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><a href="http://blog.csdn.net/shenggaofei/article/details/52333687" target="_blank" rel="noopener">各种加密算法</a></p><p><strong>公钥加密算法，计算机通信安全的基石，保证了加密数据不会被破解！</strong></p><h4 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h4><blockquote><p>利用同一个密钥对信息进行加密和解密</p></blockquote><ul><li><p>好处：算法公开，简单、速度快，而且对称加密通常使用的是相对较小的密钥，密钥越大，加密越强，但是加密和解密的过程越慢。所以说密钥大小既要考虑到安全性又要照顾到效率。</p></li><li><p>缺点：对密钥的管理和分配，就是如何把密钥发送到需要解密你的加密信息的人手里是一个大问题，在发送密钥的过程中很容易被拦截篡改。</p></li><li><p>常见的对称加密算法：<br>DES、3DES、AES、TDEA、Blowfish、RC5、IDEA</p><blockquote><p>DES：数据加密标准，64位密钥长度(其中8位的奇偶位，56位数据位，只有56位有效)对64位二进制数据库进行加密，每次加密进行16轮的编码</p><p>3DES：利用不同的三个密钥对数据进行三次加密，是DES的一个更加安全的变形。加密的过程是加密-解密-加密(这里不是加密-加密-加密，在于是为了与现有DES系统的向后兼容问题，因为当K1=K2时，三重DES的效果就和原来的DES一样),解密的过程是解密-加密-解密</p><p>AES：高级加密标准，下一代的加密算法标准，速度快，安全级别高，密钥有128、192和256位的</p></blockquote></li></ul><h4 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h4><blockquote><p>对数据的加密和解密采用的一对密钥，公钥和私钥</p></blockquote><ul><li><p>好处：对于密钥的管理更强，通常使用的是公钥进行加密然后双方都是用各自的私钥进行解密，安全性更高</p></li><li><p>缺点：加密过程慢</p></li><li><p>常见的非对称加密算法：<br>  RSA、ECC</p></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p>（1） 对称加密加密与解密使用的是同样的密钥，所以速度快，但由于需要将密钥在网络传输，所以安全性不高。</p></li><li><p>（2） 非对称加密使用了一对密钥，公钥与私钥，所以安全性高，但加密与解密速度慢。</p></li><li><p>（3） 解决的办法是将对称加密的密钥使用非对称加密的公钥进行加密，然后发送出去，接收方使用私钥进行解密得到对称加密的密钥，然后双方可以使用对称加密来进行沟通。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android设备网络连接情况</title>
      <link href="/2017-11-15-%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E6%83%85%E5%86%B5/"/>
      <url>/2017-11-15-%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E6%83%85%E5%86%B5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Android系统中不同网络状态的获取和判断</p></blockquote><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line">    * 获取当前的网络状态 ：没有网络-0：WIFI网络1：4G网络-4：3G网络-3：2G网络-2</span><br><span class="line">    * 自定义</span><br><span class="line">    *</span><br><span class="line">    * @param context</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">   public static int getAPNType(Context context) &#123;</span><br><span class="line">       //结果返回值</span><br><span class="line">       int netType = 0;</span><br><span class="line">       //获取手机所有连接管理对象</span><br><span class="line">       ConnectivityManager manager = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);</span><br><span class="line">       //获取NetworkInfo对象</span><br><span class="line">       NetworkInfo networkInfo = manager.getActiveNetworkInfo();</span><br><span class="line">       //NetworkInfo对象为空 则代表没有网络</span><br><span class="line">       if (networkInfo == null) &#123;</span><br><span class="line">           return netType;</span><br><span class="line">       &#125;</span><br><span class="line">       //否则 NetworkInfo对象不为空 则获取该networkInfo的类型</span><br><span class="line">       int nType = networkInfo.getType();</span><br><span class="line">       if (nType == ConnectivityManager.TYPE_WIFI) &#123;</span><br><span class="line">           //WIFI</span><br><span class="line">           netType = 1;</span><br><span class="line">       &#125; else if (nType == ConnectivityManager.TYPE_MOBILE) &#123;</span><br><span class="line">           int nSubType = networkInfo.getSubtype();</span><br><span class="line">           TelephonyManager telephonyManager = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);</span><br><span class="line">           //3G   联通的3G为UMTS或HSDPA 电信的3G为EVDO</span><br><span class="line">           if (nSubType == TelephonyManager.NETWORK_TYPE_LTE</span><br><span class="line">                   &amp;&amp; !telephonyManager.isNetworkRoaming()) &#123;</span><br><span class="line">               netType = 4;</span><br><span class="line">           &#125; else if (nSubType == TelephonyManager.NETWORK_TYPE_UMTS</span><br><span class="line">                   || nSubType == TelephonyManager.NETWORK_TYPE_HSDPA</span><br><span class="line">                   || nSubType == TelephonyManager.NETWORK_TYPE_EVDO_0</span><br><span class="line">                   &amp;&amp; !telephonyManager.isNetworkRoaming()) &#123;</span><br><span class="line">               netType = 3;</span><br><span class="line">               //2G 移动和联通的2G为GPRS或EGDE，电信的2G为CDMA</span><br><span class="line">           &#125; else if (nSubType == TelephonyManager.NETWORK_TYPE_GPRS</span><br><span class="line">                   || nSubType == TelephonyManager.NETWORK_TYPE_EDGE</span><br><span class="line">                   || nSubType == TelephonyManager.NETWORK_TYPE_CDMA</span><br><span class="line">                   &amp;&amp; !telephonyManager.isNetworkRoaming()) &#123;</span><br><span class="line">               netType = 2;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               netType = 2;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return netType;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h5 id="无线网络-wifi"><a href="#无线网络-wifi" class="headerlink" title="无线网络(wifi)"></a>无线网络(wifi)</h5><h5 id="5G网络"><a href="#5G网络" class="headerlink" title="5G网络"></a>5G网络</h5><h5 id="4G网络"><a href="#4G网络" class="headerlink" title="4G网络"></a>4G网络</h5><h5 id="3G网络"><a href="#3G网络" class="headerlink" title="3G网络"></a>3G网络</h5><h5 id="2G网络"><a href="#2G网络" class="headerlink" title="2G网络"></a>2G网络</h5><h5 id="弱网"><a href="#弱网" class="headerlink" title="弱网"></a>弱网</h5><h5 id="断网"><a href="#断网" class="headerlink" title="断网"></a>断网</h5>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跑步</title>
      <link href="/2017-11-10-%E8%B7%91%E6%AD%A5/"/>
      <url>/2017-11-10-%E8%B7%91%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<h4 id="曾经肥胖静好"><a href="#曾经肥胖静好" class="headerlink" title="曾经肥胖静好"></a>曾经肥胖静好</h4><blockquote><p> 2017-6月开始了第一次跑步，还记得是因为某一天站到称上，发现自己离开学校也就1年，然而体重却是长了不止10斤！有点担心自己在这么长下去就要提前进入油腻大叔的阶段。<strong>so</strong>对自己说要减肥！</p></blockquote><a id="more"></a><blockquote><p>刚开始的时候还没想到跑步，毕竟当初学校期间最怂的还是1000米跑…然后就开始选择每天晚上在地上折腾自己，翻看着从网上扒拉下拉的各种各样的减肥动作，然后跟着开始一板一眼的模仿起来！效果的话说实话真不知道有没有😶</p></blockquote><blockquote><p>然后有一天看到朋友圈里有一个学长晒着他参加半马的照片，突然萌发了我也要去跑步的想法。至今还记得刚开始跑步的那天，6月份的7点多，已经没有那么的炎热，人行道上路灯映照着几个人影。我开始迈出自己关于的第一步。(这是平时晚上的一小步，却是跑步的一大步)</p></blockquote><blockquote></blockquote>]]></content>
      
      
      <categories>
          
          <category> 闲文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闲文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Annotation 注解原理及使用</title>
      <link href="/2017-11-3-Annotation/"/>
      <url>/2017-11-3-Annotation/</url>
      
        <content type="html"><![CDATA[<blockquote><p>需要了解<strong><a href="https://github.com/aisuhua/restful-api-design-references" target="_blank" rel="noopener">Restful</a></strong>设计规范、<strong><a href="http://www.jianshu.com/p/64427882ac27" target="_blank" rel="noopener">ORM</a>框架</strong></p></blockquote><blockquote><p>很多的开源库都用到了注解来简化代码提高开发效率</p></blockquote><a id="more"></a><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>Annotation(注解):能够添加到Java源代码的元数据(为描述数据的数据)。类、方法、变量、参数、包都可以添加Annotation，可用来将元数据和程序元素相关联。</p><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><ul><li>标记，用来告诉编译器一些信息</li><li>编译时动态处理，如动态生成代码</li><li>运行时动态处理，如得到注解信息</li></ul><h5 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h5><ul><li>标注Annotation 系统自带的几个常见的Annotation</li><li>元Annotation 指用来自定义Annotation的Annotation</li><li>自定义Annotation 用户根据自己需求自定义的Annotation 定义时需要用到上面的元Annotation</li></ul><h5 id="自定义Annotation"><a href="#自定义Annotation" class="headerlink" title="自定义Annotation"></a>自定义Annotation</h5><ul><li>1.通过@interface定义</li><li>2.注解配置参数名为注解类的方法名：<ul><li>1.所以方法没有方法体，没有参数没有修饰符，实际只允许public &amp; abstract修饰符</li><li>2.方法返回值只能是基本类型</li><li>3.若只有一个默认属性，可以直接用value函数，一个属性都没有表示该Annotation为mark Annotation</li></ul></li><li>3.可以用default表示默认值</li><li>4.注解定义</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//是否会保存到JavaDoc中</span><br><span class="line">@Documented</span><br><span class="line">//保留时间，source:源码时，class：编译时，runtime：运行时，默认为class，值为source大多为mark annotation，如@overrided等</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">//表示可以用来修饰哪些程序元素，如方法，变量，类，参数等等，如果没有标注则表示修饰所有</span><br><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">//是否可以被继承，默认为false</span><br><span class="line">@Inherited</span><br><span class="line">public @interface MethodInfo &#123;</span><br><span class="line">    String author() default &quot;quickly520@126.com&quot;;</span><br><span class="line"></span><br><span class="line">    String date();</span><br><span class="line"></span><br><span class="line">    String Desc() default &quot;自定义Annotation&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="引用注解"><a href="#引用注解" class="headerlink" title="引用注解"></a>引用注解</h5><ul><li>注解的使用</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 获得当前进程的名字</span><br><span class="line">    *</span><br><span class="line">    * @param context</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">   @MethodInfo(author = &quot;quicklymost@gmail.com&quot;</span><br><span class="line">           , date = &quot;2017-11-14&quot;, Desc = &quot;获得当前进程的名字&quot;)</span><br><span class="line">   public static String getCurProcessName(Context context) &#123;</span><br><span class="line">       int pid = android.os.Process.myPid();</span><br><span class="line">       ActivityManager activityManager = (ActivityManager) context</span><br><span class="line">               .getSystemService(Context.ACTIVITY_SERVICE);</span><br><span class="line">       for (ActivityManager.RunningAppProcessInfo appProcess : activityManager.getRunningAppProcesses()) &#123;</span><br><span class="line">           if (appProcess.pid == pid) &#123;</span><br><span class="line">               return appProcess.processName;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return null;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h5 id="是否引用了注解"><a href="#是否引用了注解" class="headerlink" title="是否引用了注解"></a>是否引用了注解</h5><ul><li>对某个类进行注解添加</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@MethodInfo(date = &quot;2017-11-29 10:18:34&quot;)</span><br><span class="line">public class AnnotationUse &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过反射来检查类是否添加了注解</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private void isUseAnnotation() &#123;</span><br><span class="line">      /**</span><br><span class="line">       * 检查类是否有注解</span><br><span class="line">       */</span><br><span class="line">      if (AnnotationUse.class.isAnnotationPresent(MethodInfo.class)) &#123;</span><br><span class="line">          /**</span><br><span class="line">           * 通过反射来对AnnotationUse进行检查是否有注解</span><br><span class="line">           */</span><br><span class="line">          MethodInfo methodInfo = AnnotationUse.class.getAnnotation(MethodInfo.class);</span><br><span class="line">          Log.d(&quot;App&quot;, &quot;methodInfo:&quot; + methodInfo);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h5 id="通过注解来代替枚举"><a href="#通过注解来代替枚举" class="headerlink" title="通过注解来代替枚举"></a>通过注解来代替枚举</h5><blockquote><p>Google对枚举在Android中是不推荐使用的,枚举类型比起静态变量，会消耗2倍的内存</p></blockquote><ul><li>@IntDef</li></ul><p><a href="https://developer.android.com/reference/android/support/annotation/IntDef.html" target="_blank" rel="noopener">IntDef</a>是一种替换整数类型枚举的注解</p><ul><li>@StringDef</li></ul><p><a href="https://developer.android.com/reference/android/support/annotation/StringDef.html" target="_blank" rel="noopener">StringDef</a>是一种替换字符串类型枚举的注解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class TypeCheck &#123;</span><br><span class="line">    public static final int TYPE_MUSIC = 0;</span><br><span class="line">    public static final int TYPE_PHOTO = 1;</span><br><span class="line">    public static final int TYPE_TEXT = 2;</span><br><span class="line"></span><br><span class="line">    public int itemType;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 无法确定传入的参数是否符合要求，这里可以利用IntDef/StringDef来对类型进行检查</span><br><span class="line">     */</span><br><span class="line">//    public void MethodCheck(int itemType) &#123;</span><br><span class="line">//        this.itemType = itemType;</span><br><span class="line">//    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Retention(RetentionPolicy.SOURCE)</span><br><span class="line">    @IntDef(&#123;TYPE_MUSIC, TYPE_PHOTO, TYPE_TEXT&#125;)</span><br><span class="line">    public @interface typeCheck &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public TypeCheck(@typeCheck int itemType) &#123;</span><br><span class="line">        this.itemType = itemType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @typeCheck</span><br><span class="line">    public int getType() &#123;</span><br><span class="line">        return itemType;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebView注意以及性能瓶颈</title>
      <link href="/2017-10-29-WebView%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E4%BB%A5%E5%8F%8A%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88%E6%B5%8B%E8%AF%95/"/>
      <url>/2017-10-29-WebView%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E4%BB%A5%E5%8F%8A%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h4 id="webview注意事项："><a href="#webview注意事项：" class="headerlink" title="webview注意事项："></a>webview注意事项：</h4><ul><li>webview加载太慢</li><li>webview导致的内存泄露</li><li>webview的兼容性(不同的系统采用的不同内核导致的兼容性问题，特别是国内各个厂商对原生系统的定制化)</li></ul><a id="more"></a><h5 id="webview加载太慢"><a href="#webview加载太慢" class="headerlink" title="webview加载太慢"></a>webview加载太慢</h5><ul><li>webview加载慢的原因：webview在加载页面的时候，除了url的请求外，还有webview页面外部引用的js、css、字体、图片等请求，而且这些请求都是串行的，这些请求加上浏览器的解析、渲染页面等就导致了webview整体的加载时间变得很长，消耗的流量也很多。</li></ul><h5 id="webview-性能测试以及瓶颈分析"><a href="#webview-性能测试以及瓶颈分析" class="headerlink" title="webview 性能测试以及瓶颈分析"></a>webview 性能测试以及瓶颈分析</h5><h5 id="webview常用缓存机制的使用场景和优势"><a href="#webview常用缓存机制的使用场景和优势" class="headerlink" title="webview常用缓存机制的使用场景和优势"></a>webview常用缓存机制的使用场景和优势</h5><ul><li>浏览器缓存机制</li><li>Dom Storage</li><li>Web Sql dataBase</li><li>Appcache</li><li>IndexDB</li><li>File System Api</li></ul><hr><p>未完待续</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>返回数据格式规范</title>
      <link href="/2017-10-25-Json%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E8%A7%84%E8%8C%83/"/>
      <url>/2017-10-25-Json%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h4 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: application/json</span><br><span class="line">/**</span><br><span class="line"> *不推荐使用使用表单格式:</span><br><span class="line"> *application/x-www-form-urlencoded</span><br><span class="line"> *无法提交有层级的参数</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="返回"><a href="#返回" class="headerlink" title="返回"></a>返回</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: application/json</span><br><span class="line">/**</span><br><span class="line"> *返回头格式，请返回JSON格式</span><br><span class="line"> *不要返回 text/html，text/css 等不相关返回头</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><h5 id="请求为其他错误的Code的返回结果"><a href="#请求为其他错误的Code的返回结果" class="headerlink" title="请求为其他错误的Code的返回结果"></a>请求为其他错误的Code的返回结果</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;code&quot;: 400,</span><br><span class="line">  &quot;data&quot;: null,</span><br><span class="line">  &quot;message&quot;: &quot;error&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="请求为成功Code的返回结果"><a href="#请求为成功Code的返回结果" class="headerlink" title="请求为成功Code的返回结果"></a>请求为成功Code的返回结果</h5><ul><li>返回的result为一个数组，并且有数据时期望的结果</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;code&quot;: 200,</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;result&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;house_id&quot;: 36,</span><br><span class="line">        &quot;area&quot;: &quot;\u6c5f\u5e72\u533a&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;totals&quot;: 1 //不一定有</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;message&quot;: &quot;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>返回的result为一个数组，并且没有数据时期望的结果</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;code&quot;: 200,</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;result&quot;: [], //返回一个空的数组</span><br><span class="line">    &quot;totals&quot;: &quot;0&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;message&quot;: &quot;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>返回的result为一个对象，并且有数据时期望的结果</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;code&quot;: 200,</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;result&quot;: &#123;</span><br><span class="line">      &quot;user_id&quot;: 11111,</span><br><span class="line">      &quot;mobile&quot;: &quot;187xxxxxxxx&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;message&quot;: &quot;success&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>返回的result为一个对象，并且没有数据时期望的结果</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;code&quot;: 200,</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;result&quot;: null //返回一个空的对象</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;message&quot;: &quot;null&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发规范 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发规范 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-/LeakCancary的使用和原理/" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/07/LeakCancary的使用和原理/" class="article-date">
  <time datetime="2018-03-07T12:50:02.584Z" itemprop="datePublished">2018-03-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/07/LeakCancary的使用和原理/">LeakCancary的使用和原理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="目录："><a href="#目录：" class="headerlink" title="目录："></a>目录：</h3><ul>
<li>为什么会有<em>LeakCancary</em></li>
<li>什么是<em>LeakCancary</em></li>
<li><em>LeakCancary</em>的使用</li>
<li><em>LeakCancary</em>的实现过程</li>
</ul>
<hr>
<h4 id="Why-LeakCancary"><a href="#Why-LeakCancary" class="headerlink" title="Why LeakCancary"></a>Why LeakCancary</h4><blockquote>
<p><strong>Square</strong>在开源项目<strong>LeakCancary</strong>的前言就提到了</p>
<p><strong>“A small leak will sink a great ship”</strong></p>
<p>我们可以翻译过来用一句名言来表示：<br><strong>“千里之堤溃于蚁穴”</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError</span><br><span class="line">        at android.graphics.Bitmap.nativeCreate(Bitmap.java:-2)</span><br><span class="line">        at android.graphics.Bitmap.createBitmap(Bitmap.java:689)</span><br><span class="line">        at com.squareup.ui.SignView.createSignatureBitmap(SignView.java:121)</span><br></pre></td></tr></table></figure>
<p><strong>OOM</strong> 项目中最让人头疼的一个异常，它不像一些其他异常很显示的给你指出并且容易解决，它的产生原因一般都是内存对象的不正确使用导致GC无法正常的回收对象，进而产生内存泄露，让系统的内存空间逐渐的不够，然后导致内存溢出。</p>
<p><strong>Square</strong>公司有篇文章说过他们在使用Bitmap进行签名页面进行绘制过程中，创建的bitmap对象经常性的产生OOM。<br>为了解决这个问题，<strong>Square</strong>做出了很多的对策，包括：</p>
<ul>
<li>使用<strong>Bitmap.Config.ALPHA_8</strong>节省内存</li>
<li>手动捕获<strong>OOM</strong>，调用<strong>GC</strong></li>
</ul>
<p>但是实际上效果并不好，后来他们发现是方向错了，当系统中分配的内存已经不够了，这时候OOM可以发生在任何的地方，特别是一些大对象的使用，比如Bitmap的创建。OOM只是表象，更深层次的问题可能是：<strong>内存泄露</strong></p>
<p>但是在原来的时候排查内存泄露是个全手工的过程,为了解决这个问题，<strong>LeakCancary</strong>出现了。</p>
<h4 id="What-LeakCancary"><a href="#What-LeakCancary" class="headerlink" title="What LeakCancary"></a>What LeakCancary</h4><p><strong><a href="https://github.com/square/leakcanary" target="_blank" rel="noopener">LeakCancary</a></strong>是<strong>Square</strong>公司推出的一款Java和Android内存泄露检查框架，如果检测到某个地方产生了内存泄露，LeakCancary会生成一个显示的通知，并且在Locat会有相应的log日志提醒，通过显示的通知和log日志我们可以对内存泄露进行准确的定位并去解决它。</p>
<h4 id="Use-LeakCancary"><a href="#Use-LeakCancary" class="headerlink" title="Use LeakCancary"></a>Use LeakCancary</h4><p><img src="http://p0sgkjh7x.bkt.clouddn.com/374F4D1C-CDAA-4FA1-BD09-1EFEE81C4B81.png" alt="LeakCancary显示通知图"></p>
<p><em>LeakCancary显示通知图镇楼</em></p>
<p>关于<strong>LeakCancary</strong>的开源和使用，Square最初的目的是为了能更好的对app进行内存泄露的检测，而且是为了能更简的入手，所以它的使用就不会很复杂，实际上用法也是很简单：</p>
<ul>
<li>在build.gradle添加引用：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">debugCompile &apos;com.squareup.leakcanary:leakcanary-android:1.5.4&apos;</span><br><span class="line">releaseCompile &apos;com.squareup.leakcanary:leakcanary-android-no-op:1.5.4&apos;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当前最新版本为1.5.4，可以根据git上的最新版本进行升级</p>
</blockquote>
<ul>
<li>在<strong>自定义继承Application</strong>中添加<strong>RefWatcher</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Ys7App extends Application &#123;</span><br><span class="line"></span><br><span class="line"> 	 /**</span><br><span class="line"> 	  * RefWatcher对象</span><br><span class="line"> 	  */</span><br><span class="line">    private RefWatcher refWatcher;</span><br><span class="line"></span><br><span class="line">    public static RefWatcher getRefWatcher(Context context) &#123;</span><br><span class="line">        Ys7App application = (Ys7App) context.getApplicationContext();</span><br><span class="line">        return application.refWatcher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate() &#123;</span><br><span class="line">        super.onCreate();</span><br><span class="line">        refWatcher = LeakCanary.install(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>不要忘记把自定义继承的<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">然后我们就可以去写**内存泄露**了(咳咳，说错了，是去发现内存泄露)</span><br><span class="line"></span><br><span class="line">说个很常见的内存泄露问题：*关于Context对象的使用*</span><br><span class="line"></span><br><span class="line">项目中很多地方都需要用到**Context**对象,有时候我们会直接使用**Activity**的**Context**对象，有时候会使用全局的**Context**对象。关于这个我们要说说关于在**Activity**中使用单例模式的问题，很多时候我们需要去维护一个全局的方法，很容易想到用单例模式，它也是设计模式中最简单易懂的一个，但是它如果使用不好就会产生**内存泄露**问题。</span><br><span class="line"></span><br><span class="line">* TextView的一个单例实现类</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>public class TextHelper {<br>    private static TextHelper mTextHelper;<br>    private Context mContext;<br>    private TextView mTextView;</p>
<pre><code>private TextHelper(Context context) {
    this.mContext = context;
}

public static TextHelper getTextHelper(Context context) {
    if (null == mTextHelper) {
        mTextHelper = new TextHelper(context);
    }
    return mTextHelper;
}

/**
 * 设置TextView的大小和颜色
 *
 * @param textView
 */
@SuppressLint(&quot;NewApi&quot;)
public void setText(TextView textView) {
    this.mTextView = textView;
    this.mTextView.setTextSize(20f);
    this.mTextView.setTextColor(mContext.getColor(R.color.black));
}
</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 这里因为我们需要引用到资源文件中的color文件，所以需要个**Context**对象</span><br><span class="line"></span><br><span class="line">* 在Activity中使用：</span><br></pre></td></tr></table></figure>
<p> TextHelper.getTextHelper(SDKActivity.this).setText(nameText);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt; 这里我们使用了当前**Activity**的**Context**对象</span><br><span class="line"></span><br><span class="line">这里因为在**Activity**中使用了当前的**Context**对象，看上去没什么问题，但是如果我们退出当前Activity后(引入了**LeakCancary**的前提)，会在通知栏看到产生了个内存泄露通知</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;http://p0sgkjh7x.bkt.clouddn.com/D879CC01A4E508F2835F89036A03A0A6.jpg&quot; height=&quot;250&quot; width=&quot;150&quot;/&gt;</span><br><span class="line"></span><br><span class="line">然后我们通过查看**Leaks**中的列表问题</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;http://p0sgkjh7x.bkt.clouddn.com/F6A127ED4F1BAA1DFD5CE4F6B3C8012A.jpg&quot; height=&quot;250&quot; width=&quot;150&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&gt; Leaks:由于App运行中产生了内存泄露然后显示在手机上，在这边是一个内存泄露的问题列表，然后我们可以通过查看每一项进行问题的查看</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;http://p0sgkjh7x.bkt.clouddn.com/94088C38003714DBF648267A164FF6B4.jpg&quot; height=&quot;250 &quot; width=&quot;150&quot; /&gt;</span><br><span class="line"></span><br><span class="line">这边就是我们通过leaked5.8查看的具体问题，可以看到Leaks已经帮我们把内存泄露的地方指出来了，这是因为我们的**Activity**在退出后它的**Context**对象被单例模式中的方法持有 着，但是**Activity**已经不存在了，这里就产生了内存泄露。</span><br><span class="line">&gt; 实际上这是个很简单但是又很容易犯的问题</span><br><span class="line">&gt; </span><br><span class="line">&gt; 同时我们也可以通过点击Leaks边上的**+**来进行更多信息的查看</span><br><span class="line"></span><br><span class="line">所以我们这里的话要解决这个内存泄露就要传入一个全局的**Context**对象</span><br></pre></td></tr></table></figure>
<p>TextHelper.getTextHelper(Application.getInstance()).setText(nameText);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">或者是直接在单例模式中直接获取全局的**Context**对象</span><br></pre></td></tr></table></figure>
<p>public class TextHelper {<br>    private static TextHelper mTextHelper;<br>    private Context mContext;<br>    private TextView mTextView;</p>
<pre><code>private TextHelper(Context context) {
    this.mContext = Application.getInstance();
}

public static TextHelper getTextHelper() {
    if (null == mTextHelper) {
        mTextHelper = new TextHelper();
    }
    return mTextHelper;
}

/**
 * 设置TextView的大小和颜色
 *
 * @param textView
 */
@SuppressLint(&quot;NewApi&quot;)
public void setText(TextView textView) {
    this.mTextView = textView;
    this.mTextView.setTextSize(20f);
    this.mTextView.setTextColor(mContext.getColor(R.color.black));
}
</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">这里就能避免由于**Context**对象的被持有导致的**内存泄露**。</span><br><span class="line"></span><br><span class="line">&gt; 实际上我们项目开发过程中会或多或少的产生**内存泄露**，这里只是举了一个简单的例子，我们只能通过去发现然后排查解决。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### Behind LeakCancary</span><br><span class="line">&gt; 在使用框架的同时也要关注下背后的实现过程和原理</span><br><span class="line">&gt; 我们通过对源码进行一步步的分解</span><br><span class="line"></span><br><span class="line">* 返回**RefWatcher**的过程</span><br></pre></td></tr></table></figure>
<p>private RefWatcher refWatcher;<br>refWatcher = LeakCanary.install(this);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; 通过**install()**方法</span><br></pre></td></tr></table></figure>
<p>public static RefWatcher install(Application application) {<br>        return ((AndroidRefWatcherBuilder)refWatcher(application).listenerServiceClass(DisplayLeakService.class).excludedRefs(AndroidExcludedRefs.createAppDefaults().build())).buildAndInstall();<br>    }</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; 继续对**buildAndInstall()**进行分析</span><br></pre></td></tr></table></figure>
<p>public RefWatcher buildAndInstall() {<br>        RefWatcher refWatcher = this.build();<br>        if(refWatcher != RefWatcher.DISABLED) {<br>            LeakCanary.enableDisplayLeakActivity(this.context);<br>            ActivityRefWatcher.install((Application)this.context, refWatcher);<br>        }</p>
<pre><code>    return refWatcher;
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; 在这里会返回一个**AndroidRefWatcher**，所以我们在对**Activity**进行内存泄露检查的时候，不需要专门添加代码，这里的**AndroidRefWatcher**会自动的帮我们进行检查</span><br></pre></td></tr></table></figure>
<p>public final class ActivityRefWatcher {<br>    private final ActivityLifecycleCallbacks lifecycleCallbacks = new ActivityLifecycleCallbacks() {<br>        public void onActivityCreated(Activity activity, Bundle savedInstanceState) {<br>        }</p>
<pre><code>    public void onActivityStarted(Activity activity) {
    }

    public void onActivityResumed(Activity activity) {
    }

    public void onActivityPaused(Activity activity) {
    }

    public void onActivityStopped(Activity activity) {
    }

    public void onActivitySaveInstanceState(Activity activity, Bundle outState) {
    }

    public void onActivityDestroyed(Activity activity) {
      //调用ActivityRefWatcher的watch方法
       ActivityRefWatcher.this.onActivityDestroyed(activity);
    }
};
</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 在**ActivityRefWatcher**中我们发现会有关于**Activity**生命周期的回调监听并且在**onDestroy()**中会去添加**ActivityRefWatcher**的**watch**方法，但是这里也需要注意的是**registerActivityLifecycleCallbacks()**是在Api14以后才添加的方法，所以如果要在Api14以前检测就需要自己去重写onDestory并在里面添加RefWatcher.watch()方法</span><br><span class="line"></span><br><span class="line">如果是在**Fragment**中需要检查内存泄露情况的话需要我们自己实现**RefWatcher**的**watch**方法</span><br></pre></td></tr></table></figure>
<p>public class BaseFragment extends Fragment {</p>
<pre><code>@Override
public void onDestroy() {
    super.onDestroy();
    //返回一个RefWatcher对象
    RefWatcher refWatcher = Ys7App.getRefWatcher(getActivity());
    refWatcher.watch(this);
}
</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; 在这里有个疑问，为什么**Square**公司在设计**LeakCancary**的时候，考虑到了**Activity**，添加了对应的**ActivityRefWatcher**，但是对于碎片**Fragment**并没有去设计对应的**FragmentRefWatcher**方法,不知道是因为Fragment的生命周期过多还是其他的原因，也许我们可以自己根据**ActivityRefWatcher**的实现方法设计一套自己的**FragmentRefWatcher**，先留个想法...</span><br><span class="line"></span><br><span class="line">* RefWatcher是如何能够对内存泄露进行检测的</span><br><span class="line"></span><br><span class="line">通过观察RefWatcher的watch()方法</span><br></pre></td></tr></table></figure>
<p>public void watch(Object watchedReference, String referenceName) {<br>if(this != DISABLED) {<br>…<br>long watchStartNanoTime = System.nanoTime();<br>String key = UUID.randomUUID().toString();<br>this.retainedKeys.add(key);<br>//创建一个KeyedWeakReference弱引用对象<br>KeyedWeakReference reference = new KeyedWeakReference(watchedReference, key, referenceName, this.queue);<br>this.ensureGoneAsync(watchStartNanoTime, reference);<br>}<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里创建了一个**KeyedWeakReference**对象，这是个弱引用的对象</span><br></pre></td></tr></table></figure>
<p>private void ensureGoneAsync(final long watchStartNanoTime, final KeyedWeakReference reference) {<br>//执行操作，检查弱引用对象是否被清除<br>this.watchExecutor.execute(new Retryable() {<br>    public Result run() {<br>        return RefWatcher.this.ensureGone(reference, watchStartNanoTime);<br>    }<br>});<br>}</p>
<p>Result ensureGone(KeyedWeakReference reference, long watchStartNanoTime) {<br>…<br>if(this.debuggerControl.isDebuggerAttached()) {<br>    return Result.RETRY;<br>} else if(this.gone(reference)) {<br>    return Result.DONE;<br>} else {<br>    //手动调用GC<br>    this.gcTrigger.runGc();<br>    this.removeWeaklyReachableReferences();<br>    //如果弱引用对象还存在，则说明内存泄露了，生成hprof文件<br>     if(!this.gone(reference)) {<br>                File heapDumpFile = this.heapDumper.dumpHeap();<br>                …<br>                this.heapdumpListener.analyze(new HeapDump(heapDumpFile, reference.key, reference.name, this.excludedRefs, watchDurationMs, gcDurationMs, heapDumpDurationMs));<br>            }<br>     }<br>    return Result.DONE;<br>}<br>//retainedKeys中是否包含弱引用对象的key<br>private boolean gone(KeyedWeakReference reference) {<br>        return !this.retainedKeys.contains(reference.key);<br>    }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在**WatchExector**的后台线程中执行检查弱引用对象是否被清除，如果没有清除，则调用一次GC，(这边能够检查弱引用对象还是根据**KeyedWeakReference**是以key-value形式存在的对象)</span><br><span class="line">如果弱引用对象没有被清除，则说明内存泄露了，系统就导出hprof文件,保存在app系统目录下</span><br></pre></td></tr></table></figure>
<p>final class KeyedWeakReference extends WeakReference<object> {<br>        //key-value形式存在<br>    public final String key;<br>    public final String name;</object></p>
<pre><code>KeyedWeakReference(Object referent, String key, String name, ReferenceQueue&lt;Object&gt; referenceQueue) {
    super(Preconditions.checkNotNull(referent, &quot;referent&quot;), 
    ...
</code></pre><p>}</p>
<p><code>`</code></p>
<hr>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>根据<strong>Square</strong>公司的数据说明他们在使用了<strong>LeakCancary</strong>后，减少了<strong>94%</strong>由OOM导致的cash。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/07/LeakCancary的使用和原理/" data-id="cjtwrr63w000y5f6sp94ywu1q" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-/安卓的进程保活/" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/07/安卓的进程保活/" class="article-date">
  <time datetime="2018-03-07T12:50:02.583Z" itemprop="datePublished">2018-03-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/07/安卓的进程保活/">安卓的进程保活</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p><em>安卓进程保活真的好烦啊…</em></p>
<p>我想每一个在实现安卓的进程保的开发者都是这样的想法吧(什么，你没有这个想法，那你就收下我的膝盖吧…)</p>
<p>在我们的应用开发中有时候需要我们的app时刻的运行着，比如IM类的、屏幕保护等等,这些都需要一直运行在后台中，如果被系统Kill了就没有<br>办法提服务,所以就有了进程保活</p>
</blockquote>
<h4 id="进程的分类：-根据优先级排列"><a href="#进程的分类：-根据优先级排列" class="headerlink" title="进程的分类：(根据优先级排列)"></a>进程的分类：(根据优先级排列)</h4><ul>
<li>前台进程</li>
</ul>
<p>进程持有这些：可见的并且与用户交互的Activity、绑定在可见并且与用户交互的Activity的Service、通过startForeground()启动的Service、一个Service正在执行它的onCreat、onStart、onDestory、一个BroatcastReceiver正在执行它的onReceiver方法</p>
<blockquote>
<p>一般系统不会去杀死这些前台进程</p>
</blockquote>
<ul>
<li>可见进程</li>
</ul>
<p>进程持有这些：不在前台，但是可见的Activity、绑定在不在前台，可见Activity的Service</p>
<blockquote>
<p>用户看得见，但是不能操作，一般系统也不会去杀死这些可见进程</p>
</blockquote>
<ul>
<li>服务进程</li>
</ul>
<p>进程持有这些：通过startService启动的Service</p>
<blockquote>
<p>在内存不足维持前台进程和可见进程的时候，服务进程会被杀死</p>
</blockquote>
<ul>
<li>后台进程</li>
</ul>
<p>用户按了Home键和back键，程序不可见了，但是其实还是在运行的程序</p>
<blockquote>
<p>系统很容易去杀死这些进程</p>
</blockquote>
<ul>
<li>空进程</li>
</ul>
<blockquote>
<p>这种进程里面不包含任何的东西，没有实际作用，最容易被杀死的进程，没有之一…</p>
</blockquote>
<h4 id="进程为什么被杀死"><a href="#进程为什么被杀死" class="headerlink" title="进程为什么被杀死"></a>进程为什么被杀死</h4><p>进程被杀死的原因：</p>
<ul>
<li>被系统杀死了</li>
</ul>
<blockquote>
<p>安卓系统是基于Linux系统的，继承了Linux的内存管理策略，进程退出后不会立马杀死，会在内存不够的时候在去按照进程的优先级去杀死进程腾出内存</p>
</blockquote>
<ul>
<li>被第三方软件杀死</li>
</ul>
<blockquote>
<p>360之类的</p>
</blockquote>
<ul>
<li>被用户手动杀死</li>
</ul>
<blockquote>
<p>系统自带的一键清理、手机设置应用管理器的ForceClose</p>
</blockquote>
<h4 id="进程保活的方法"><a href="#进程保活的方法" class="headerlink" title="进程保活的方法"></a>进程保活的方法</h4><ul>
<li>提高进程的优先级</li>
</ul>
<blockquote>
<p>开启一个像素的Activity(QQ的保活方案)</p>
<p>启动前台Service</p>
</blockquote>
<ul>
<li>在进程杀死后，进行拉起</li>
</ul>
<blockquote>
<p>监听系统的广播，拉起进程(网络变化、解锁屏幕、开机等但是已经被N了)</p>
<p>双进程相互唤起</p>
<p>依靠系统唤起</p>
<p>多个app之间相互唤醒，阿里系列的app、腾讯系列的app</p>
</blockquote>
<ul>
<li>依靠第三方</li>
</ul>
<blockquote>
<p>各个终端对应的推送，小米的小米推送、华为的华为推送，其他的可以接入其他的其他推送</p>
</blockquote>
<ul>
<li>JobScheduler</li>
</ul>
<blockquote>
<p>5.0之后推出的进程死后复活一种方式</p>
</blockquote>
<ul>
<li><p>粘性服务与系统服务捆绑</p>
</li>
<li><p>账号同步唤醒，利用android自身的同步进制进行拉活</p>
</li>
</ul>
<hr>
<p>附：网上一个大神的关于<a href="http://blog.csdn.net/marswin89/article/details/48015453" target="_blank" rel="noopener">进程保活的方案</a>，通过对进程的分析、常见的进程保活以及到最后的nvtive实现的进程保活(从Android到Linux，从Java到C，看的我一脸懵逼…)</p>
<blockquote>
<p>妈妈问我为什么跪着看 囧…</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/07/安卓的进程保活/" data-id="cjtwrr61e000a5f6scvfyonvf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-/为何会有插件化的必然/" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/07/为何会有插件化的必然/" class="article-date">
  <time datetime="2018-03-07T12:50:02.582Z" itemprop="datePublished">2018-03-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/07/为何会有插件化的必然/">为何会有插件化的必然</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>一个项目，随着时间和业务的推移，会变得越来越庞大和臃肿，越来越多的功能堆积导致我们一次编译运行要等上半天，像我们公司的一个线上项目，原来打包发布的时候只有10M的apk，后来为了接入一个第三方的SDK，导致项目apk活生生撸到了40M，每次编译运行都要等个半天！囧…所以这时候产生了插件化,插件化使我们可以通过动态的加载、删除，那些独立的插件apk可以在线下载安装，有利于减少apk的体积同时也可以通过插件化时实现热修复。现在有很多热门的插件化方案：阿里的Atlas,滴滴的VirtualApk，360的RePlugin等。</p>
</blockquote>
<p>说到<strong>插件化</strong>我们就不得不说说2个跟它很类似的<strong>模块化</strong>和<strong>组件化</strong></p>
<h5 id="模块化："><a href="#模块化：" class="headerlink" title="模块化："></a>模块化：</h5><p>模块化是根据业务对项目进行分离成莫干个模块的过程，例如一个消息模块、城市查询模块等。</p>
<h5 id="组件化："><a href="#组件化：" class="headerlink" title="组件化："></a>组件化：</h5><p>组件化是根据功能来实现分离，例如一个下拉刷新组件、上拉加载组件等。</p>
<blockquote>
<p>一个模块可以依赖多个组件，组件一般不会去依赖其他组件</p>
</blockquote>
<p>然后我们在来说说<strong>插件化</strong></p>
<h5 id="插件化"><a href="#插件化" class="headerlink" title="插件化"></a>插件化</h5><p>插件化和模块化差不多，但是它跟模块化的最大区别在于它可以打独立的apk包，而模块化不会去打成独立的apk，只会去生成model然后依赖到主app中</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/07/为何会有插件化的必然/" data-id="cjtwrr61b00095f6suazwxzip" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-/安卓组件化到模块化/" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/07/安卓组件化到模块化/" class="article-date">
  <time datetime="2018-03-07T12:50:02.582Z" itemprop="datePublished">2018-03-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/07/安卓组件化到模块化/">安卓组件化到模块化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/07/安卓组件化到模块化/" data-id="cjtwrr61900085f6sqsfvrqy5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-/初步解读安卓组件化/" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/07/初步解读安卓组件化/" class="article-date">
  <time datetime="2018-03-07T12:50:02.581Z" itemprop="datePublished">2018-03-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/07/初步解读安卓组件化/">初步解读安卓组件化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>以下的内容纯属个人理解，不对之处…</p>
</blockquote>
<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>项目开发中，我们会用到许许多多系统的组件、自定义的组件，也许刚开始的时候我们只是重复的使用的组件(<em>往往这些组件会在多个项目中重复的使用，毕竟国内的App说实话创意真的是挺少的</em>)，但是随着我们开发经验的增加，有一天也许就有想能不能把这些组件进行封装出来，可以满足多个项目的需求呢，这时候就产生了<em>组件化</em>。</p>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p><strong>组件化</strong>，就是根据组件将项目进行分离成若干个组件，比如<strong>下拉刷新组件</strong>、<strong>上拉加载组件</strong>等等。这些组件不能单独的运行，必须依赖于主App中才能运行，但是可以依赖到不同项目的主App中。避免了重复的造轮子，提高了开发的效率(对于外包的项目有组件化简直不能再舒服了…)</p>
<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>这里先引一张个人项目的图</p>
<p><img src="http://p0sgkjh7x.bkt.clouddn.com/5BD17723-39D7-4AE9-A01C-F44C4930A428.png" width="150" height="200"></p>
<p>这里的<strong>lib_load</strong>和<strong>lib_refresh</strong>就是项目的刷新和加载的组件(关于上图的那几个mode可以去<a href="https://momubai.github.io/2017/12/15/%E8%81%8A%E8%81%8A%E4%BB%8E%E5%AE%89%E5%8D%93%E7%BB%84%E4%BB%B6%E5%8C%96%E5%88%B0%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E8%BF%87%E7%A8%8B.html" target="_blank" rel="noopener">关于安卓的模块化</a>进行查看)，它们是依附在app里的，只需要在build导入lib</p>
<p><img src="http://p0sgkjh7x.bkt.clouddn.com/879E01F0-E625-49C7-B36A-F217887E3228.png" width="150"></p>
<p>就可以在app中使用</p>
<p>xw</p>
<blockquote>
<p>未完待续</p>
</blockquote>
<hr>
<h4 id="附言"><a href="#附言" class="headerlink" title="附言"></a>附言</h4><blockquote>
<p>组件化说是根据组件进行分离，但是有时候也可以根据功能进行分离(<strong><a href="https://momubai.github.io/2017/12/15/%E8%81%8A%E8%81%8A%E4%BB%8E%E5%AE%89%E5%8D%93%E7%BB%84%E4%BB%B6%E5%8C%96%E5%88%B0%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E8%BF%87%E7%A8%8B.html" target="_blank" rel="noopener">模块化</a></strong>：模块是根据功能进行分离的)，比如一个日间夜间模式切换、轮播图功能(轮播图说它是功能呢也可以，说是组件呢也没错)，所以说这里很多时候不会去那么的计较，毕竟每个人对组件的概念都是不一样的,有可能在你这里认为是一个组件，但是到他那里可能就是个模块了</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/07/初步解读安卓组件化/" data-id="cjtwrr61000075f6s1b4b9dtn" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-/Annotation 注解原理及使用/" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/07/Annotation 注解原理及使用/" class="article-date">
  <time datetime="2018-03-07T12:50:02.580Z" itemprop="datePublished">2018-03-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/07/Annotation 注解原理及使用/">Annotation 注解原理及使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>需要了解<strong><a href="https://github.com/aisuhua/restful-api-design-references" target="_blank" rel="noopener">Restful</a></strong>设计规范、<strong><a href="http://www.jianshu.com/p/64427882ac27" target="_blank" rel="noopener">ORM</a>框架</strong></p>
</blockquote>
<blockquote>
<p>很多的开源库都用到了注解来简化代码提高开发效率</p>
</blockquote>
<h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>Annotation(注解):能够添加到Java源代码的元数据(为描述数据的数据)。类、方法、变量、参数、包都可以添加Annotation，可用来将元数据和程序元素相关联。</p>
<h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><ul>
<li>标记，用来告诉编译器一些信息</li>
<li>编译时动态处理，如动态生成代码</li>
<li>运行时动态处理，如得到注解信息</li>
</ul>
<h5 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h5><ul>
<li>标注Annotation 系统自带的几个常见的Annotation</li>
<li>元Annotation 指用来自定义Annotation的Annotation</li>
<li>自定义Annotation 用户根据自己需求自定义的Annotation 定义时需要用到上面的元Annotation</li>
</ul>
<h5 id="自定义Annotation"><a href="#自定义Annotation" class="headerlink" title="自定义Annotation"></a>自定义Annotation</h5><ul>
<li>1.通过@interface定义</li>
<li>2.注解配置参数名为注解类的方法名：<ul>
<li>1.所以方法没有方法体，没有参数没有修饰符，实际只允许public &amp; abstract修饰符</li>
<li>2.方法返回值只能是基本类型</li>
<li>3.若只有一个默认属性，可以直接用value函数，一个属性都没有表示该Annotation为mark Annotation</li>
</ul>
</li>
<li>3.可以用default表示默认值</li>
<li>4.注解定义</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//是否会保存到JavaDoc中</span><br><span class="line">@Documented</span><br><span class="line">//保留时间，source:源码时，class：编译时，runtime：运行时，默认为class，值为source大多为mark annotation，如@overrided等</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">//表示可以用来修饰哪些程序元素，如方法，变量，类，参数等等，如果没有标注则表示修饰所有</span><br><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">//是否可以被继承，默认为false</span><br><span class="line">@Inherited</span><br><span class="line">public @interface MethodInfo &#123;</span><br><span class="line">    String author() default &quot;quickly520@126.com&quot;;</span><br><span class="line"></span><br><span class="line">    String date();</span><br><span class="line"></span><br><span class="line">    String Desc() default &quot;自定义Annotation&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="引用注解"><a href="#引用注解" class="headerlink" title="引用注解"></a>引用注解</h5><ul>
<li>注解的使用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 获得当前进程的名字</span><br><span class="line">    *</span><br><span class="line">    * @param context</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">   @MethodInfo(author = &quot;quicklymost@gmail.com&quot;</span><br><span class="line">           , date = &quot;2017-11-14&quot;, Desc = &quot;获得当前进程的名字&quot;)</span><br><span class="line">   public static String getCurProcessName(Context context) &#123;</span><br><span class="line">       int pid = android.os.Process.myPid();</span><br><span class="line">       ActivityManager activityManager = (ActivityManager) context</span><br><span class="line">               .getSystemService(Context.ACTIVITY_SERVICE);</span><br><span class="line">       for (ActivityManager.RunningAppProcessInfo appProcess : activityManager.getRunningAppProcesses()) &#123;</span><br><span class="line">           if (appProcess.pid == pid) &#123;</span><br><span class="line">               return appProcess.processName;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return null;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h5 id="是否引用了注解"><a href="#是否引用了注解" class="headerlink" title="是否引用了注解"></a>是否引用了注解</h5><ul>
<li>对某个类进行注解添加</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@MethodInfo(date = &quot;2017-11-29 10:18:34&quot;)</span><br><span class="line">public class AnnotationUse &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>通过反射来检查类是否添加了注解</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private void isUseAnnotation() &#123;</span><br><span class="line">      /**</span><br><span class="line">       * 检查类是否有注解</span><br><span class="line">       */</span><br><span class="line">      if (AnnotationUse.class.isAnnotationPresent(MethodInfo.class)) &#123;</span><br><span class="line">          /**</span><br><span class="line">           * 通过反射来对AnnotationUse进行检查是否有注解</span><br><span class="line">           */</span><br><span class="line">          MethodInfo methodInfo = AnnotationUse.class.getAnnotation(MethodInfo.class);</span><br><span class="line">          Log.d(&quot;App&quot;, &quot;methodInfo:&quot; + methodInfo);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h5 id="通过注解来代替枚举"><a href="#通过注解来代替枚举" class="headerlink" title="通过注解来代替枚举"></a>通过注解来代替枚举</h5><blockquote>
<p>Google对枚举在Android中是不推荐使用的,枚举类型比起静态变量，会消耗2倍的内存</p>
</blockquote>
<ul>
<li>@IntDef</li>
</ul>
<p><a href="https://developer.android.com/reference/android/support/annotation/IntDef.html" target="_blank" rel="noopener">IntDef</a>是一种替换整数类型枚举的注解</p>
<ul>
<li>@StringDef</li>
</ul>
<p><a href="https://developer.android.com/reference/android/support/annotation/StringDef.html" target="_blank" rel="noopener">StringDef</a>是一种替换字符串类型枚举的注解</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class TypeCheck &#123;</span><br><span class="line">    public static final int TYPE_MUSIC = 0;</span><br><span class="line">    public static final int TYPE_PHOTO = 1;</span><br><span class="line">    public static final int TYPE_TEXT = 2;</span><br><span class="line"></span><br><span class="line">    public int itemType;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 无法确定传入的参数是否符合要求，这里可以利用IntDef/StringDef来对类型进行检查</span><br><span class="line">     */</span><br><span class="line">//    public void MethodCheck(int itemType) &#123;</span><br><span class="line">//        this.itemType = itemType;</span><br><span class="line">//    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Retention(RetentionPolicy.SOURCE)</span><br><span class="line">    @IntDef(&#123;TYPE_MUSIC, TYPE_PHOTO, TYPE_TEXT&#125;)</span><br><span class="line">    public @interface typeCheck &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public TypeCheck(@typeCheck int itemType) &#123;</span><br><span class="line">        this.itemType = itemType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @typeCheck</span><br><span class="line">    public int getType() &#123;</span><br><span class="line">        return itemType;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/07/Annotation 注解原理及使用/" data-id="cjtwrr60y00065f6s3fxa1v2b" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-/Retrofit相关/" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/07/Retrofit相关/" class="article-date">
  <time datetime="2018-03-07T12:50:02.580Z" itemprop="datePublished">2018-03-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/07/Retrofit相关/">Retrofit相关</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h5 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h5><blockquote>
<p> 在用Retrofit+RxJava向服务端请求数据的时候出现了异常</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Caused by: java.io.EOFException: End of input at line 1 column</span><br></pre></td></tr></table></figure>
<h5 id="问题所在"><a href="#问题所在" class="headerlink" title="问题所在"></a>问题所在</h5><p>原来的时候在请求其他接口的时候见过类似的<strong>Exception</strong>，是因为请求返回的数据跟接口定位需要返回的数据不匹配导致的(为什么不匹配就会导致异常，下面的问题分析会给出答案)。</p>
<blockquote>
<p>然后就利用<a href="https://paw.cloud/" target="_blank" rel="noopener">Paw</a>去进行接口调试，发现服务端就是返回成功状态了，没有响应体Body！最重要的是服务端是接入第三方的不好让人去改他们的返回逻辑,然后只能客户端自己去处理这种情况。</p>
</blockquote>
<h5 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h5><p>为什么定义的返回类型不匹配就会导致异常呢，查看了Retrofit的配置方法发现在初始化的时候通过<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>Retrofit retrofit = new Retrofit.Builder()<br>                .baseUrl(“”)<br>                .client(OkHttpManager.getOkHttpClient())<br>                .addConverterFactory(GsonConverterFactory.create(GsonUtil.getGson()))<br>                .addCallAdapterFactory(RxJavaCallAdapterFactory.create())<br>                .build();</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">##### 问题解决</span><br><span class="line"></span><br><span class="line">既然问题发现了，那就想着如何去解决了</span><br><span class="line">&gt; (当初第一个想法就是Gson解析错误，那就不用Gson了，但是项目已经开发了这么多，现在换个解析框架肯定来不及，而且成本也太高，最主要的是没法保证其他的解析框架就不好出现这个问题，所以这个想法也就是个想法)</span><br><span class="line"></span><br><span class="line">然后通过某度查找解决方法</span><br><span class="line">&gt; 虽然一直吐槽它，但是它的使用频率还是很高的，特别是在被墙的世界里</span><br><span class="line"></span><br><span class="line">这边也发现了几篇解决方案：</span><br><span class="line">&gt; [Retrofit 响应体无body时解析EOFException](http://blog.csdn.net/u011374875/article/details/51956113)</span><br><span class="line">&gt; </span><br><span class="line">&gt; [Android retrofit End of input at line 1 column 1 path](http://blog.csdn.net/it_talk/article/details/60767060)</span><br><span class="line"></span><br><span class="line">其中都给出了具体的解决方案</span><br><span class="line"></span><br><span class="line">* 自定义无Body的解析转换器，判断如果是无Body的时候调用此转换类</span><br><span class="line"></span><br><span class="line">	* 1.自定义无Body转换器</span><br></pre></td></tr></table></figure>
<pre><code>public class NullOnEmptyConverterFactory extends Converter.Factory {

public static final NullOnEmptyConverterFactory create() {
    return new NullOnEmptyConverterFactory();
}

public NullOnEmptyConverterFactory() {
}


@MethodInfo(date = &quot;2017-12-06 22:14:20&quot;, Desc = &quot;需要重写这里的responseBodyConverter&quot;)
@Override
public Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations, Retrofit retrofit) {
    Converter&lt;ResponseBody, ?&gt; delegate = retrofit.nextResponseBodyConverter(this, type, annotations);
    return new Converter&lt;ResponseBody, Object&gt;() {
        @Override
        public Object convert(ResponseBody value) throws IOException {
            /**
             * 当Body的Content-Length为0的时候就是没有Body的时候直接返回null
             */
            if (value.contentLength() == 0) {
                return null;
            }
            /**
             * 这里如果有Body的时候正常返回
             */
            return delegate.convert(value);
        }
    };
}


@MethodInfo(date = &quot;2017-12-06 22:15:49&quot;, Desc = &quot;这里的requestBodyConverter不需要重写&quot;)
@Override
public Converter&lt;?, RequestBody&gt; requestBodyConverter(Type type, Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
    return super.requestBodyConverter(type, parameterAnnotations, methodAnnotations, retrofit);
}

@MethodInfo(date = &quot;2017-12-06 22:16:36&quot;, Desc = &quot;这里的stringConverter不需要重写&quot;)
@Override
public Converter&lt;?, String&gt; stringConverter(Type type, Annotation[] annotations, Retrofit retrofit) {
    return super.stringConverter(type, annotations, retrofit);
}
</code></pre><p>}</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 2.配置到Retrofit的Build过程中</span><br></pre></td></tr></table></figure>

 Retrofit retrofit = new Retrofit.Builder()
            .baseUrl(&quot;&quot;)
            .client(OkHttpManager.getOkHttpClient())
            /**
             * 这里需要注意要加在Gson解析器之前，否则还是会导致异常
             */
            .addConverterFactory(NullOnEmptyConverterFactory.create())
            .addConverterFactory(GsonConverterFactory.create(GsonUtil.getGson()))
            .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
            .build();

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">	</span><br><span class="line">* 利用String接收无Body，添加```ScalarsConverterFactory</span><br></pre></td></tr></table></figure>

* 这里只需要添加<figure class="highlight plain"><figcaption><span>```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">	</span><br></pre></td></tr></table></figure>

 Retrofit retrofit = new Retrofit.Builder()
                .baseUrl(&quot;&quot;)
                .client(OkHttpManager.getOkHttpClient())
                .addConverterFactory(ScalarsConverterFactory.create())
                .addConverterFactory(GsonConverterFactory.create(GsonUtil.getGson()))
                .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
                .build();

```
</code></pre><h5 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h5>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/07/Retrofit相关/" data-id="cjtwrr60w00055f6sqt0a6ddq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-/加密算法初探/" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/07/加密算法初探/" class="article-date">
  <time datetime="2018-03-07T12:50:02.579Z" itemprop="datePublished">2018-03-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/07/加密算法初探/">加密算法初探</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://blog.csdn.net/shenggaofei/article/details/52333687" target="_blank" rel="noopener">各种加密算法</a></p>
<p><strong>公钥加密算法，计算机通信安全的基石，保证了加密数据不会被破解！</strong></p>
<h4 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h4><blockquote>
<p>利用同一个密钥对信息进行加密和解密</p>
</blockquote>
<ul>
<li><p>好处：算法公开，简单、速度快，而且对称加密通常使用的是相对较小的密钥，密钥越大，加密越强，但是加密和解密的过程越慢。所以说密钥大小既要考虑到安全性又要照顾到效率。</p>
</li>
<li><p>缺点：对密钥的管理和分配，就是如何把密钥发送到需要解密你的加密信息的人手里是一个大问题，在发送密钥的过程中很容易被拦截篡改。</p>
</li>
<li><p>常见的对称加密算法：<br>DES、3DES、AES、TDEA、Blowfish、RC5、IDEA</p>
<blockquote>
<p>DES：数据加密标准，64位密钥长度(其中8位的奇偶位，56位数据位，只有56位有效)对64位二进制数据库进行加密，每次加密进行16轮的编码</p>
<p>3DES：利用不同的三个密钥对数据进行三次加密，是DES的一个更加安全的变形。加密的过程是加密-解密-加密(这里不是加密-加密-加密，在于是为了与现有DES系统的向后兼容问题，因为当K1=K2时，三重DES的效果就和原来的DES一样),解密的过程是解密-加密-解密</p>
<p>AES：高级加密标准，下一代的加密算法标准，速度快，安全级别高，密钥有128、192和256位的</p>
</blockquote>
</li>
</ul>
<h4 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h4><blockquote>
<p>对数据的加密和解密采用的一对密钥，公钥和私钥</p>
</blockquote>
<ul>
<li><p>好处：对于密钥的管理更强，通常使用的是公钥进行加密然后双方都是用各自的私钥进行解密，安全性更高</p>
</li>
<li><p>缺点：加密过程慢</p>
</li>
<li><p>常见的非对称加密算法：<br>  RSA、ECC</p>
</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li><p>（1） 对称加密加密与解密使用的是同样的密钥，所以速度快，但由于需要将密钥在网络传输，所以安全性不高。</p>
</li>
<li><p>（2） 非对称加密使用了一对密钥，公钥与私钥，所以安全性高，但加密与解密速度慢。</p>
</li>
<li><p>（3） 解决的办法是将对称加密的密钥使用非对称加密的公钥进行加密，然后发送出去，接收方使用私钥进行解密得到对称加密的密钥，然后双方可以使用对称加密来进行沟通。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/07/加密算法初探/" data-id="cjtwrr60u00035f6som47c19n" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-/Android网络连接状态/" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/07/Android网络连接状态/" class="article-date">
  <time datetime="2018-03-07T12:50:02.578Z" itemprop="datePublished">2018-03-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/07/Android网络连接状态/">Android网络连接状态</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>Android系统中不同网络状态的获取和判断</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line">    * 获取当前的网络状态 ：没有网络-0：WIFI网络1：4G网络-4：3G网络-3：2G网络-2</span><br><span class="line">    * 自定义</span><br><span class="line">    *</span><br><span class="line">    * @param context</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">   public static int getAPNType(Context context) &#123;</span><br><span class="line">       //结果返回值</span><br><span class="line">       int netType = 0;</span><br><span class="line">       //获取手机所有连接管理对象</span><br><span class="line">       ConnectivityManager manager = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);</span><br><span class="line">       //获取NetworkInfo对象</span><br><span class="line">       NetworkInfo networkInfo = manager.getActiveNetworkInfo();</span><br><span class="line">       //NetworkInfo对象为空 则代表没有网络</span><br><span class="line">       if (networkInfo == null) &#123;</span><br><span class="line">           return netType;</span><br><span class="line">       &#125;</span><br><span class="line">       //否则 NetworkInfo对象不为空 则获取该networkInfo的类型</span><br><span class="line">       int nType = networkInfo.getType();</span><br><span class="line">       if (nType == ConnectivityManager.TYPE_WIFI) &#123;</span><br><span class="line">           //WIFI</span><br><span class="line">           netType = 1;</span><br><span class="line">       &#125; else if (nType == ConnectivityManager.TYPE_MOBILE) &#123;</span><br><span class="line">           int nSubType = networkInfo.getSubtype();</span><br><span class="line">           TelephonyManager telephonyManager = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);</span><br><span class="line">           //3G   联通的3G为UMTS或HSDPA 电信的3G为EVDO</span><br><span class="line">           if (nSubType == TelephonyManager.NETWORK_TYPE_LTE</span><br><span class="line">                   &amp;&amp; !telephonyManager.isNetworkRoaming()) &#123;</span><br><span class="line">               netType = 4;</span><br><span class="line">           &#125; else if (nSubType == TelephonyManager.NETWORK_TYPE_UMTS</span><br><span class="line">                   || nSubType == TelephonyManager.NETWORK_TYPE_HSDPA</span><br><span class="line">                   || nSubType == TelephonyManager.NETWORK_TYPE_EVDO_0</span><br><span class="line">                   &amp;&amp; !telephonyManager.isNetworkRoaming()) &#123;</span><br><span class="line">               netType = 3;</span><br><span class="line">               //2G 移动和联通的2G为GPRS或EGDE，电信的2G为CDMA</span><br><span class="line">           &#125; else if (nSubType == TelephonyManager.NETWORK_TYPE_GPRS</span><br><span class="line">                   || nSubType == TelephonyManager.NETWORK_TYPE_EDGE</span><br><span class="line">                   || nSubType == TelephonyManager.NETWORK_TYPE_CDMA</span><br><span class="line">                   &amp;&amp; !telephonyManager.isNetworkRoaming()) &#123;</span><br><span class="line">               netType = 2;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               netType = 2;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return netType;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h5 id="无线网络-wifi"><a href="#无线网络-wifi" class="headerlink" title="无线网络(wifi)"></a>无线网络(wifi)</h5><h5 id="5G网络"><a href="#5G网络" class="headerlink" title="5G网络"></a>5G网络</h5><h5 id="4G网络"><a href="#4G网络" class="headerlink" title="4G网络"></a>4G网络</h5><h5 id="3G网络"><a href="#3G网络" class="headerlink" title="3G网络"></a>3G网络</h5><h5 id="2G网络"><a href="#2G网络" class="headerlink" title="2G网络"></a>2G网络</h5><h5 id="弱网"><a href="#弱网" class="headerlink" title="弱网"></a>弱网</h5><h5 id="断网"><a href="#断网" class="headerlink" title="断网"></a>断网</h5>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/07/Android网络连接状态/" data-id="cjtwrr60t00025f6s87tyodmm" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-/Run/" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/07/Run/" class="article-date">
  <time datetime="2018-03-07T12:50:02.578Z" itemprop="datePublished">2018-03-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/07/Run/">跑步</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="曾经肥胖静好"><a href="#曾经肥胖静好" class="headerlink" title="曾经肥胖静好"></a>曾经肥胖静好</h4><blockquote>
<p> 2017-6月开始了第一次跑步，还记得是因为某一天站到称上，发现自己离开学校也就1年，然而体重却是长了不止10斤！有点担心自己在这么长下去就要提前进入油腻大叔的阶段。<strong>so</strong>对自己说要减肥！</p>
</blockquote>
<blockquote>
<p>刚开始的时候还没想到跑步，毕竟当初学校期间最怂的还是1000米跑…然后就开始选择每天晚上在地上折腾自己，翻看着从网上扒拉下拉的各种各样的减肥动作，然后跟着开始一板一眼的模仿起来！效果的话说实话真不知道有没有😶</p>
</blockquote>
<blockquote>
<p>然后有一天看到朋友圈里有一个学长晒着他参加半马的照片，突然萌发了我也要去跑步的想法。至今还记得刚开始跑步的那天，6月份的7点多，已经没有那么的炎热，人行道上路灯映照着几个人影。我开始迈出自己关于的第一步。(这是平时晚上的一小步，却是跑步的一大步)</p>
</blockquote>
<blockquote>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/07/Run/" data-id="cjtwrr60r00015f6sdc40wfhs" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/03/29/5.1节日旅游攻略/">5.1节日旅游攻略</a>
          </li>
        
          <li>
            <a href="/2018/03/07/各大商店应用图标、截图尺寸/">各大商店应用图标、截图尺寸</a>
          </li>
        
          <li>
            <a href="/2018/03/07/Android9.0曝光新特性/">Android9.0曝光新特性</a>
          </li>
        
          <li>
            <a href="/2018/03/07/TensorFlow入门/">TensorFlow入门</a>
          </li>
        
          <li>
            <a href="/2018/03/07/Android仓库托管平台/">Android仓库托管平台</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>
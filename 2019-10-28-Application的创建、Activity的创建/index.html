<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="搬砖的"><title>Application的创建、Activity的创建 | 沐白白白</title><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.3"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.3"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css?v=2.0.3"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js?v=2.0.3"></script><script src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=2.0.3"></script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Application的创建、Activity的创建</h1><a id="logo" href="/.">沐白白白</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="https://github.com/MoMuBai/DailyQA"><i class="fa fa-dailyQA"> DailyQA</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">Application的创建、Activity的创建</h1><div class="post-meta"><a href="/2019-10-28-Application的创建、Activity的创建/#comments" class="comment-count"></a><p><span class="date">Oct 28, 2019</span><span><a href="/categories/Android/" class="category">Android</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><p> <em>关于Activity需要知道的更多内容</em></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Activity作为作为四大组件中我们最常见的一个组件，经常接触使用，但是往往每次让我们对这个组件进行说明的时候，我们只知道它的几个生命周期，几种启动模式，但是具体的更多的就讲不出来了。<br>ps：我在写这个之前实际上也是一知半解，所以今天我们一起去看看Activity更多的东西，源码版本为 android-26</p>
<ul>
<li>1、Application的创建</li>
<li>2、Activity的创建和生命周期</li>
</ul>
<h4 id="一、Application的创建"><a href="#一、Application的创建" class="headerlink" title="一、Application的创建"></a>一、Application的创建</h4><p>我们知道，java程序想运行都是通过调用main方法来启动，我们的Android应用程序也是如此，但是我们每次都是直接点击手机屏幕的应用图标就直接启动了app，这时候难免有疑惑，我们为什么不需要调用main方法就可以直接启动我们的程序呢，虽然我们没有直接的去写main方法，但是实际上还是通过ActivityThread类的main方法来作为我们应用程序的入口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># ActivityThread类</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        ...</span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line">        ActivityThread thread = new ActivityThread();//1、这边new了一个ActivityThread对象</span><br><span class="line">        thread.attach(false);//2、这边去进行连接，连接什么？</span><br><span class="line">        if (sMainThreadHandler == null) &#123;</span><br><span class="line">            sMainThreadHandler = thread.getHandler();</span><br><span class="line">        &#125;</span><br><span class="line">        if (false) &#123;</span><br><span class="line">            Looper.myLooper().setMessageLogging(new</span><br><span class="line">                    LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;));</span><br><span class="line">        &#125;</span><br><span class="line">        Looper.loop();</span><br><span class="line">        throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>在ActivityThread类中，能看到一个main方法，它就是我们程序的入口，在注释1的地方，会去创建一个ActivityThread对象，在注释2的地方，调用thread的attach方法去连接，具体的连接什么我们继续看下面的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#ActivityThread类</span><br><span class="line">private void attach(boolean system) &#123;</span><br><span class="line">      ...</span><br><span class="line">      if (!system) &#123;</span><br><span class="line">          ...</span><br><span class="line">          final IActivityManager mgr = ActivityManager.getService();//1、通过AIDL，获取AMS的代理对象IActivityManager</span><br><span class="line">          try &#123;</span><br><span class="line">              mgr.attachApplication(mAppThread);//2、这边将AMS和我们的应用进程application进行连接</span><br><span class="line">          &#125; catch (RemoteException ex) &#123;</span><br><span class="line">              throw ex.rethrowFromSystemServer();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          ...</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>关于AIDL，这边不进行展开，我们关心的是注释2，这边通过AIDL将AMS和我们应用进程application进行连接，具体的是调用ActivityManagerService的attachApplication方法进行连接。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#ActivityManagerService类</span><br><span class="line">@Override</span><br><span class="line">public final void attachApplication(IApplicationThread thread) &#123;</span><br><span class="line">      synchronized (this) &#123;</span><br><span class="line">          int callingPid = Binder.getCallingPid();//1、获取pid</span><br><span class="line">          final long origId = Binder.clearCallingIdentity();</span><br><span class="line">          attachApplicationLocked(thread, callingPid);//2、传入pid进行连接</span><br><span class="line">          Binder.restoreCallingIdentity(origId);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>这边的注释1通过Binder对象获取应用的pid，注释2处调用attachApplicationLocked的方法传入pid连接application。需要注意的这边加了synchronized关键字，表示我们需要等待这里执行完毕才能下一步，也就是说我们一个应用需要当我们application被连接后才能走下面的流程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">##ActivityManagerService</span><br><span class="line">private final boolean attachApplicationLocked(IApplicationThread thread,</span><br><span class="line">                                                  int pid, int callingUid, long startSeq) &#123;</span><br><span class="line">        ProcessRecord app;  //1、进程记录类，保存相关的信息</span><br><span class="line">        long startTime = SystemClock.uptimeMillis();</span><br><span class="line">        if (pid != MY_PID &amp;&amp; pid &gt;= 0) &#123;</span><br><span class="line">            synchronized (mPidsSelfLocked) &#123;</span><br><span class="line">                app = mPidsSelfLocked.get(pid);  //2、根据id获取相关信息赋值给记录对象</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        ...</span><br><span class="line">        if (app.instr != null) &#123;  //3、判断进程是否正在活跃</span><br><span class="line">           //Application 4、绑定到当前线程</span><br><span class="line">           thread.bindApplication(processName, appInfo, providers, app.instr.mClass,</span><br><span class="line">                    profilerInfo, app.instr.mArguments, app.instr.mWatcher, app.instr.mUiAutomationConnection,</span><br><span class="line">                    testMode, mBinderTransactionTrackingEnabled, enableTrackAllocation,</span><br><span class="line">                    isRestrictedBackupMode || !normalMode, app.persistent, new Configuration(getGlobalConfiguration()),</span><br><span class="line">                    app.compat, getCommonServicesLocked(app.isolated), mCoreSettingsObserver.getCoreSettingsLocked(),</span><br><span class="line">                    buildSerial, isAutofillCompatEnabled);   </span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //Application 4、绑定到当前线程</span><br><span class="line">            thread.bindApplication(processName, appInfo, providers, null, profilerInfo,</span><br><span class="line">                    null, null, null, testMode, mBinderTransactionTrackingEnabled,</span><br><span class="line">                    enableTrackAllocation, isRestrictedBackupMode || !normalMode, app.persistent,</span><br><span class="line">                    new Configuration(getGlobalConfiguration()), app.compat, getCommonServicesLocked(app.isolated),</span><br><span class="line">                    mCoreSettingsObserver.getCoreSettingsLocked(), buildSerial, isAutofillCompatEnabled);  </span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        // See if the top visible activity is waiting to run in this process...</span><br><span class="line">        //查看顶部可见活动是否正在等待在此进程中进行</span><br><span class="line">        if (normalMode) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                //TODO 5、Activity创建的分析</span><br><span class="line">                //检测top的Activity是否在运行中等待</span><br><span class="line">                if (mStackSupervisor.attachApattachApplicationplicationLocked(app)) &#123;</span><br><span class="line">                    didSomething = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                Slog.wtf(TAG, &quot;Exception thrown launching activities in &quot; + app, e);</span><br><span class="line">                badApp = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Find any services that should be running in this process...</span><br><span class="line">        //查看在此进程中进行的服务</span><br><span class="line">        if (!badApp) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                didSomething |= mServices.attachApplicationLocked(app, processName);</span><br><span class="line">                checkTime(startTime, &quot;attachApplicationLocked: after mServices.attachApplicationLocked&quot;);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                Slog.wtf(TAG, &quot;Exception thrown starting services in &quot; + app, e);</span><br><span class="line">                badApp = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Check if a next-broadcast receiver is in this process...</span><br><span class="line">        //查看在此进程中进行的广播接收者</span><br><span class="line">        if (!badApp &amp;&amp; isPendingBroadcastProcessLocked(pid)) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                didSomething |= sendPendingBroadcastsLocked(app);</span><br><span class="line">                checkTime(startTime, &quot;attachApplicationLocked: after sendPendingBroadcastsLocked&quot;);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                // If the app died trying to launch the receiver we declare it &apos;bad&apos;</span><br><span class="line">                Slog.wtf(TAG, &quot;Exception thrown dispatching broadcasts in &quot; + app, e);</span><br><span class="line">                badApp = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Check whether the next backup agent is in this process...</span><br><span class="line">        //检测下一个备份代理是否在此进程中</span><br><span class="line">        if (!badApp &amp;&amp; mBackupTarget != null &amp;&amp; mBackupTarget.app == app) &#123;</span><br><span class="line">            if (DEBUG_BACKUP) Slog.v(TAG_BACKUP,</span><br><span class="line">                    &quot;New app is backup target, launching agent for &quot; + app);</span><br><span class="line">            notifyPackageUse(mBackupTarget.appInfo.packageName,</span><br><span class="line">                    PackageManager.NOTIFY_PACKAGE_USE_BACKUP);</span><br><span class="line">            try &#123;</span><br><span class="line">                thread.scheduleCreateBackupAgent(mBackupTarget.appInfo,</span><br><span class="line">                        compatibilityInfoForPackageLocked(mBackupTarget.appInfo),</span><br><span class="line">                        mBackupTarget.backupMode);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                Slog.wtf(TAG, &quot;Exception thrown creating backup agent in &quot; + app, e);</span><br><span class="line">                badApp = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看具体的attachApplicationLocked方法里面，注释1处创建了一个进程记录对象用来保存进程的相关信息，注释2根据id获取到相关信息赋值给记录对象，注释3先判断进行是否活跃，然后调用bindApplication的方法进行application的绑定，这边的thread是IApplicationThread对象，IApplicationThread它是一个AIDL的接口，是系统进程调用应用进程的接口，它的实现类是ApplicationThread，是一个在ActivityThread的内部类，注释5的地方是关于Activity的创建，我们这边先跳过，等我们将Application进行绑定完成后在来分析。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">##ActivityThread.ApplicationThread</span><br><span class="line">public final void bindApplication(String processName, ApplicationInfo appInfo...，String buildSerial) &#123;</span><br><span class="line"></span><br><span class="line">            if (services != null) &#123;</span><br><span class="line">                // Setup the service cache in the ServiceManager</span><br><span class="line">                ServiceManager.initServiceCache(services);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            setCoreSettings(coreSettings);//1、添加核心设置</span><br><span class="line"></span><br><span class="line">            //2、将bindApplication带进来的信息封装到AppBindData类中，通过handler发送出去</span><br><span class="line">            AppBindData data = new AppBindData();</span><br><span class="line">            data.processName = processName;</span><br><span class="line">            data.appInfo = appInfo;</span><br><span class="line">            data.providers = providers;</span><br><span class="line">            ...</span><br><span class="line">            sendMessage(H.BIND_APPLICATION, data);//3、将data通过handler发送出去，具体的WHAT 是 H.BIND_APPLICATION</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>在注释1会去添加一些核心的设置，我们这边就不去关注，我们看注释2的地方，去将带进来的信息封装到data中然后在注释3通过handler发送出去，具体的WHAT 是 H.BIND_APPLICATION。H是一个继承Handler的子类，这边我们去看下消息是如何被分发处理的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">##ActivityThread.H</span><br><span class="line">public void handleMessage(Message msg) &#123;</span><br><span class="line">            ...</span><br><span class="line">        switch (msg.what) &#123;</span><br><span class="line">            ...</span><br><span class="line">           case BIND_APPLICATION:</span><br><span class="line">                    //1、这边进行handler消息的处理 处理创建Application的消息</span><br><span class="line">                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;bindApplication&quot;);</span><br><span class="line">                    AppBindData data = (AppBindData) msg.obj;</span><br><span class="line">                    handleBindApplication(data);</span><br><span class="line">                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                    break;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这边注释1处理创建Application的消息，调用handleBindApplication的方法去绑定application<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">##ActivityThread</span><br><span class="line">private void handleBindApplication(AppBindData data) &#123;</span><br><span class="line"></span><br><span class="line">      final InstrumentationInfo ii;//1、创建InstrumentationInfo对象</span><br><span class="line"></span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line">      final ContextImpl appContext = ContextImpl.createAppContext(this, data.info); 2、 //获取application的context上下文</span><br><span class="line">      </span><br><span class="line">      //  3、加载instrumentation</span><br><span class="line">      if (ii != null) &#123;</span><br><span class="line">          ...</span><br><span class="line">          </span><br><span class="line">          mInstrumentation.init(this, instrContext, appContext, component,</span><br><span class="line">                  data.instrumentationWatcher, data.instrumentationUiAutomationConnection); //4、instrumentation初始化</span><br><span class="line">          ...</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          mInstrumentation = new Instrumentation();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      try &#123;</span><br><span class="line">        </span><br><span class="line">          Application app = data.info.makeApplication(data.restrictedBackupMode, null);//5、通过makeApplication方法创建application</span><br><span class="line"></span><br><span class="line">          ...</span><br><span class="line">          </span><br><span class="line">          // Do this after providers, since instrumentation tests generally start their</span><br><span class="line">          // test thread at this point, and we don&apos;t want that racing.</span><br><span class="line">          try &#123;</span><br><span class="line">              mInstrumentation.onCreate(data.instrumentationArgs);</span><br><span class="line">          &#125; catch (Exception e) &#123;</span><br><span class="line">              throw new RuntimeException(</span><br><span class="line">                      &quot;Exception thrown in onCreate() of &quot;</span><br><span class="line">                              + data.instrumentationName + &quot;: &quot; + e.toString(), e);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          try &#123;</span><br><span class="line">              mInstrumentation.callApplicationOnCreate(app);//6、回调application的onCreate方法</span><br><span class="line">          &#125; catch (Exception e) &#123;</span><br><span class="line">              if (!mInstrumentation.onException(app, e)) &#123;</span><br><span class="line">                  throw new RuntimeException(</span><br><span class="line">                          &quot;Unable to create application &quot; + app.getClass().getName()</span><br><span class="line">                                  + &quot;: &quot; + e.toString(), e);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">          StrictMode.setThreadPolicy(savedPolicy);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法里面处理了许多事情，注释1创建了一个InstrumentationInfo对象，在注释2获取了application的上下文，注释3和4去加载并初始化了InstrumentationInfo，注释5是我们的关键地方，通过调用makeApplication的方法创建了我们的application，我们看下makeApplication的方法都做了什么操作。然后在注释6调用InstrumentationInfo去回调application的onCreate方法，到这里我们的application就创建并且回到了我们熟悉onCreate方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">##LoadedApk</span><br><span class="line">public Application makeApplication(boolean forceDefaultAppClass,</span><br><span class="line">           Instrumentation instrumentation) &#123;</span><br><span class="line">       if (mApplication != null) &#123;//1、如果mApplication不为null，直接返回mApplication对象</span><br><span class="line">           return mApplication;</span><br><span class="line">       &#125;</span><br><span class="line">     </span><br><span class="line">       Application app = null;</span><br><span class="line">      //如果是有自定义的application，就用这个，如果没有，就用系统的application</span><br><span class="line">       String appClass = mApplicationInfo.className;</span><br><span class="line">       if (forceDefaultAppClass || (appClass == null)) &#123;</span><br><span class="line">           appClass = &quot;android.app.Application&quot;;</span><br><span class="line">       &#125;</span><br><span class="line">       try &#123;</span><br><span class="line">           //2、获得类加载器然后通过反射去new一个Appliction</span><br><span class="line">           java.lang.ClassLoader cl = getClassLoader();</span><br><span class="line">           ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this);</span><br><span class="line">           app = mActivityThread.mInstrumentation.newApplication(</span><br><span class="line">                   cl, appClass, appContext);</span><br><span class="line">           appContext.setOuterContext(app);</span><br><span class="line">       &#125; catch (Exception e) &#123;</span><br><span class="line">           ...</span><br><span class="line">       &#125;</span><br><span class="line">       mActivityThread.mAllApplications.add(app);</span><br><span class="line">       mApplication = app;//3、赋值给mApplication</span><br><span class="line"></span><br><span class="line">       if (instrumentation != null) &#123;//4、这边会为instrumentation是为null的</span><br><span class="line">           try &#123;</span><br><span class="line">               instrumentation.callApplicationOnCreate(app);//5、这边如果instrumentation不为null，才能执行到这里</span><br><span class="line">           &#125; catch (Exception e) &#123;</span><br><span class="line">               if (!instrumentation.onException(app, e)) &#123;</span><br><span class="line">                  ...</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       ...</span><br><span class="line">       return app;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这边我们首先判断mApplication如果不为null，直接返回这个对象，如果为null的话，我们通过类加载然后反射去new出一个application对象并且赋值给mApplication，还有这边因为我们在调用makeApplication方法时传入的Instrumentation是个null对象，所以我们这边不会去执行<br>callApplicationOnCreate回调onCreate方法的。具体的回调onCreate会在上面的源码注释6的地方去执行回调。</p>
<h4 id="二、Activity的创建"><a href="#二、Activity的创建" class="headerlink" title="二、Activity的创建"></a>二、Activity的创建</h4><p>这边我们首先需要知道Activity的状态和生命周期</p>
<p>状态：运行、暂停、停止、销毁(运行和暂停是不可见的，停止和销毁是不可见的)<br>生命周期：包括了常见的onCreate、onResume、onStart、onPause、onStop、onDestory等</p>
<p>上面的分析过程中我们在ActivityManagerService类中留了一个<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">##ActivityManagerService</span><br><span class="line">private final boolean attachApplicationLocked(IApplicationThread thread,</span><br><span class="line">                                                  int pid, int callingUid, long startSeq) &#123;</span><br><span class="line">        ...</span><br><span class="line"> //5、检测最可见的Activity是否在运行进程中等待，如果再则创建Activity</span><br><span class="line">        //TODO 待分析Activity的创建</span><br><span class="line">        if (mStackSupervisor.attachApplicationLocked(app)) &#123;  </span><br><span class="line">            didSomething = true;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>这边我们对它进行深入下看看是如何创建的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">##ActivityStackSupervisor</span><br><span class="line">boolean attachApplicationLocked(ProcessRecord app) throws RemoteException &#123;</span><br><span class="line">       ...</span><br><span class="line">       for (int displayNdx = mActivityDisplays.size() - 1; displayNdx &gt;= 0; --displayNdx) &#123;</span><br><span class="line">           ArrayList&lt;ActivityStack&gt; stacks = mActivityDisplays.valueAt(displayNdx).mStacks;</span><br><span class="line">           for (int stackNdx = stacks.size() - 1; stackNdx &gt;= 0; --stackNdx) &#123;</span><br><span class="line">               final ActivityStack stack = stacks.get(stackNdx);</span><br><span class="line">               if (!isFocusedStack(stack)) &#123;</span><br><span class="line">                   continue;</span><br><span class="line">               &#125;</span><br><span class="line">               //ActivityRecord来维护Activity运行时的状态信息，需要将Activity绑定到AMS，ActivityRecord才能开始Activity的生命周期</span><br><span class="line">               ActivityRecord hr = stack.topRunningActivityLocked();</span><br><span class="line">               if (hr != null) &#123;</span><br><span class="line">                   if (hr.app == null &amp;&amp; app.uid == hr.info.applicationInfo.uid</span><br><span class="line">                           &amp;&amp; processName.equals(hr.processName)) &#123;</span><br><span class="line">                       try &#123;</span><br><span class="line">                           if (realStartActivityLocked(hr, app, true, true)) &#123;//1、真正的创建Activity</span><br><span class="line">                               didSomething = true;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125; catch (RemoteException e) &#123;</span><br><span class="line">                           throw e;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       ...</span><br><span class="line">       return didSomething;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>在realStartActivityLocked我们会创建Activity<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">##ActivityStackSupervisor</span><br><span class="line"> final boolean realStartActivityLocked(ActivityRecord r, ProcessRecord app,</span><br><span class="line">            boolean andResume, boolean checkConfig) throws RemoteException &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        r.startFreezingScreenLocked(app, 0);//1、开始屏幕相关的启动</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        // schedule launch ticks to collect information about slow apps.</span><br><span class="line">        r.startLaunchTickingLocked();//2、启动定时锁定</span><br><span class="line"></span><br><span class="line">        r.app = app;</span><br><span class="line">        app.waitingToKill = null;</span><br><span class="line">        r.launchCount++;//3、每启动一次launchCount的数量自增</span><br><span class="line">        r.lastLaunchTime = SystemClock.uptimeMillis();//4、修改最后一次的启动时间</span><br><span class="line"></span><br><span class="line">        final ActivityStack stack = task.getStack();</span><br><span class="line">        try &#123;</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            //5、根据具体的包名，通知应用</span><br><span class="line"></span><br><span class="line">         mService.notifyPackageUse(r.intent.getComponent().getPackageName(),</span><br><span class="line">                                      PackageManager.NOTIFY_PACKAGE_USE_ACTIVITY);</span><br><span class="line">            </span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            //6、调用ApplicationThread的scheduleLaunchActivity 方法去启动LaunchActivity</span><br><span class="line">            app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken,</span><br><span class="line">                    System.identityHashCode(r), r.info,</span><br><span class="line">                    // TODO: Have this take the merged configuration instead of separate global and</span><br><span class="line">                    // override configs.</span><br><span class="line">                    mergedConfiguration.getGlobalConfiguration(),</span><br><span class="line">                    mergedConfiguration.getOverrideConfiguration(), r.compat,</span><br><span class="line">                    r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle,</span><br><span class="line">                    r.persistentState, results, newIntents, !andResume,</span><br><span class="line">                    mService.isNextTransitionForward(), profilerInfo);</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        if (isFocusedStack(stack)) &#123;</span><br><span class="line">            mService.startSetupActivityLocked();7、开始设置活动锁</span><br><span class="line">        &#125;</span><br><span class="line">        if (r.app != null) &#123;</span><br><span class="line">            mService.mServices.updateServiceConnectionActivitiesLocked(r.app);//8、更新服务连接活动锁</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>这边的注释很多，但是我们主要关心的是注释6，这边调用ApplicationThread的scheduleLaunchActivity 方法去启动LaunchActivity，我们回到ApplicationThread</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">##ActivityThread.ApplicationThread</span><br><span class="line">@Override</span><br><span class="line">public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident,</span><br><span class="line">                                       ..., ProfilerInfo profilerInfo) &#123;</span><br><span class="line"></span><br><span class="line">    updateProcessState(procState, false);</span><br><span class="line"></span><br><span class="line">    ActivityClientRecord r = new ActivityClientRecord();</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    sendMessage(H.LAUNCH_ACTIVITY, r);//通过handler发送启动Activity的消息</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这边是不是很眼熟，我们刚刚的application的绑定也是通过handler去发送消息去处理(这边我们能发现handler是有多么重要了吧，哈哈)，我们去ActivityThread的子类H去看下具体的activity创建的消息处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void handleMessage(Message msg) &#123;</span><br><span class="line">        switch (msg.what) &#123;</span><br><span class="line">            case LAUNCH_ACTIVITY: &#123;//1、接收到关于创建Activity的消息，进行处理</span><br><span class="line">                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityStart&quot;);</span><br><span class="line">                final ActivityClientRecord r = (ActivityClientRecord) msg.obj;</span><br><span class="line">                r.packageInfo = getPackageInfoNoCheck(</span><br><span class="line">                        r.activityInfo.applicationInfo, r.compatInfo);</span><br><span class="line">                handleLaunchActivity(r, null, &quot;LAUNCH_ACTIVITY&quot;);//2、去创建LaunchActivity</span><br><span class="line">                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据message的what值我们找到了具体的消息处理，这边会通过handleLaunchActivity去处理我们Activity创建<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">##ActivityThread</span><br><span class="line"> private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) &#123;</span><br><span class="line">        ...</span><br><span class="line">        Activity a = performLaunchActivity(r, customIntent);//1、去执行LaunchActivity</span><br><span class="line"></span><br><span class="line">        if (a != null) &#123;</span><br><span class="line">            r.createdConfig = new Configuration(mConfiguration);</span><br><span class="line">            reportSizeConfigurations(r);</span><br><span class="line">            Bundle oldState = r.state;</span><br><span class="line">            handleResumeActivity(r.token, false, r.isForward,</span><br><span class="line">                    !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason);//2、处理可见Activity</span><br><span class="line">            ...</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // If there was an error, for any reason, tell the activity manager to stop us.</span><br><span class="line">            try &#123;</span><br><span class="line">            //3、这边如何activity是个null的对象，直接通过ActivityManagerService调用finishActivity去关闭掉</span><br><span class="line">                ActivityManager.getService()</span><br><span class="line">                        .finishActivity(r.token, Activity.RESULT_CANCELED, null,</span><br><span class="line">                                Activity.DONT_FINISH_TASK_WITH_ACTIVITY);</span><br><span class="line">            &#125; catch (RemoteException ex) &#123;</span><br><span class="line">                throw ex.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>这边我们先看注释1的performLaunchActivity方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">##ActivityThread</span><br><span class="line">private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        ActivityInfo aInfo = r.activityInfo;//1、获取Activity的信息</span><br><span class="line">        if (r.packageInfo == null) &#123;</span><br><span class="line">            r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo,</span><br><span class="line">                    Context.CONTEXT_INCLUDE_CODE);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        ContextImpl appContext = createBaseContextForActivity(r);//2、获取Acitivty的上下文</span><br><span class="line">        Activity activity = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            java.lang.ClassLoader cl = appContext.getClassLoader();//3、获取类加载器，使用cl(类加载器）加载出Activity，再使用反射new出Activity</span><br><span class="line">            activity = mInstrumentation.newActivity(</span><br><span class="line">                    cl, component.getClassName(), r.intent);</span><br><span class="line">            StrictMode.incrementExpectedActivityCount(activity.getClass());</span><br><span class="line">            r.intent.setExtrasClassLoader(cl);</span><br><span class="line">            r.intent.prepareToEnterProcess();</span><br><span class="line">            if (r.state != null) &#123;</span><br><span class="line">                r.state.setClassLoader(cl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">           ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            //4、这边又去调用一次makeApplication方法</span><br><span class="line">            Application app = r.packageInfo.makeApplication(false, mInstrumentation);</span><br><span class="line">            if (activity != null) &#123;</span><br><span class="line">                ...</span><br><span class="line">                appContext.setOuterContext(activity);</span><br><span class="line"></span><br><span class="line">                activity.attach(appContext, this, getInstrumentation(), r.token,</span><br><span class="line">                        r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">                        r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">                        r.referrer, r.voiceInteractor, window, r.configCallback);</span><br><span class="line"></span><br><span class="line">                ...</span><br><span class="line">                if (r.isPersistable()) &#123;//5、这边去调用Activity的onCreate方法</span><br><span class="line">                    mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">                &#125;</span><br><span class="line">                ...</span><br><span class="line"></span><br><span class="line">        &#125; catch (SuperNotCalledException e) &#123;</span><br><span class="line">            throw e;</span><br><span class="line"></span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">           ...</span><br><span class="line">        &#125;</span><br><span class="line">        return activity;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在注释3我们会发现这边是获取类加载去然后通过反射去new出一个Activity，然后在注释5去回调Activity的onCreate方法，到这边我们就能去调用我们的setContentView去加载布局了。注释4的地方又调用了一次makeApplication方法，如果Application不为null，直接返回application对象。<br>现在我们回到上一个源码的注释2那里，看看handleResumeActivity都做了什么?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">##ActivityThread</span><br><span class="line"> final void handleResumeActivity(IBinder token,</span><br><span class="line">                                    boolean clearHide, boolean isForward, boolean reallyResume, int seq, String reason) &#123;</span><br><span class="line">        ...</span><br><span class="line">        r = performResumeActivity(token, clearHide, reason);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法里面有很多代码，我们只需要去看performResumeActivity方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">##ActivityThread</span><br><span class="line">public final ActivityClientRecord performResumeActivity(IBinder token, boolean clearHide, String reason) &#123;</span><br><span class="line">    ...</span><br><span class="line">    r.activity.performResume();//主要是这个方法</span><br><span class="line">    ...</span><br><span class="line">    return r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这边是调用Activity的performResume方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">##Activity</span><br><span class="line">final void performResume() &#123;</span><br><span class="line">        performRestart();</span><br><span class="line"></span><br><span class="line">        mFragments.execPendingActions();</span><br><span class="line"></span><br><span class="line">        mLastNonConfigurationInstances = null;</span><br><span class="line"></span><br><span class="line">        mCalled = false;</span><br><span class="line">        // mResumed is set by the instrumentation</span><br><span class="line">        mInstrumentation.callActivityOnResume(this);//回调Activity的onResume方法</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>到这边我们就能发现它跟Activity的onCreate的回调是类似的，都是通过mInstrumentation.callActivityxxx去回调执行。</p>
<h4 id="沿着别人走过的路，跟上去发现不一样的风景"><a href="#沿着别人走过的路，跟上去发现不一样的风景" class="headerlink" title="沿着别人走过的路，跟上去发现不一样的风景"></a>沿着别人走过的路，跟上去发现不一样的风景</h4><p>参考链接：<a href="https://www.jianshu.com/p/f55467033146" target="_blank" rel="noopener">https://www.jianshu.com/p/f55467033146</a></p>
</div><div class="post-copyright"><blockquote><p>原文作者: 沐白</p><p>原文链接: <a href="https:mubai.site/2019-10-28-Application的创建、Activity的创建/">https:mubai.site/2019-10-28-Application的创建、Activity的创建/</a></p><p>版权声明: 转载请注明出处(必须保留作者署名及链接)</p></blockquote></div><div class="tags"><a href="/tags/Android/">Android</a></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2019-11-2-Activity 布局加载分析/" class="pre">Activity 布局加载分析</a><a href="/2019-3-31-5.1旅游攻略/" class="next">5.1节日旅游攻略</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#一、Application的创建"><span class="toc-number">1.1.</span> <span class="toc-text">一、Application的创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#二、Activity的创建"><span class="toc-number">1.2.</span> <span class="toc-text">二、Activity的创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#沿着别人走过的路，跟上去发现不一样的风景"><span class="toc-number">1.3.</span> <span class="toc-text">沿着别人走过的路，跟上去发现不一样的风景</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020-3-21-礼物专线/">GiftForGirl</a></li><li class="post-list-item"><a class="post-list-link" href="/2020-1-9-蓝牙知识模块之Android开发/">蓝牙知识模块之Android开发之旅</a></li><li class="post-list-item"><a class="post-list-link" href="/2020-1-4-蓝牙知识模块之Android坑/">蓝牙知识模块之Android坑</a></li><li class="post-list-item"><a class="post-list-link" href="/2019-12-25-多线程交替打印数组/">多线程交替打印数组元素</a></li><li class="post-list-item"><a class="post-list-link" href="/2019-12-30-蓝牙知识模块之简介/">蓝牙知识模块之简介</a></li><li class="post-list-item"><a class="post-list-link" href="/2019-12-20-沉浸式状态栏/">沉浸式状态栏</a></li><li class="post-list-item"><a class="post-list-link" href="/2019-12-2-Rxjava2 太多方法了，记不住呀/">Rxjava2 太多方法了，记不住呀</a></li><li class="post-list-item"><a class="post-list-link" href="/2019-11-2-Activity 布局加载分析/">Activity 布局加载分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2019-10-28-Application的创建、Activity的创建/">Application的创建、Activity的创建</a></li><li class="post-list-item"><a class="post-list-link" href="/2019-3-31-5.1旅游攻略/">5.1节日旅游攻略</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">25</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/开发规范/">开发规范</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/总结/">总结</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/机器学习/">机器学习</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/架构/">架构</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/物联网/">物联网</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/闲文/">闲文</a><span class="category-list-count">5</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/开发规范/" style="font-size: 15px;">开发规范</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/闲文/" style="font-size: 15px;">闲文</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/架构/" style="font-size: 15px;">架构</a> <a href="/tags/总结/" style="font-size: 15px;">总结</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/机器学习/" style="font-size: 15px;">机器学习</a> <a href="/tags/物联网/" style="font-size: 15px;">物联网</a> <a href="/tags/Maven/" style="font-size: 15px;">Maven</a> <a href="/tags/简历/" style="font-size: 15px;">简历</a> <a href="/tags/礼物专线/" style="font-size: 15px;">礼物专线</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">十二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">十一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">十月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://juejin.im/" title="掘金" target="_blank">掘金</a><ul></ul><a href="https://www.wanandroid.com/" title="玩安卓" target="_blank">玩安卓</a><ul></ul><a href="https://www.simon96.online/2018/10/12/hexo-tutorial/" title="遇见西门" target="_blank">遇见西门</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">沐白.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.3"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.3" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script><script src="/live2dw/lib/L2Dwidget.min.js?bd2294fafea3389ee458f1d9be5a2157"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>
<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>LeakCancary的使用和原理 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="目录： 为什么会有LeakCancary 什么是LeakCancary LeakCancary的使用 LeakCancary的实现过程   Why LeakCancary Square在开源项目LeakCancary的前言就提到了 “A small leak will sink a great ship” 我们可以翻译过来用一句名言来表示：“千里之堤溃于蚁穴”  1234java.lang.Out">
<meta property="og:type" content="article">
<meta property="og:title" content="LeakCancary的使用和原理">
<meta property="og:url" content="http://yoursite.com/2018/03/07//LeakCancary的使用和原理//index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="目录： 为什么会有LeakCancary 什么是LeakCancary LeakCancary的使用 LeakCancary的实现过程   Why LeakCancary Square在开源项目LeakCancary的前言就提到了 “A small leak will sink a great ship” 我们可以翻译过来用一句名言来表示：“千里之堤溃于蚁穴”  1234java.lang.Out">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://p0sgkjh7x.bkt.clouddn.com/374F4D1C-CDAA-4FA1-BD09-1EFEE81C4B81.png">
<meta property="og:updated_time" content="2018-03-07T12:50:02.585Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LeakCancary的使用和原理">
<meta name="twitter:description" content="目录： 为什么会有LeakCancary 什么是LeakCancary LeakCancary的使用 LeakCancary的实现过程   Why LeakCancary Square在开源项目LeakCancary的前言就提到了 “A small leak will sink a great ship” 我们可以翻译过来用一句名言来表示：“千里之堤溃于蚁穴”  1234java.lang.Out">
<meta name="twitter:image" content="http://p0sgkjh7x.bkt.clouddn.com/374F4D1C-CDAA-4FA1-BD09-1EFEE81C4B81.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-/LeakCancary的使用和原理/" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/07/LeakCancary的使用和原理/" class="article-date">
  <time datetime="2018-03-07T12:50:02.584Z" itemprop="datePublished">2018-03-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      LeakCancary的使用和原理
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="目录："><a href="#目录：" class="headerlink" title="目录："></a>目录：</h3><ul>
<li>为什么会有<em>LeakCancary</em></li>
<li>什么是<em>LeakCancary</em></li>
<li><em>LeakCancary</em>的使用</li>
<li><em>LeakCancary</em>的实现过程</li>
</ul>
<hr>
<h4 id="Why-LeakCancary"><a href="#Why-LeakCancary" class="headerlink" title="Why LeakCancary"></a>Why LeakCancary</h4><blockquote>
<p><strong>Square</strong>在开源项目<strong>LeakCancary</strong>的前言就提到了</p>
<p><strong>“A small leak will sink a great ship”</strong></p>
<p>我们可以翻译过来用一句名言来表示：<br><strong>“千里之堤溃于蚁穴”</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError</span><br><span class="line">        at android.graphics.Bitmap.nativeCreate(Bitmap.java:-2)</span><br><span class="line">        at android.graphics.Bitmap.createBitmap(Bitmap.java:689)</span><br><span class="line">        at com.squareup.ui.SignView.createSignatureBitmap(SignView.java:121)</span><br></pre></td></tr></table></figure>
<p><strong>OOM</strong> 项目中最让人头疼的一个异常，它不像一些其他异常很显示的给你指出并且容易解决，它的产生原因一般都是内存对象的不正确使用导致GC无法正常的回收对象，进而产生内存泄露，让系统的内存空间逐渐的不够，然后导致内存溢出。</p>
<p><strong>Square</strong>公司有篇文章说过他们在使用Bitmap进行签名页面进行绘制过程中，创建的bitmap对象经常性的产生OOM。<br>为了解决这个问题，<strong>Square</strong>做出了很多的对策，包括：</p>
<ul>
<li>使用<strong>Bitmap.Config.ALPHA_8</strong>节省内存</li>
<li>手动捕获<strong>OOM</strong>，调用<strong>GC</strong></li>
</ul>
<p>但是实际上效果并不好，后来他们发现是方向错了，当系统中分配的内存已经不够了，这时候OOM可以发生在任何的地方，特别是一些大对象的使用，比如Bitmap的创建。OOM只是表象，更深层次的问题可能是：<strong>内存泄露</strong></p>
<p>但是在原来的时候排查内存泄露是个全手工的过程,为了解决这个问题，<strong>LeakCancary</strong>出现了。</p>
<h4 id="What-LeakCancary"><a href="#What-LeakCancary" class="headerlink" title="What LeakCancary"></a>What LeakCancary</h4><p><strong><a href="https://github.com/square/leakcanary" target="_blank" rel="noopener">LeakCancary</a></strong>是<strong>Square</strong>公司推出的一款Java和Android内存泄露检查框架，如果检测到某个地方产生了内存泄露，LeakCancary会生成一个显示的通知，并且在Locat会有相应的log日志提醒，通过显示的通知和log日志我们可以对内存泄露进行准确的定位并去解决它。</p>
<h4 id="Use-LeakCancary"><a href="#Use-LeakCancary" class="headerlink" title="Use LeakCancary"></a>Use LeakCancary</h4><p><img src="http://p0sgkjh7x.bkt.clouddn.com/374F4D1C-CDAA-4FA1-BD09-1EFEE81C4B81.png" alt="LeakCancary显示通知图"></p>
<p><em>LeakCancary显示通知图镇楼</em></p>
<p>关于<strong>LeakCancary</strong>的开源和使用，Square最初的目的是为了能更好的对app进行内存泄露的检测，而且是为了能更简的入手，所以它的使用就不会很复杂，实际上用法也是很简单：</p>
<ul>
<li>在build.gradle添加引用：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">debugCompile &apos;com.squareup.leakcanary:leakcanary-android:1.5.4&apos;</span><br><span class="line">releaseCompile &apos;com.squareup.leakcanary:leakcanary-android-no-op:1.5.4&apos;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当前最新版本为1.5.4，可以根据git上的最新版本进行升级</p>
</blockquote>
<ul>
<li>在<strong>自定义继承Application</strong>中添加<strong>RefWatcher</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Ys7App extends Application &#123;</span><br><span class="line"></span><br><span class="line"> 	 /**</span><br><span class="line"> 	  * RefWatcher对象</span><br><span class="line"> 	  */</span><br><span class="line">    private RefWatcher refWatcher;</span><br><span class="line"></span><br><span class="line">    public static RefWatcher getRefWatcher(Context context) &#123;</span><br><span class="line">        Ys7App application = (Ys7App) context.getApplicationContext();</span><br><span class="line">        return application.refWatcher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate() &#123;</span><br><span class="line">        super.onCreate();</span><br><span class="line">        refWatcher = LeakCanary.install(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>不要忘记把自定义继承的<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">然后我们就可以去写**内存泄露**了(咳咳，说错了，是去发现内存泄露)</span><br><span class="line"></span><br><span class="line">说个很常见的内存泄露问题：*关于Context对象的使用*</span><br><span class="line"></span><br><span class="line">项目中很多地方都需要用到**Context**对象,有时候我们会直接使用**Activity**的**Context**对象，有时候会使用全局的**Context**对象。关于这个我们要说说关于在**Activity**中使用单例模式的问题，很多时候我们需要去维护一个全局的方法，很容易想到用单例模式，它也是设计模式中最简单易懂的一个，但是它如果使用不好就会产生**内存泄露**问题。</span><br><span class="line"></span><br><span class="line">* TextView的一个单例实现类</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>public class TextHelper {<br>    private static TextHelper mTextHelper;<br>    private Context mContext;<br>    private TextView mTextView;</p>
<pre><code>private TextHelper(Context context) {
    this.mContext = context;
}

public static TextHelper getTextHelper(Context context) {
    if (null == mTextHelper) {
        mTextHelper = new TextHelper(context);
    }
    return mTextHelper;
}

/**
 * 设置TextView的大小和颜色
 *
 * @param textView
 */
@SuppressLint(&quot;NewApi&quot;)
public void setText(TextView textView) {
    this.mTextView = textView;
    this.mTextView.setTextSize(20f);
    this.mTextView.setTextColor(mContext.getColor(R.color.black));
}
</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 这里因为我们需要引用到资源文件中的color文件，所以需要个**Context**对象</span><br><span class="line"></span><br><span class="line">* 在Activity中使用：</span><br></pre></td></tr></table></figure>
<p> TextHelper.getTextHelper(SDKActivity.this).setText(nameText);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt; 这里我们使用了当前**Activity**的**Context**对象</span><br><span class="line"></span><br><span class="line">这里因为在**Activity**中使用了当前的**Context**对象，看上去没什么问题，但是如果我们退出当前Activity后(引入了**LeakCancary**的前提)，会在通知栏看到产生了个内存泄露通知</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;http://p0sgkjh7x.bkt.clouddn.com/D879CC01A4E508F2835F89036A03A0A6.jpg&quot; height=&quot;250&quot; width=&quot;150&quot;/&gt;</span><br><span class="line"></span><br><span class="line">然后我们通过查看**Leaks**中的列表问题</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;http://p0sgkjh7x.bkt.clouddn.com/F6A127ED4F1BAA1DFD5CE4F6B3C8012A.jpg&quot; height=&quot;250&quot; width=&quot;150&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&gt; Leaks:由于App运行中产生了内存泄露然后显示在手机上，在这边是一个内存泄露的问题列表，然后我们可以通过查看每一项进行问题的查看</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;http://p0sgkjh7x.bkt.clouddn.com/94088C38003714DBF648267A164FF6B4.jpg&quot; height=&quot;250 &quot; width=&quot;150&quot; /&gt;</span><br><span class="line"></span><br><span class="line">这边就是我们通过leaked5.8查看的具体问题，可以看到Leaks已经帮我们把内存泄露的地方指出来了，这是因为我们的**Activity**在退出后它的**Context**对象被单例模式中的方法持有 着，但是**Activity**已经不存在了，这里就产生了内存泄露。</span><br><span class="line">&gt; 实际上这是个很简单但是又很容易犯的问题</span><br><span class="line">&gt; </span><br><span class="line">&gt; 同时我们也可以通过点击Leaks边上的**+**来进行更多信息的查看</span><br><span class="line"></span><br><span class="line">所以我们这里的话要解决这个内存泄露就要传入一个全局的**Context**对象</span><br></pre></td></tr></table></figure>
<p>TextHelper.getTextHelper(Application.getInstance()).setText(nameText);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">或者是直接在单例模式中直接获取全局的**Context**对象</span><br></pre></td></tr></table></figure>
<p>public class TextHelper {<br>    private static TextHelper mTextHelper;<br>    private Context mContext;<br>    private TextView mTextView;</p>
<pre><code>private TextHelper(Context context) {
    this.mContext = Application.getInstance();
}

public static TextHelper getTextHelper() {
    if (null == mTextHelper) {
        mTextHelper = new TextHelper();
    }
    return mTextHelper;
}

/**
 * 设置TextView的大小和颜色
 *
 * @param textView
 */
@SuppressLint(&quot;NewApi&quot;)
public void setText(TextView textView) {
    this.mTextView = textView;
    this.mTextView.setTextSize(20f);
    this.mTextView.setTextColor(mContext.getColor(R.color.black));
}
</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">这里就能避免由于**Context**对象的被持有导致的**内存泄露**。</span><br><span class="line"></span><br><span class="line">&gt; 实际上我们项目开发过程中会或多或少的产生**内存泄露**，这里只是举了一个简单的例子，我们只能通过去发现然后排查解决。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### Behind LeakCancary</span><br><span class="line">&gt; 在使用框架的同时也要关注下背后的实现过程和原理</span><br><span class="line">&gt; 我们通过对源码进行一步步的分解</span><br><span class="line"></span><br><span class="line">* 返回**RefWatcher**的过程</span><br></pre></td></tr></table></figure>
<p>private RefWatcher refWatcher;<br>refWatcher = LeakCanary.install(this);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; 通过**install()**方法</span><br></pre></td></tr></table></figure>
<p>public static RefWatcher install(Application application) {<br>        return ((AndroidRefWatcherBuilder)refWatcher(application).listenerServiceClass(DisplayLeakService.class).excludedRefs(AndroidExcludedRefs.createAppDefaults().build())).buildAndInstall();<br>    }</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; 继续对**buildAndInstall()**进行分析</span><br></pre></td></tr></table></figure>
<p>public RefWatcher buildAndInstall() {<br>        RefWatcher refWatcher = this.build();<br>        if(refWatcher != RefWatcher.DISABLED) {<br>            LeakCanary.enableDisplayLeakActivity(this.context);<br>            ActivityRefWatcher.install((Application)this.context, refWatcher);<br>        }</p>
<pre><code>    return refWatcher;
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; 在这里会返回一个**AndroidRefWatcher**，所以我们在对**Activity**进行内存泄露检查的时候，不需要专门添加代码，这里的**AndroidRefWatcher**会自动的帮我们进行检查</span><br></pre></td></tr></table></figure>
<p>public final class ActivityRefWatcher {<br>    private final ActivityLifecycleCallbacks lifecycleCallbacks = new ActivityLifecycleCallbacks() {<br>        public void onActivityCreated(Activity activity, Bundle savedInstanceState) {<br>        }</p>
<pre><code>    public void onActivityStarted(Activity activity) {
    }

    public void onActivityResumed(Activity activity) {
    }

    public void onActivityPaused(Activity activity) {
    }

    public void onActivityStopped(Activity activity) {
    }

    public void onActivitySaveInstanceState(Activity activity, Bundle outState) {
    }

    public void onActivityDestroyed(Activity activity) {
      //调用ActivityRefWatcher的watch方法
       ActivityRefWatcher.this.onActivityDestroyed(activity);
    }
};
</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 在**ActivityRefWatcher**中我们发现会有关于**Activity**生命周期的回调监听并且在**onDestroy()**中会去添加**ActivityRefWatcher**的**watch**方法，但是这里也需要注意的是**registerActivityLifecycleCallbacks()**是在Api14以后才添加的方法，所以如果要在Api14以前检测就需要自己去重写onDestory并在里面添加RefWatcher.watch()方法</span><br><span class="line"></span><br><span class="line">如果是在**Fragment**中需要检查内存泄露情况的话需要我们自己实现**RefWatcher**的**watch**方法</span><br></pre></td></tr></table></figure>
<p>public class BaseFragment extends Fragment {</p>
<pre><code>@Override
public void onDestroy() {
    super.onDestroy();
    //返回一个RefWatcher对象
    RefWatcher refWatcher = Ys7App.getRefWatcher(getActivity());
    refWatcher.watch(this);
}
</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; 在这里有个疑问，为什么**Square**公司在设计**LeakCancary**的时候，考虑到了**Activity**，添加了对应的**ActivityRefWatcher**，但是对于碎片**Fragment**并没有去设计对应的**FragmentRefWatcher**方法,不知道是因为Fragment的生命周期过多还是其他的原因，也许我们可以自己根据**ActivityRefWatcher**的实现方法设计一套自己的**FragmentRefWatcher**，先留个想法...</span><br><span class="line"></span><br><span class="line">* RefWatcher是如何能够对内存泄露进行检测的</span><br><span class="line"></span><br><span class="line">通过观察RefWatcher的watch()方法</span><br></pre></td></tr></table></figure>
<p>public void watch(Object watchedReference, String referenceName) {<br>if(this != DISABLED) {<br>…<br>long watchStartNanoTime = System.nanoTime();<br>String key = UUID.randomUUID().toString();<br>this.retainedKeys.add(key);<br>//创建一个KeyedWeakReference弱引用对象<br>KeyedWeakReference reference = new KeyedWeakReference(watchedReference, key, referenceName, this.queue);<br>this.ensureGoneAsync(watchStartNanoTime, reference);<br>}<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里创建了一个**KeyedWeakReference**对象，这是个弱引用的对象</span><br></pre></td></tr></table></figure>
<p>private void ensureGoneAsync(final long watchStartNanoTime, final KeyedWeakReference reference) {<br>//执行操作，检查弱引用对象是否被清除<br>this.watchExecutor.execute(new Retryable() {<br>    public Result run() {<br>        return RefWatcher.this.ensureGone(reference, watchStartNanoTime);<br>    }<br>});<br>}</p>
<p>Result ensureGone(KeyedWeakReference reference, long watchStartNanoTime) {<br>…<br>if(this.debuggerControl.isDebuggerAttached()) {<br>    return Result.RETRY;<br>} else if(this.gone(reference)) {<br>    return Result.DONE;<br>} else {<br>    //手动调用GC<br>    this.gcTrigger.runGc();<br>    this.removeWeaklyReachableReferences();<br>    //如果弱引用对象还存在，则说明内存泄露了，生成hprof文件<br>     if(!this.gone(reference)) {<br>                File heapDumpFile = this.heapDumper.dumpHeap();<br>                …<br>                this.heapdumpListener.analyze(new HeapDump(heapDumpFile, reference.key, reference.name, this.excludedRefs, watchDurationMs, gcDurationMs, heapDumpDurationMs));<br>            }<br>     }<br>    return Result.DONE;<br>}<br>//retainedKeys中是否包含弱引用对象的key<br>private boolean gone(KeyedWeakReference reference) {<br>        return !this.retainedKeys.contains(reference.key);<br>    }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在**WatchExector**的后台线程中执行检查弱引用对象是否被清除，如果没有清除，则调用一次GC，(这边能够检查弱引用对象还是根据**KeyedWeakReference**是以key-value形式存在的对象)</span><br><span class="line">如果弱引用对象没有被清除，则说明内存泄露了，系统就导出hprof文件,保存在app系统目录下</span><br></pre></td></tr></table></figure>
<p>final class KeyedWeakReference extends WeakReference<object> {<br>        //key-value形式存在<br>    public final String key;<br>    public final String name;</object></p>
<pre><code>KeyedWeakReference(Object referent, String key, String name, ReferenceQueue&lt;Object&gt; referenceQueue) {
    super(Preconditions.checkNotNull(referent, &quot;referent&quot;), 
    ...
</code></pre><p>}</p>
<p><code>`</code></p>
<hr>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>根据<strong>Square</strong>公司的数据说明他们在使用了<strong>LeakCancary</strong>后，减少了<strong>94%</strong>由OOM导致的cash。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/07/LeakCancary的使用和原理/" data-id="cjtwrr63w000y5f6sp94ywu1q" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/03/07/2017年年度总结+2018年目标展望/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          2017年年度总结+2018年目标展望
        
      </div>
    </a>
  
  
    <a href="/2018/03/07/安卓的进程保活/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">安卓的进程保活</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/03/29/5.1节日旅游攻略/">5.1节日旅游攻略</a>
          </li>
        
          <li>
            <a href="/2018/03/07/各大商店应用图标、截图尺寸/">各大商店应用图标、截图尺寸</a>
          </li>
        
          <li>
            <a href="/2018/03/07/Android9.0曝光新特性/">Android9.0曝光新特性</a>
          </li>
        
          <li>
            <a href="/2018/03/07/TensorFlow入门/">TensorFlow入门</a>
          </li>
        
          <li>
            <a href="/2018/03/07/Android仓库托管平台/">Android仓库托管平台</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>
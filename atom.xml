<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>沐白白白</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https:mubai.site/"/>
  <updated>2020-03-21T08:41:44.069Z</updated>
  <id>https:mubai.site/</id>
  
  <author>
    <name>沐白</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>GiftForGirl</title>
    <link href="https:mubai.site/2020-3-21-%E7%A4%BC%E7%89%A9%E4%B8%93%E7%BA%BF/"/>
    <id>https:mubai.site/2020-3-21-礼物专线/</id>
    <published>2020-03-20T16:00:00.000Z</published>
    <updated>2020-03-21T08:41:44.069Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GiftForGirl"><a href="#GiftForGirl" class="headerlink" title="GiftForGirl"></a>GiftForGirl</h2><p><strong><em>专为男士为女士送礼用，包括香水、口红、包包、手链、镯子、耳环、项链、丝巾、帽子、护肤品、化妆品、指甲油、睡衣、内衣等等，仅供参考</em></strong></p><p><em>顺序不分先后，随便排的，开心就好，目前只是大概写写抄抄，内容待补充，未完待续</em></p><hr><ul><li><a href="#1-香水">香水</a></li><li><a href="#2-口红">口红</a></li><li><a href="#3-包包">包包</a></li><li><a href="#4-手链">手链</a></li><li><a href="#5-镯子">镯子</a></li><li><a href="#6-耳环">耳环</a></li><li><a href="#7-项链">项链</a></li><li><a href="#8-丝巾">丝巾</a></li><li><a href="#9-帽子">帽子</a></li><li><a href="#10-护肤品">护肤品</a></li><li><a href="#11-化妆品">化妆品</a></li><li><a href="#12-指甲油">指甲油</a></li><li><a href="#13-太阳眼镜">太阳眼镜</a></li><li><a href="#14-手表">手表</a></li><li><a href="#15-钱包">钱包</a></li><li><a href="#16-内衣">内衣</a></li><li><a href="#17-睡衣">睡衣</a></li></ul><h3 id="1-香水"><a href="#1-香水" class="headerlink" title="1 香水"></a>1 香水</h3><ul><li>Dior</li><li>CHANEL</li><li>菲拉格慕</li><li>范思哲</li><li>伊丽莎白雅顿</li><li>巴宝莉</li><li>阿玛尼</li><li>祖马龙</li><li>兰蔻</li><li>圣罗兰</li><li>橘滋</li></ul><h3 id="2-口红"><a href="#2-口红" class="headerlink" title="2 口红"></a>2 口红</h3><ul><li>圣罗兰YSL</li><li>魅可MAC</li><li>迪奥Dior</li><li>纪梵希Givenchy</li><li>资生堂SHISEIDO</li><li>美宝莲</li><li>阿玛尼Armaani</li><li>兰蔻LANCOME</li><li>香奈儿CHANEL</li><li>欧莱雅</li><li>汤姆福特Tom Ford</li><li>美丽小屋</li></ul><h3 id="3-包包"><a href="#3-包包" class="headerlink" title="3 包包"></a>3 包包</h3><ul><li>路易威登LV</li><li>香奈儿CHANEL</li><li>爱马仕Hermes</li><li>普拉达Prada</li><li>古驰Gucci</li><li>圣大保罗Polo</li><li>登喜路Dunhill</li><li>沙驰SATCHI</li><li>鳄鱼Lacoste</li><li>梦特娇Montagut</li></ul><h3 id="4-手链"><a href="#4-手链" class="headerlink" title="4 手链"></a>4 手链</h3><ul><li>潘多拉</li><li>路易威登LV</li><li>迪奥Dior</li><li>卡地亚</li><li>蒂芙尼</li><li>佐卡伊</li><li>芬迪</li><li>梵克雅宝</li><li>宝格丽</li><li>施华洛世奇</li></ul><h3 id="5-镯子"><a href="#5-镯子" class="headerlink" title="5 镯子"></a>5 镯子</h3><ul><li>施华洛世奇</li><li>潘多拉</li><li>蒂芙尼</li><li>卡地亚</li><li>爱马仕</li></ul><h3 id="6-耳环"><a href="#6-耳环" class="headerlink" title="6 耳环"></a>6 耳环</h3><ul><li>宝格丽</li><li>伯爵</li><li>梵克雅宝</li><li>Qeelin麒麟</li><li>施华洛世奇</li><li>橘滋</li><li>菲尼莎</li><li>依慧达</li><li>御木本</li><li>波米雷特</li><li>Oxette</li><li>尚晨珠宝</li><li>吉盟</li><li>梵蒂诺</li></ul><h3 id="7-项链"><a href="#7-项链" class="headerlink" title="7 项链"></a>7 项链</h3><ul><li>蒂芙尼</li><li>施华洛世奇</li><li>海盗船</li><li>Julie</li><li>卡地亚</li><li>宝格丽</li><li>蒙奇奇</li><li>梵克雅宝</li><li>爱马仕</li><li>迪奥</li><li>周大福</li><li>周生生</li><li>谢瑞麟TSL</li><li>潮宏基CHJ</li><li>周大生</li><li>老凤祥</li><li>六福</li></ul><h3 id="8-丝巾"><a href="#8-丝巾" class="headerlink" title="8 丝巾"></a>8 丝巾</h3><ul><li>爱马仕</li><li>玛利亚·古琦</li><li>万事利</li><li>博柏利</li><li>Zara飒拉</li><li>路易威登LV</li><li>鹿王</li><li>以纯</li><li>维信</li><li>宝石蝶</li><li>龙翔纺织</li><li>丝界</li><li>丝绸故事</li><li>喜得宝</li><li>上海故事</li><li>妩WOO</li><li>绝代佳人</li></ul><h3 id="9-帽子"><a href="#9-帽子" class="headerlink" title="9 帽子"></a>9 帽子</h3><ul><li>彩蓝EB</li><li>来可派</li><li>丽华LH</li><li>爱马仕</li><li>博柏利</li><li>快乐狐狸</li><li>拜丽德</li><li>GAP盖璞</li><li>红日</li><li>盛锡福</li></ul><h3 id="10-护肤品"><a href="#10-护肤品" class="headerlink" title="10 护肤品"></a>10 护肤品</h3><ul><li>法国lancome(兰蔻)-睫毛膏、兰蔻粉水</li><li>美国estee lauder(雅诗兰黛)-adbanced night repair(简称anr)系列、海蓝之谜</li><li>日本shiseido(资生堂)</li><li>法国dior(迪奥)-蓝金唇膏、5色眼影</li><li>法国chanel(香奈尔)</li><li>美国clinique(倩碧)-护肤三步曲</li><li>日本sk-ii-护肤精华露(又称神仙水)</li><li>法国biotherm(碧欧泉)-活泉水分露</li><li>hr(赫莲娜)-极至之美胶原系列、维他命c精华系列</li><li>美国伊丽沙白.雅顿-8小时润泽霜</li><li>雅斯兰黛的眼霜</li><li>sk2的各种护肤品、面膜</li><li>前男友面膜</li><li>luna洗脸仪</li><li>面部按摩仪   </li><li>Dreamtimes 梦幻时光爽肤水</li><li>FANCL芳柯</li><li>Ipsa流金水</li><li>Ipsa自律循环乳液</li><li>CPB水磨精华</li><li>珂润浸润保湿水+保湿面霜</li><li>碧欧泉新活泉爽肤组合</li><li>倩碧(润肤露)黄油</li><li>资生堂红色蜜露</li><li>DHC橄榄滋养套装</li><li>高丝雪肌精乳液</li><li>兰蔻精华肌底液(小黑瓶)</li><li>丝塔芙洁面乳</li><li>AVENE雅漾舒护活泉水</li></ul><h3 id="11-化妆品"><a href="#11-化妆品" class="headerlink" title="11 化妆品"></a>11 化妆品</h3><ul><li><p>欧莱雅：</p><ul><li>顶级品牌：HR(赫莲娜)是旗舰产品</li><li>二线产品：Lancome(兰蔻)，Biotherm(碧欧泉)</li><li>三线或三线以下产品：LOrealParis(欧莱雅)，kiehls(契尔氏)，美爵士、Garnier(卡尼尔)，羽西，小护士，INNEOV</li><li>彩妆品牌：CCBPARIS、shuuemura(植村秀)、Maybelline(美宝莲)</li><li>药妆品牌：Vichy(薇姿)，LAROCHE-POSAY(理肤泉)、SkinCeuticals(杜克)</li><li>香水品牌：GiorgioArmaniParfums(阿玛尼)，RalphLaurenParfums(拉尔夫*劳伦、POLO),caelParfums(卡夏尔)，VIKTOR&amp;ROLF</li><li>发用品牌：KERASTASE卡诗、MATRIX、MIZANI、REDKEN、SOFTSHEENCARSO</li></ul></li><li><p>宝洁公司</p><ul><li>顶级品牌：SK-II(Maxfactor)—就是蜜丝佛陀</li><li>二线品牌：Olay(玉兰油)、Illume(伊奈美)、Always、Zest</li><li>彩妆品牌：Covergirl(封面女郎)</li><li>亚洲区第一彩妆品牌：ANNASUI(安娜苏)</li><li>香水品牌：Hugoboss、Locaste、ANNASUI(安娜苏)、Escada(艾斯卡达)、Dunhill(登喜路)、Valention、Lanvin(朗万)、PaulSmith(保罗史密斯)</li><li>洗护品牌：飘柔、海飞丝、激爽(刚淘汰)、潘婷、润妍、沙宣、伊卡璐(Clairol)、舒肤佳、Wella(威娜)</li></ul></li><li><p>雅诗兰黛</p><ul><li>顶级品牌：LaMer(海蓝之谜)—–港台翻译为海洋之蓝</li><li>一线品牌：雅诗兰黛</li><li>二线品牌：Clinique(倩碧)</li><li>三线品牌：Stila、Origins(品木宣言)、Prescriptives、、Aveda(肯梦)和JoMalone</li><li>顶级限量彩妆品牌：TomFord(汤姆福特)</li><li>彩妆品牌：BobbiBrown(芭比波朗)、M.A.C(魅可).</li><li>香水品牌：TommyHilfiger(唐美希绯格)、DKNY(唐可娜儿)、Aramis(雅男士)</li><li>开架品牌：BeautyBank(目前仅在Kohls百货售卖，总共推出了Flirt、AmericanBeauty、GoodSkin及以Grassroots4个系</li></ul></li><li><p>资生堂</p><ul><li>顶级品牌：CledePeau(CDP)、IPSA(茵芙莎)</li><li>二线品牌：Ettusais(爱杜莎)、CARITA 凯伊黛、Decleor 思妍丽</li><li>底线品牌：ShiseidoFitit、Asplir(爱泊丽)、DeLuxe、ff 、SELFIT(珊妃)、Whitia(白媞雅)、FT Shiseido、泊美</li><li>彩妆品牌：Maquillage</li><li>中国专售：AUPRES欧珀莱、Za姬芮</li><li>香水品牌：JeanPaulGaultier、三宅一生</li><li>洗护品牌：ShiseidoProfessional</li></ul></li><li><p>LVMH</p><ul><li>护肤品牌：Guerlain(娇兰)、ChristianDior(迪奥)、纪梵希(Givenchy)、DomPerignon(唐-裴利农)、Bliss、CLARINS(娇韵诗)</li><li>彩妆品牌：Makeupforever(浮生若梦)、BENEFIT、Cosmetics、AcquadiParma、Fresh、SEPHORA(丝芙兰)</li><li>香水品牌：KENZO(高田贤三)，fendi(芬迪)，Celine(赛琳)、LOEWE、DOLCE&amp;GABBANA(杜嘉班纳)、CHAUMET(舒维)、CalvinKlein(CK)、ChristianLacroi</li></ul></li><li><p>Chanel(香奈儿)</p></li><li>LG<ul><li>顶级护肤品牌：OHUI</li><li>二线护肤品牌：IsaKnox爱之浓思、海皙蓝、LaeVert(莲婷)</li><li>底线品牌：曼丽妃丝、缇兰</li></ul></li></ul><h4 id="12-指甲油"><a href="#12-指甲油" class="headerlink" title="12 指甲油"></a>12 指甲油</h4><ul><li>芭比波朗</li><li>RGB</li><li>NARS</li><li>CND</li><li>莎莉汉森</li><li>巴黎欧莱雅</li><li>ESSIE</li><li>露华浓</li><li>China Glaze</li><li>OPI</li><li>美宝莲Maybelline</li><li>Missha谜尚</li><li>歌诗美COSMAY</li><li>香奈儿</li><li>Za姬芮</li><li>丝芙兰</li><li>安娜苏AnnaSui</li><li>Innisfree悦丝风吟</li><li>TheFaceShop菲斯小铺</li><li>露华浓Revlon</li><li>迪奥Dior</li></ul><h3 id="13-太阳眼镜"><a href="#13-太阳眼镜" class="headerlink" title="13 太阳眼镜"></a>13 太阳眼镜</h3><ul><li>雷德蒙女士太阳镜</li><li>爱靓眼镜女士太阳镜</li><li>阿玛尼女士太阳镜</li><li>暴龙女士太阳镜</li><li>海伦凯勒女士太阳镜</li><li>宝丽来女士太阳镜</li><li>kalikali女士太阳镜</li><li>GUCCI女士太阳镜</li><li>香奈儿女士太阳镜</li><li>雷朋女士太阳镜</li><li>古驰女士太阳镜</li><li>帕莎女士太阳镜</li><li>阿玛尼女士太阳镜</li><li>卡地亚女士太阳镜</li><li>帕莎女士太阳镜</li><li>欣菲特女士太阳镜</li><li>海豚女士太阳镜</li><li>派丽蒙女士太阳镜</li><li>万宝龙女士太阳镜</li><li>保圣女士太阳镜</li><li>宝姿女士太阳镜</li></ul><h3 id="14-手表"><a href="#14-手表" class="headerlink" title="14 手表"></a>14 手表</h3><ul><li>dw手表 尼龙表带简约休闲女士手表、女士简约金属钢带手表、玫瑰金女士手表</li><li>雷达</li><li>浪琴 PRIMALUNA心月 系列L8.111.4.87.6腕表、圆舞曲系列-玫瑰金镶钻腕表</li><li>天梭 T028.210.11.057.01</li><li>名士 灵霓系列MOA10036腕表</li><li>美度 DONNA Caliber 80超长动力储存女士腕表</li><li>艾米龙 净雅系列06.2188.L.6.6.28.6腕表</li><li>万宝龙 明星经典系列U0110304腕表</li><li>艾美 典雅系列LC6016-SS002-130腕表</li><li>欧米茄 星座系列</li><li>卡地亚 蓝气球系列、桑托斯系列、伦敦SOLO系列、「坦克」女款、山度士</li><li>劳力士 日志</li><li>香奈儿BOY FRIEND 系列</li><li>爱彼皇家 橡树满天星</li><li>法穆兰</li></ul><h3 id="15-钱包"><a href="#15-钱包" class="headerlink" title="15 钱包"></a>15 钱包</h3><ul><li>路易威登LV</li><li>古琦欧·古琦Gucci</li><li>香奈儿CHANEL</li><li>普拉达Prada</li><li>圣大保罗Polo</li><li>迪奥Dior</li><li>爱马仕Hermes</li><li>寇兹/寇驰COACH</li><li>登喜路Dunhill</li><li>芬迪Fendi</li></ul><h3 id="16-内衣"><a href="#16-内衣" class="headerlink" title="16 内衣"></a>16 内衣</h3><ul><li>古今</li><li>婷美</li><li>法曼儿</li><li>华歌尔</li><li>仙黛尔</li><li>LA PERLA</li><li>都市丽人</li><li>欧迪芬</li><li>嘉莉诗</li><li>歌瑞尔</li><li>梦芭莎</li><li>猫人</li><li>安莉芳</li><li>维多利亚的秘密</li><li>雅芳</li><li>爱慕</li><li>黛安芬</li><li>曼妮芬</li></ul><h3 id="17-睡衣"><a href="#17-睡衣" class="headerlink" title="17 睡衣"></a>17 睡衣</h3><ul><li>芬腾</li><li>安之伴</li><li>美标Meibiao</li><li>爱慕Aimer</li><li>秋鹿</li><li>歌瑞尔</li><li>康妮雅</li><li>维多利亚的秘密</li><li>美梦</li><li>沃莱卡</li><li>安莉芳</li><li>雪俐</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;GiftForGirl&quot;&gt;&lt;a href=&quot;#GiftForGirl&quot; class=&quot;headerlink&quot; title=&quot;GiftForGirl&quot;&gt;&lt;/a&gt;GiftForGirl&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;专为男士为女士送礼用，包括香水、口红、包包、
      
    
    </summary>
    
      <category term="闲文" scheme="https:mubai.site/categories/%E9%97%B2%E6%96%87/"/>
    
    
      <category term="礼物专线" scheme="https:mubai.site/tags/%E7%A4%BC%E7%89%A9%E4%B8%93%E7%BA%BF/"/>
    
  </entry>
  
  <entry>
    <title>蓝牙知识模块之Android开发之旅</title>
    <link href="https:mubai.site/2020-1-9-%E8%93%9D%E7%89%99%E7%9F%A5%E8%AF%86%E6%A8%A1%E5%9D%97%E4%B9%8BAndroid%E5%BC%80%E5%8F%91/"/>
    <id>https:mubai.site/2020-1-9-蓝牙知识模块之Android开发/</id>
    <published>2020-01-06T16:00:00.000Z</published>
    <updated>2020-05-22T15:08:55.725Z</updated>
    
    <content type="html"><![CDATA[<p> <em>蓝牙知识模块之Android应用</em></p><h3 id="一、Android之Ble开发之旅"><a href="#一、Android之Ble开发之旅" class="headerlink" title="一、Android之Ble开发之旅:"></a>一、Android之Ble开发之旅:</h3><ul><li>检测权限：蓝牙、定位</li><li><p>检查蓝牙是否开启，没有打开就去打开，然后等一小会再去检测</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"> //检测蓝牙是否打开</span><br><span class="line">void openBluetoothScanDevice() &#123;</span><br><span class="line">    if (!BluetoothAdapter.getDefaultAdapter().isEnabled()) &#123;</span><br><span class="line">        //蓝牙没打开则去打开蓝牙</span><br><span class="line">        boolean openresult = toEnable(BluetoothAdapter.getDefaultAdapter());</span><br><span class="line">        if(!openresult)&#123;</span><br><span class="line">            Toast.makeText(MainActivity.this, &quot;打开蓝牙失败，请检查是否禁用了蓝牙权限&quot;,Toast.LENGTH_LONG).show();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //停个半秒再检查一次</span><br><span class="line">        SystemClock.sleep(500);</span><br><span class="line">        runOnUiThread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                int i = 0;</span><br><span class="line">                while (!BluetoothAdapter.getDefaultAdapter().isEnabled())&#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(500);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (i &gt;= 15)&#123;</span><br><span class="line">                        Toast.makeText(MainActivity.this, &quot;打开蓝牙失败，请检查是否禁用了蓝牙权限&quot;,Toast.LENGTH_LONG).show();</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;else&#123;</span><br><span class="line">                        i++;</span><br><span class="line">                    &#125;</span><br><span class="line"> </span><br><span class="line">                &#125;</span><br><span class="line">                //发现蓝牙打开了，则进行开启扫描的步骤</span><br><span class="line">                scanDevice();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //检查下当前是否在进行扫描 如果是则先停止</span><br><span class="line">        if (mBle != null &amp;&amp; mScanning)&#123;</span><br><span class="line">            mBle.stopScan();</span><br><span class="line">        &#125;</span><br><span class="line">        scanDevice();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>开始扫描蓝牙：注意这边也不能重复的去扫描，有时候多扫描几次，然后那个有些设备刚出现就消失，然后就一直发现不了，最好只能是重启蓝牙，所以这边多次扫描最好有个间隔时间，200ms也行</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">@UiThread</span><br><span class="line">void scanDevice() &#123;</span><br><span class="line">    //如果此时发蓝牙工作还是不正常 则打开手机的蓝牙面板让用户开启</span><br><span class="line">    if (mBle != null &amp;&amp; !mBle.adapterEnabled()) &#123;</span><br><span class="line">        Intent enableBtIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);</span><br><span class="line">        startActivityForResult(enableBtIntent, REQUEST_ENABLE_BT);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    myhandler.postDelayed(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            //检查一下去那些，如果没有则动态请求一下权限</span><br><span class="line">            requestPermission();</span><br><span class="line">            //开启扫描</span><br><span class="line">            scanLeDevice(true);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,500);</span><br><span class="line">&#125;</span><br><span class="line">private void scanLeDevice(final boolean enable) &#123;</span><br><span class="line">    //获取ble操作类</span><br><span class="line">    mBle = AppContext.getInstance().getmBle();</span><br><span class="line">    if (mBle == null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (enable) &#123;</span><br><span class="line">        //开始扫描</span><br><span class="line">        if (mBle != null) &#123;</span><br><span class="line">            boolean startscan = mBle.startScan(resultCallback);</span><br><span class="line">            if (!startscan)&#123;</span><br><span class="line">                Toast.makeText(MainActivity.this, &quot;开启蓝牙扫描失败，请检查蓝牙是否正常工作！&quot;,Toast.LENGTH_LONG).show();</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            mScanning = true;</span><br><span class="line">            //扫描一分钟后停止扫描</span><br><span class="line">            myhandler.postDelayed(stopRunnable,SCAN_PERIOD);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //停止扫描</span><br><span class="line">        mScanning = false;</span><br><span class="line">        if (mBle != null) &#123;</span><br><span class="line">            mBle.stopScan();</span><br><span class="line">            myhandler.removeCallbacksAndMessages(null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>找到蓝牙–&gt;连接：这边要注意有些设备连接上后里面断开，然后又去连接，又断开，这次重复几次后设备找不到了，还是只能重启蓝牙，所以这边也是一样，要注意下间隔时间。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"> private BluetoothGattCallback mGattCallback = new BluetoothGattCallback() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onConnectionStateChange(final BluetoothGatt gatt, int status,</span><br><span class="line">                                            int newState) &#123;</span><br><span class="line">            super.onConnectionStateChange(gatt, status, newState);</span><br><span class="line">            Log.e(TAG, &quot;onConnectionStateChange()       status:&quot; + status + &quot;    newState:&quot; + newState);</span><br><span class="line">            String address = gatt.getDevice().getAddress();</span><br><span class="line">            if (status == BluetoothGatt.GATT_SUCCESS) &#123;</span><br><span class="line">                //如果是主动断开的 则断开</span><br><span class="line">                if (newState == BluetoothProfile.STATE_CONNECTED) &#123;</span><br><span class="line">                    reconnectCount = 0;</span><br><span class="line">                    Log.e(TAG, &quot;连接成功&quot;);</span><br><span class="line">                    if(connectionStateCallback != null)&#123;</span><br><span class="line">connectionStateCallback.onConnectionStateChange(status,newState);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else if (newState == BluetoothProfile.STATE_DISCONNECTED) &#123;</span><br><span class="line">                    disconnect(address);</span><br><span class="line">                    Log.e(TAG, &quot;断开成功&quot;);</span><br><span class="line">                    if(connectionStateCallback != null)&#123;</span><br><span class="line">                        connectionStateCallback.onConnectionStateChange(status,newState);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                //如果是收到莫名其妙的断开状态的话 则重连一次</span><br><span class="line">                if (newState != BluetoothProfile.STATE_CONNECTED &amp;&amp; canreconntect) &#123;</span><br><span class="line">                    //先断开原有的连接</span><br><span class="line">                    disconnect(address);</span><br><span class="line">                    if(reconnectCount &gt;= 2)&#123;</span><br><span class="line">                        //重连三次不成功就失败</span><br><span class="line">                        if(connectionStateCallback != null)&#123;</span><br><span class="line">                            connectionStateCallback.onConnectionStateChange(status,newState);</span><br><span class="line">                        &#125;</span><br><span class="line">                        reconnectCount = 0;</span><br><span class="line">                        canreconntect = false;</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //再次重新连接</span><br><span class="line">                    boolean connect_resule = requestConnect(address,connectionStateCallback,true);</span><br><span class="line">                    reconnectCount++;</span><br><span class="line">                    Log.e(TAG,&quot;正在尝试重新连接：&quot;+connect_resule);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    if(connectionStateCallback != null)&#123;</span><br><span class="line">                        connectionStateCallback.onConnectionStateChange(status,newState);</span><br><span class="line">                    &#125;</span><br><span class="line">                    disconnect(address);</span><br><span class="line"> </span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></li><li><p>发送数据：通过UUID找到service在通过UUID找到characteristic特征值，特征值又分为：(UUID是设备提供了，没有就去找他们要去！传统蓝牙用的是socket来进行通讯，而ble则不大一样，使用的是characteristic，同时ble传输的16进制数据)</p><ul><li>read 读</li><li>write 写</li><li><p>notify 通知</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//通过characteristic发送数据</span><br><span class="line">public boolean requestWriteCharacteristic(String address,byte[] data) &#123;</span><br><span class="line">        BluetoothGatt gatt = mBluetoothGatts.get(address);</span><br><span class="line">        if (gatt == null || mGattCharacteristicWrite == null) &#123;</span><br><span class="line">            if (gatt == null) &#123;</span><br><span class="line">                Log.e(TAG, &quot;发送BLE数据失败:gatt = null&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            if (mGattCharacteristicWrite == null) &#123;</span><br><span class="line">                Log.e(TAG, &quot;发送BLE数据失败:characteristic = null&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        Log.d(TAG, &quot;data：&quot; + CodeUtil.bytesToString(mGattCharacteristicWrite.getValue()));</span><br><span class="line">        boolean result = false;</span><br><span class="line">        try &#123;</span><br><span class="line">            mGattCharacteristicWrite.setValue(data);</span><br><span class="line">            result = gatt.writeCharacteristic(mGattCharacteristicWrite);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>然后发送数据的回调到BluetoothGattCallback的onCharacteristicWrite</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">     public void onCharacteristicWrite(BluetoothGatt gatt,</span><br><span class="line">                                       BluetoothGattCharacteristic characteristic, int status) &#123;</span><br><span class="line">         super.onCharacteristicWrite(gatt, characteristic, status);</span><br><span class="line">         Log.e(TAG, &quot;onCharacteristicWrite()&quot;);</span><br><span class="line">         if (status != BluetoothGatt.GATT_SUCCESS) &#123;</span><br><span class="line">             Log.e(TAG, &quot;onCharacteristicWrite()检测到不可以写数据    status：&quot; + status);</span><br><span class="line">             return;</span><br><span class="line">         &#125;</span><br><span class="line">         Log.e(TAG, &quot;onCharacteristicWrite()检测到可以去写数据了&quot;);</span><br><span class="line">         Log.d(&quot;写出的数据：&quot;, CodeUtil.bytesToString(characteristic.getValue()));</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><ul><li>接收数据：2种，一种是主动的调用read去接收，一种是被动的通过可通知属性去接收，现在一般是第二种。</li></ul><p>首先先要订阅一下：<br>BluetoothGatt.setCharacteristicNotification(BluetoothGattCharacteristic characteristic，boolean enable) 。enable表示是否接收此BluetoothGattCharacteristic的通知。</p><pre><code>订阅完成之后还需要写一下描述者BluetoothGatt.writeDescriptor(BluetoothGattDescriptor descriptor)，此时便可以接收到ble设备发送过来的数据了。</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 订阅并写描述者  (指定UUID的service下的所有Notification的特征字)</span><br><span class="line"> */</span><br><span class="line">public boolean characteristicNotification(String uuid)&#123;</span><br><span class="line">    BluetoothGatt gatt = mBluetoothGatts.get(deviceAddress);</span><br><span class="line">    if (gatt == null) &#123;</span><br><span class="line">        Log.e(TAG, &quot;BluetoothAdapter not initialized&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    BluetoothGattService service = getService(UUID.fromString(uuid));</span><br><span class="line">    if(service == null)&#123;</span><br><span class="line">        Log.e(TAG, &quot;service is null&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;BluetoothGattCharacteristic&gt; gattCharacteristics = service.getCharacteristics();</span><br><span class="line">    for (int j = 0; j &lt; gattCharacteristics.size(); j++) &#123;</span><br><span class="line">        BluetoothGattCharacteristic chara = gattCharacteristics.get(j);</span><br><span class="line">        //判断是否有可通知的特征字，有则进行订阅写描述者</span><br><span class="line">        if ( (chara.getProperties() &amp; BluetoothGattCharacteristic.PROPERTY_NOTIFY) &gt; 0) &#123;</span><br><span class="line">            boolean b = gatt.setCharacteristicNotification(chara, true);</span><br><span class="line">            BluetoothGattDescriptor descriptor = chara.getDescriptor(DESC_CCC);</span><br><span class="line">            Log.e(TAG, &quot;订阅结果:&quot; + b + &quot;        characteristic:&quot; + chara.getUuid());</span><br><span class="line">            if (descriptor == null) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            byte[] val_set = null;</span><br><span class="line">            val_set = BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE;</span><br><span class="line">            if (!descriptor.setValue(val_set)) &#123;</span><br><span class="line">                Log.e(TAG, &quot;descriptor.setValue失败&quot; );</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            boolean f = gatt.writeDescriptor(descriptor);</span><br><span class="line">            Log.e(TAG, &quot;写描述者结果:&quot; + f + &quot;        characteristic:&quot; + chara.getUuid());</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(150);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ble设备发送过来的数据时，底层会调用BluetoothGattCallback的onCharacteristicChanged方法，我们可以在这里获取到ble设备发送过来的数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">        public void onCharacteristicChanged(BluetoothGatt gatt,</span><br><span class="line">                                            BluetoothGattCharacteristic characteristic) &#123;</span><br><span class="line">            super.onCharacteristicChanged(gatt, characteristic);</span><br><span class="line">            Log.e(TAG, &quot;onCharacteristicChanged()&quot;);</span><br><span class="line">            String address = gatt.getDevice().getAddress();</span><br><span class="line">            long starttime = System.currentTimeMillis();</span><br><span class="line">            byte[] bytes = characteristic.getValue();</span><br><span class="line">            if(dataCallback != null)&#123;</span><br><span class="line">                dataCallback.onGetData(characteristic.getUuid().toString(),bytes);</span><br><span class="line">            &#125;</span><br><span class="line">            StringBuilder sb = new StringBuilder();</span><br><span class="line">            for (int i = 0; i &lt; bytes.length; i++) &#123;</span><br><span class="line">                sb.append(String.format(&quot;%02x&quot;, bytes[i]));</span><br><span class="line">                Log.d(TAG,&quot; time :&quot; + starttime + &quot;     bytes：&quot; + i + &quot;     =&quot; + Integer.toHexString(bytes[i]));</span><br><span class="line">            &#125;</span><br><span class="line">            Log.d(TAG, &quot;出来的数据：&quot; + sb.toString());</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><ul><li><p>断开：通过调用disconnect，这边最好是在等待一会，再去调用close，否则可能从设备端那边数据还没有发送完成，如果直接调用close，可能会造成设备死机问题。</p></li><li><p>发送失败问题：如果发送但是没有回调过来，有可能是蓝牙那边断掉了，我们首先在发送一段数据确认，如果还是没有收到，有可能是设备端处理出现问题，有可能是直接断开了，我们这边就断开连接，然后close，然后在去重新的扫描连接在发送数据。</p></li></ul><p><strong><em>参考连接</em></strong></p><p><a href="https://blog.csdn.net/qingtiantianqing/article/details/52459629" target="_blank" rel="noopener">1.https://blog.csdn.net/qingtiantianqing/article/details/52459629</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; &lt;em&gt;蓝牙知识模块之Android应用&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;一、Android之Ble开发之旅&quot;&gt;&lt;a href=&quot;#一、Android之Ble开发之旅&quot; class=&quot;headerlink&quot; title=&quot;一、Android之Ble开发之旅:&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="Android" scheme="https:mubai.site/categories/Android/"/>
    
    
      <category term="Android" scheme="https:mubai.site/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>蓝牙知识模块之Android坑</title>
    <link href="https:mubai.site/2020-1-4-%E8%93%9D%E7%89%99%E7%9F%A5%E8%AF%86%E6%A8%A1%E5%9D%97%E4%B9%8BAndroid%E5%9D%91/"/>
    <id>https:mubai.site/2020-1-4-蓝牙知识模块之Android坑/</id>
    <published>2020-01-03T16:00:00.000Z</published>
    <updated>2020-05-22T14:29:10.540Z</updated>
    
    <content type="html"><![CDATA[<p> <em>蓝牙知识模块之Android应用</em></p><h3 id="一、Android蓝牙4-0-BLE开发坑总结"><a href="#一、Android蓝牙4-0-BLE开发坑总结" class="headerlink" title="一、Android蓝牙4.0 BLE开发坑总结:"></a>一、Android蓝牙4.0 BLE开发坑总结:</h3><ul><li><p>1.onServicesDiscovered 回调里不能直接执行 write /readDataFromCharacteristic() 或者 enableNotificationOfCharacteristic之类的，而要放到主线程里执行，如 handler.post( … );</p></li><li><p>2.如果发现连接上了，service也discover到了，但是始终不能触发onCharacteristicChanged的，一定要查找如下2个重要原因：<br>1). 一定要gatt.setCharacteristicNotification(characteristic, enable);<br>2). 如果设置了1).却还是发现没有触发，这个时候比较坑爹了，加上对此Characteristic的descriptor做indication Enable就应该可以了;</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for(BluetoothGattDescriptor dp:characteristic().getDescriptors()) &#123;</span><br><span class="line">dp.setValue(BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE);</span><br><span class="line">mBluetoothGatt().writeDescriptor(dp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>3.不同的机型的discoverService到onServiceDiscovered之间的耗时长短不一，这会导致一个问题：如果蓝牙硬件设备支持离线传输，即有记忆功能，连接上之后多久发送之前的数据的问题。如果连接之上立即发送，那么手机端的onServiceDiscovered尚未触发，这样Characteristic的值就获取不了(因为你的service，Characteristic都尚未初始化好)，从而导致失败。</li></ul><p>解决的办法有3个：<br>1）建立一套ACK机制，蓝牙硬件设备不断的广播，直到所有的数据都收到返回的ACK确认才不再广播即可。<br>2）更好的办法是，当手机端onServiceDiscovered触发后，并且service，Characteristic都初始化好后，发送指令给蓝牙硬件设备(即writeCharacteristic)表示手机端已经准备好，可以发送数据给我了，蓝牙硬件设备收到后再发送数据，这样能很好的保证数据不丢失。<br>3) 最好的办法是1）和 2）的结合，即发送准备好的指令，然后让智能硬件发送数据，然后在接收数据的过程中，使用ACK机制确保数据没有任何丢失。</p><ul><li><p>4.Read/Write Characteristic/Descriptor 等都是异步的，即立即返回，等待回调。因此如果Android手机底层自身如果没有做请求的同步顺序执行的话，那么当有很多请求几乎同时进行时，回调顺序是无法保证的。此时就造成错误，这也会导致很多蓝牙4.0不能兼容某些Android的原因，因此需要自己提供一套同步机制，如RequestQueue，来保证request&amp;response 一个接一个高效有序的进行，即下一个request必须等到上一个request的response返回之后再执行。</p></li><li><p>5.Read/Write Characteristic/Descriptor/RemoteRssi()，一般在不同的线程中回调。(除了onDescriptorWrite返回的线程与写入线程为同一个线程???)</p></li></ul><p>BluetoothDevice.conncectGatt(),<br>BluetoothGatt.connect(),<br>BluetoothGatt.disconnect(),<br>BluetoothGatt.discoverServices()</p><p>最好都在主线程，否则会遇到很多意想不到的麻烦。</p><ul><li><p>6.BLE的特征一次读写最大长度20字节。</p></li><li><p>7.Android手机会对连接过的BLE设备的Services进行缓存，若设备升级后Services等有改动，则程序会出现通讯失败。此时就得刷新缓存，反射调用BluetoothGatt类总的refresh()方法。</p></li><li><p>8.startLeScan(UUID[], LeScanCallback)在Android 4.4及以下手机中似乎只支持16位的短UUID，不支持128位。</p></li><li><p>9.connectGatt() 在某些三星手机上只能在UI线程调用。</p></li><li><p>10.Android L 新API扫描设备换为 startScan(List, ScanSettings, ScanCallback)。</p></li><li><p>11.Android M 必须拥有定位权限才能扫描BLE设备。</p></li><li><p>12.一个主设备(例如Android手机)可以同时连接多个从设备(一般为6个，例如智能硬件。超过就连接不上了)，一个从设备只能被一个主设备连接，一旦从设备连接上主设备，就停止广播，断开连接则继续广播。在任何时刻都只能最多一个设备在尝试建立连接。如果同时对多个蓝牙设备发起建立Gatt连接请求。如果前面的设备连接失败了，则后面的设备请求会被永远阻塞住，不会有任何连接回调。所以建议：如果要对多个设备发起连接请求，最好是一个接一个的顺序同步请求管理。</p></li><li><p>13.任何出错，超时，用完就马上调用Gatt.disconnect(), Gatt.close()。</p></li><li><p>14.从bindService 到 onServiceConnected 这个回调花费时间较长， onServiceConnected 这个回调很可能在 MainActivity onResume之后才执行, 所以不要指望onResume里去执行扫描，因为此时serviceConnected 回调都尚未执行</p></li><li><p>15.getBtAdapter().enable()是异步，立即返回，但从 off 到 on 的过程需要一个时间所以只能监听系统broadcast发出的intent里的state</p></li><li><p>16.. onCharacteristicWrite … 等等是指本机写数据指令已经成功发送出去，并且智能硬件已经处理完回应回来了，另外，当智能硬件端要求发送的指令有顺序的话，那么这边不能发送速度过快，即不能在onCharacteristicWrite里立即发送下一条指令。例如OAD/OTA等等，字节必须严格按照image的字节顺序发送出去。</p></li><li><p>17.在writeCharacteristic时，若速度过快（例如在OAD时），会发现发送出去的数据有可能不是你自己真正发出去的，在onCharacteristicWrite里打印出可以确定。</p></li><li><p>18.App端的关于同一个UUID的2个指令不能同时发出去，这样会导致硬件端无法辨识，所以需要串行发送，即等其中一个发送回调成功之后，再进行下一个。</p></li><li><p>19.多次扫描蓝牙，在华为荣耀，魅族M3 NOTE 中有的机型，会发现多次断开–扫描–断开–扫描… 会扫描不到设备，此时需要在断开连接后，不能立即扫描，而是要先停止扫描后，过2秒再扫描才能扫描到设备。</p></li><li><p>20.扫描尽量不要放在主线程进行，可以放入子线程里。不然有些机型会出现 do too many work in main thread.</p></li><li><p>21.BluetoothGatt.disconnect() 之后不能要马上BluetoothGatt.close().建议在 BluetoothGattCallback中收到BluetoothGatt.STATE_DISCONNECTED时才BluetoothGatt.close()</p></li></ul><p>理由：disconnect() 之后调用close()虽然大部分手机调用正常，但存在手机蓝牙连接实际没有断开！！！这个会造成蓝牙资源泄露的问题，甚至蓝牙假死。同时这个最好做一个超时机制来释放连接，避免存在BluetoothGattCallback没有回调的情况。（注：之前有遇到手机在极端情况下没有回调）</p><ul><li>22.蓝牙api调用过程建议采用notify() 和 wait()</li></ul><p>理由：蓝牙的api调用基本都是异步的，但整个过程都是按顺序来的（connect-&gt;discovertServices-&gt;write-&gt;read…..disconnect）,尤其是Characteristic读写非常复杂的时候，一旦出错会让你非常奔溃，甚至会导致蓝牙假死问题！！！所以建议封装异步调用成为同步调用(即用notify和wait),来大幅度地减少出错的可能。</p><ul><li>23.蓝牙 startScan 分了低版本(5.0之下)和高版本(5.0以上)的api，低版本中建议startLeScan不要传递uuid，高版本中建议不要用到onBatchScanResults的方式。</li></ul><p>理由：存在少部分机型底层没有处理好，导致完全扫描不到任何数据。</p><ul><li>24.Android 7.0 以上系统不要在短时间内调用多次 startScan</li></ul><p>理由：Android 7.0系统限制在 30s内最多只能扫描5次，用完之后在30s内是扫不到任何蓝牙的。</p><ul><li>25.BluetoothGatt.requestConnectionPriority() 方法慎用（建议做机型覆盖）</li></ul><p>理由：该方法可以修改蓝牙的连接间隔，加快蓝牙的连接过程（connect 到 discoverServices）,但是在比较旧的机型(类似华为)发现，在连续调用几次后，后面的蓝牙变得连接非常不稳定.</p><ul><li>26.不要持续调用蓝牙扫描</li></ul><p>理由：在部分机型持续一定时间扫描后会发现需要重启蓝牙才能恢复扫描，这个现象在魅族手机上有遇到过；很久之前遇到蓝牙进行重复的扫描，停止扫描两个操作，一定时间后在传说中的国民手机红米上会出现这个bug，而且还必须重启手机才能恢复蓝牙功能。</p><ul><li>27.手机做为中心设备建立连接，但由外设断开蓝牙连接时容易导致外设一定时间内连接不上，所以建立最好不要由外设来进行断开连接。</li></ul><p>理由：这个可能跟蓝牙的一个断开协议有关系，正常来讲中心设备只要收到外设的断开指令后还会回馈给外设一个“收到断开”的回复，外设收到断开回复流程才算完成。但假设中心设备没有回复时，外设会持续等待直到超时断开（一般是10s），意思就是从端设备需要至少10s后才能再次被连接上。（该情况在oppo手机上100%必现）</p><ul><li>28.采用BluetoothManager.getConnectedDevices(int profile)来检查当前蓝牙连接的情况</li></ul><p>理由：可以用来检测蓝牙资源有没有释放干净，因为避免繁琐的异步通信中容易出差。不过此法返回的连接数为空时，也不代表蓝牙的连接完全释放干净。</p><ul><li>29.在小米mix2手机上，黑屏模式，service处于后台，蓝牙也没有调用，持续几分钟后，想调用蓝牙startScan方法，但无法扫描蓝牙或者扫描报异常，并且会有此日志–》 BluetoothLeScanner: start scan is blocked。</li></ul><p>解决方法：<br>方案一：设置-》电量和性能 -》省电忧化 -》应用智能省电-》选择应用-》无限制<br>方案二：android 8.0 出了新的startScan方法，还可用于近场拉活进程(传送门)</p><h3 id="二、蓝牙广播踩到的坑"><a href="#二、蓝牙广播踩到的坑" class="headerlink" title="二、蓝牙广播踩到的坑"></a>二、蓝牙广播踩到的坑</h3><p>使用蓝牙广播可以用来做许多事情，市面上有类似Ibeacon的产品就是基于蓝牙广播类现的，但在android 中还是有很多坑的。</p><ul><li><p>1.android 5.0 以上才支持广播这就算了，在5.0以上部分机器还不支持蓝牙广播，例如：亲儿子nexus 5,甚至华为有些到达7.0系统的手机还不支持。</p></li><li><p>2.存在缓存，许多手机会将上一次广播过的内容再次广播出来一下才广播正常内容</p></li><li><p>3.android 对比ios，普遍机型广播信号强度弱，广播间隔偏少</p></li><li><p>4.存在手机进行多次广播后，蓝牙会自动重启（oppo手机上有遇到此类问题）</p></li><li><p>5.手机端广播出来的蓝牙mac地址不是固定的，每广播一次，变化一次</p></li><li><p>6.AdvertiseSettings.Builder.setTimeout() 调用时注意!!!</p></li></ul><p>理由：Oppo r11,三星 Galaxy On7 （android 7.0)等机型，调用BluetoothLeAdvertiser.startAdvertising() 偶尔返回 ADVERTISE_FAILED_ALREADY_STARTED，偿试多次返回ADVERTISE_FAILED_TOO_MANY_ADVERTISERS,这很明显存在蓝牙广播泄漏问题!!!!</p><p>解决方法：由于该现象只在7.0以上的机型出现，所以本人只针对7.0以上的机型做处理。去调setTimeout()方法，改为用线程延时调用BluetoothLeAdvertiser.stopAdvertising()停止广播</p><p><strong><em>参考连接</em></strong></p><p><a href="https://blog.csdn.net/qingtiantianqing/article/details/52459629" target="_blank" rel="noopener">1.https://blog.csdn.net/qingtiantianqing/article/details/52459629</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; &lt;em&gt;蓝牙知识模块之Android应用&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;一、Android蓝牙4-0-BLE开发坑总结&quot;&gt;&lt;a href=&quot;#一、Android蓝牙4-0-BLE开发坑总结&quot; class=&quot;headerlink&quot; title=&quot;一、Android蓝牙4
      
    
    </summary>
    
      <category term="Android" scheme="https:mubai.site/categories/Android/"/>
    
    
      <category term="Android" scheme="https:mubai.site/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>多线程交替打印数组元素</title>
    <link href="https:mubai.site/2019-12-25-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0%E6%95%B0%E7%BB%84/"/>
    <id>https:mubai.site/2019-12-25-多线程交替打印数组/</id>
    <published>2019-12-24T16:00:00.000Z</published>
    <updated>2020-05-13T13:16:30.398Z</updated>
    
    <content type="html"><![CDATA[<p> <em>多线程交替打印数组元素</em></p><h3 id="通过LockSupport"><a href="#通过LockSupport" class="headerlink" title="通过LockSupport:"></a>通过LockSupport:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private  Thread a, b;</span><br><span class="line"></span><br><span class="line">private void threadPrintArray() &#123;</span><br><span class="line">    int[] arr = new int[]&#123;1, 2, 3, 4, 5, 6&#125;;</span><br><span class="line">    //通过Lock.support，可以阻塞一个线程，唤起一个线程</span><br><span class="line">    a = new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            for (int i : arr) &#123;</span><br><span class="line">                System.out.println(&quot;a：&quot; + i);</span><br><span class="line">                LockSupport.unpark(b);//先唤起b线程</span><br><span class="line">                LockSupport.park();//阻塞自己</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    b = new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            for (int i : arr) &#123;</span><br><span class="line">                LockSupport.park();//先阻塞自己，防止先打印b线程的值</span><br><span class="line">                System.out.println(&quot;b：&quot; + i);</span><br><span class="line">                LockSupport.unpark(a);//唤起a线程</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    a.start();</span><br><span class="line">    b.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过Synchronized-wait-notify"><a href="#通过Synchronized-wait-notify" class="headerlink" title="通过Synchronized+wait/notify"></a>通过Synchronized+wait/notify</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">private  Thread a, b;</span><br><span class="line">private void threadPrintArray() &#123;</span><br><span class="line">int[] arr = new int[]&#123;1, 2, 3, 4, 5, 6&#125;;</span><br><span class="line">//通过sync加锁 ，然后通过wait和notify来控制阻塞和唤起</span><br><span class="line">a = new Thread(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        synchronized (arr) &#123;</span><br><span class="line">            for (int i : arr) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println(&quot;a：&quot; + i);</span><br><span class="line">                    arr.notify();//先去唤起其他线程</span><br><span class="line">                    arr.wait();//再去对自己阻塞</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">b = new Thread(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        synchronized (arr) &#123;</span><br><span class="line">            for (int i : arr) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println(&quot;b：&quot; + i);</span><br><span class="line">                    arr.notify();//先去唤起其他线程</span><br><span class="line">                    arr.wait();//再去对自己阻塞</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">a.start();</span><br><span class="line">b.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过ReentrantLock"><a href="#通过ReentrantLock" class="headerlink" title="通过ReentrantLock"></a>通过ReentrantLock</h3><ul><li>单Condition控制(类似Sync+wait/notify)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">private ReentrantLock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">private Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">private  Thread a, b;</span><br><span class="line"></span><br><span class="line">private void threadPrintArray() &#123;</span><br><span class="line">int[] arr = new int[]&#123;1, 2, 3, 4, 5, 6&#125;;</span><br><span class="line">a = new Thread(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            for (int i : arr) &#123;</span><br><span class="line">                System.out.println(&quot;a：&quot; + i);</span><br><span class="line">                condition.singal();//唤起其他线程，即b线程</span><br><span class="line">                condition.await();//阻塞a线程</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">b = new Thread(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            for (int i : arr) &#123;</span><br><span class="line">                System.out.println(&quot;b：&quot; + i);</span><br><span class="line">                condition.signal();//唤起其他线程，即a线程</span><br><span class="line">                condition.await();//阻塞b线程</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">a.start();</span><br><span class="line">b.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>多Condition来控制</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">private ReentrantLock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">private Condition aCondition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">private Condition bCondition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">private  Thread a, b;</span><br><span class="line"></span><br><span class="line">private void threadPrintArray() &#123;</span><br><span class="line">int[] arr = new int[]&#123;1, 2, 3, 4, 5, 6&#125;;</span><br><span class="line">a = new Thread(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            for (int i : arr) &#123;</span><br><span class="line">                System.out.println(&quot;a：&quot; + i);</span><br><span class="line">                bCondition.signal();//唤起b线程</span><br><span class="line">                aCondition.await();//阻塞a线程</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">b = new Thread(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            for (int i : arr) &#123;</span><br><span class="line">                System.out.println(&quot;b：&quot; + i);</span><br><span class="line">                aCondition.signal();//唤起a线程</span><br><span class="line">                bCondition.await();//阻塞b线程</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">a.start();</span><br><span class="line">b.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过原子类-自旋实现"><a href="#通过原子类-自旋实现" class="headerlink" title="通过原子类+自旋实现"></a>通过原子类+自旋实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">AtomicInteger threadNo = new AtomicInteger(1);</span><br><span class="line"></span><br><span class="line">private  Thread a, b;</span><br><span class="line"></span><br><span class="line">private void threadPrintArray() &#123;</span><br><span class="line"></span><br><span class="line">int[] arr = new int[]&#123;1, 2, 3, 4, 5, 6&#125;;</span><br><span class="line"></span><br><span class="line">a = new Thread(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int i : arr) &#123;</span><br><span class="line">        while(threadNo.get() != 1)&#123;&#125;//如果等于1，即不是a线程的 自旋</span><br><span class="line">        System.out.println(&quot;a：&quot; + i);</span><br><span class="line">        threadNo.get.set(2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">b = new Thread(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int i : arr) &#123;</span><br><span class="line">        while(threadNo.get() != 2)&#123;&#125;//如果等于2，即不是b线程的 自旋</span><br><span class="line">            System.out.println(&quot;b：&quot; + i);</span><br><span class="line">            threadNo.get.set(1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">a.start();</span><br><span class="line">b.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; &lt;em&gt;多线程交替打印数组元素&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;通过LockSupport&quot;&gt;&lt;a href=&quot;#通过LockSupport&quot; class=&quot;headerlink&quot; title=&quot;通过LockSupport:&quot;&gt;&lt;/a&gt;通过LockSupport:&lt;/h
      
    
    </summary>
    
      <category term="Android" scheme="https:mubai.site/categories/Android/"/>
    
    
      <category term="Android" scheme="https:mubai.site/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>蓝牙知识模块之简介</title>
    <link href="https:mubai.site/2019-12-30-%E8%93%9D%E7%89%99%E7%9F%A5%E8%AF%86%E6%A8%A1%E5%9D%97%E4%B9%8B%E7%AE%80%E4%BB%8B/"/>
    <id>https:mubai.site/2019-12-30-蓝牙知识模块之简介/</id>
    <published>2019-12-24T16:00:00.000Z</published>
    <updated>2020-05-22T13:56:48.322Z</updated>
    
    <content type="html"><![CDATA[<p> <em>蓝牙相关总结1</em></p><h3 id="一、蓝牙版本和传输距离"><a href="#一、蓝牙版本和传输距离" class="headerlink" title="一、蓝牙版本和传输距离:"></a>一、蓝牙版本和传输距离:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">蓝牙版本 发布时间     最大传输速度     传输距离</span><br><span class="line"></span><br><span class="line">蓝牙5.1     2019年      48Mbit/s       300m</span><br><span class="line"></span><br><span class="line">蓝牙5.0     2016年      48Mbit/s       300m       </span><br><span class="line"></span><br><span class="line">蓝牙4.2     2014年      24Mbit/s       50m</span><br><span class="line"></span><br><span class="line">蓝牙4.1     2013年      24Mbit/s       50m</span><br><span class="line"></span><br><span class="line">蓝牙4.0     2010年      24Mbit/s       50m</span><br><span class="line"></span><br><span class="line">蓝牙3.0+HS  2009年      24Mbit/s       10m</span><br><span class="line"></span><br><span class="line">蓝牙2.1+EDR 2007年      3Mbit/s        10m</span><br><span class="line"></span><br><span class="line">蓝牙2.0+EDR 2004年      2.1Mbit/s      10m</span><br><span class="line"></span><br><span class="line">蓝牙1.2     2003年      1Mbit/s        10m</span><br><span class="line"></span><br><span class="line">蓝牙1.1     2002年      810kbit/s      10m</span><br><span class="line"></span><br><span class="line">蓝牙1.0     1998年      723.1kbit/s    10m</span><br></pre></td></tr></table></figure><h4 id="第一代蓝牙：关于短距离通讯早期的探索"><a href="#第一代蓝牙：关于短距离通讯早期的探索" class="headerlink" title="第一代蓝牙：关于短距离通讯早期的探索"></a>第一代蓝牙：关于短距离通讯早期的探索</h4><h5 id="1999-年：蓝牙-1-0"><a href="#1999-年：蓝牙-1-0" class="headerlink" title="1999 年：蓝牙 1.0"></a>1999 年：蓝牙 1.0</h5><p>早期的蓝牙 1.0 A 和 1.0B 版存在多个问题，有多家厂商指出他们的产品互不兼容。同时，在两个设备「链接」（Handshaking）的过程中，蓝牙硬件的地址（BD_ADDR）会被发送出去，在协议的层面上不能做到匿名，造成泄漏数据的危险。令一些用户却步。 </p><h5 id="2001-年：蓝牙-1-1"><a href="#2001-年：蓝牙-1-1" class="headerlink" title="2001 年：蓝牙 1.1"></a>2001 年：蓝牙 1.1</h5><p>蓝牙 1.1 版正式列入 IEEE 802.15.1 标准，该标准定义了物理层（PHY）和媒体访问控制（MAC）规范，用于设备间的无线连接，传输率为 0.7Mbps。但因为是早期设计，容易受到同频率之间产品干扰，影响通讯质量。 </p><h5 id="2003-年：蓝牙-1-2"><a href="#2003-年：蓝牙-1-2" class="headerlink" title="2003 年：蓝牙 1.2"></a>2003 年：蓝牙 1.2</h5><p>蓝牙 1.2 版可以向下兼容1.1版,针对 1.0 版本暴露出的安全性问题，完善了匿名方式，新增屏蔽设备的硬件地址（BD_ADDR）功能，保护用户免受身份嗅探攻击和跟踪。此外，还增加了四项新功能：  </p><p>· AFH（Adaptive Frequency Hopping）适应性跳频技术，减少了蓝牙产品与其它无线通讯装置之间所产生的干扰问题； </p><p>· eSCO（Extended Synchronous Connection-Oriented links）延伸同步连结导向信道技术，用于提供 QoS 的音频传输，进一步满足高阶语音与音频产品的需求； · Faster Connection 快速连接功能，可以缩短重新搜索与再连接的时间，使连接过程更为稳定快速；</p><p> · 支持 Stereo 音效的传输要求，但只能以单工方式工作。 </p><h4 id="第二代蓝牙：发力传输速率的-EDR-时代"><a href="#第二代蓝牙：发力传输速率的-EDR-时代" class="headerlink" title="第二代蓝牙：发力传输速率的 EDR 时代"></a>第二代蓝牙：发力传输速率的 EDR 时代</h4><h5 id="2004-年：蓝牙-2-0"><a href="#2004-年：蓝牙-2-0" class="headerlink" title="2004 年：蓝牙 2.0"></a>2004 年：蓝牙 2.0</h5><p>蓝牙 2.0 是 1.2 版本的改良版，新增的 EDR（Enhanced Data Rate）技术通过提高多任务处理和多种蓝牙设备同时运行的能力，使得蓝牙设备的传输率可达 3Mbps。 </p><p>蓝牙 2.0 支持双工模式：可以一边进行语音通讯，一边传输文档/高质素图片。 同时， EDR 技术通过减少工作负债循环来降低功耗，由于带宽的增加，蓝牙 2.0 增加了连接设备的数量。 </p><h5 id="2007-年：蓝牙-2-1"><a href="#2007-年：蓝牙-2-1" class="headerlink" title="2007 年：蓝牙 2.1"></a>2007 年：蓝牙 2.1</h5><p>蓝牙 2.1 新增了 Sniff Subrating 省电功能，将设备间相互确认的讯号发送时间间隔从旧版的 0.1 秒延长到 0.5 秒左右，从而让蓝牙芯片的工作负载大幅降低。 </p><p>另外，新增 SSP 简易安全配对功能，改善了蓝牙设备的配对体验，同时提升了使用和安全强度。 支持 NFC 近场通信，只要将两个内置有 NFC 芯片的蓝牙设备相互靠近，配对密码将通过 NFC 进行传输，无需手动输入。 </p><h4 id="第三代蓝牙：High-Speed，传输速率高达24Mbps"><a href="#第三代蓝牙：High-Speed，传输速率高达24Mbps" class="headerlink" title="第三代蓝牙：High Speed，传输速率高达24Mbps"></a>第三代蓝牙：High Speed，传输速率高达24Mbps</h4><p>2009 年：蓝牙 3.0 蓝牙 3.0 新增了可选技术 High Speed，High Speed 可以使蓝牙调用 802.11 WiFi 用于实现高速数据传输，传输率高达 24Mbps，是蓝牙 2.0 的 8 倍，轻松实现录像机至高清电视、PC 至 PMP、UMPC 至打印机之间的资料传输。 </p><p>蓝牙 3.0 的核心是 AMP（Generic Alternate MAC/PHY），这是一种全新的交替射频技术，允许蓝牙协议栈针对任一任务动态地选择正确射频。 </p><p>功耗方面，蓝牙 3.0 引入了 EPC 增强电源控制技术，再辅以 802.11，实际空闲功耗明显降低。 </p><p>此外，新的规范还加入 UCD 单向广播无连接数据技术，提高了蓝牙设备的相应能力。 </p><h4 id="第四代蓝牙：主推「-Low-Energy」低功耗"><a href="#第四代蓝牙：主推「-Low-Energy」低功耗" class="headerlink" title="第四代蓝牙：主推「 Low Energy」低功耗"></a>第四代蓝牙：主推「 Low Energy」低功耗</h4><h5 id="2010-年：蓝牙-4-0"><a href="#2010-年：蓝牙-4-0" class="headerlink" title="2010 年：蓝牙 4.0"></a>2010 年：蓝牙 4.0</h5><p>2010年7月7日，蓝牙技术联盟推出了蓝牙4.0规范。其最重要的特性是支持省电。蓝牙 4.0 是迄今为止第一个蓝牙综合协议规范，将三种规格集成在一起。还提出了低功耗蓝牙、传统蓝牙和高速蓝牙三种模式： </p><p>高速蓝牙主攻数据交换与传输；传统蓝牙则以信息沟通、设备连接为重点；「低功耗蓝牙」以不需占用太多带宽的设备连接为主，功耗较老版本降低了 90%。 </p><p>BLE 前身是 NOKIA 开发的 Wibree 技术，本是作为一项专为移动设备开发的极低功耗的移动无线通信技术，在被 SIG 接纳并规范化之后重命名为 Bluetooth Low Energy（后简称低功耗蓝牙）。这三种协议规范还能够互相组合搭配、从而实现更广泛的应用模式。 </p><p>蓝牙 4.0 的芯片模式分为 Single mode 与 Dual mode。Single mode 只能与蓝牙 4.0 互相传输无法向下与 3.0/2.1/2.0 版本兼容；Dual mode 可以向下兼容 3.0/2.1/2.0 版本。前者应用于使用纽扣电池的传感器设备，例如对功耗要求较高的心率检测器和温度计；后者应用于传统蓝牙设备，同时兼顾低功耗的需求。 </p><p>此外，蓝牙 4.0 还把蓝牙的传输距离提升到100米以上（低功耗模式条件下）。拥有更快的响应速度，最短可在 3 毫秒内完成连接设置并开始传输数据。更安全的技术，使用 AES-128 CCM 加密算法进行数据包加密和认证。 </p><h5 id="2013-年：蓝牙-4-1"><a href="#2013-年：蓝牙-4-1" class="headerlink" title="2013 年：蓝牙 4.1"></a>2013 年：蓝牙 4.1</h5><p>蓝牙 4.1 在传输速度和传输范围上变化很小，但在软件方面有着明显的改进。此次更新目的是为了让 Bluetooth Smart 技术最终成为物联网（Internet of Things）发展的核心动力。 </p><p>支持与 LTE 无缝协作。当蓝牙与 LTE 无线电信号同时传输数据时，那么蓝牙 4.1 可以自动协调两者的传输信息，以确保协同传输，降低相互干扰。 </p><p>允许开发人员和制造商自定义蓝牙 4.1 设备的重新连接间隔，为开发人员提供了更高的灵活性和掌控度。 </p><p>支持云同步。蓝牙 4.1 加入了专用的 IPv6 通道，蓝牙 4.1 设备只需要连接到可以联网的设备（如手机），就可以通过 IPv6 与云端的数据进行同步，满足物联网的应用需求。 </p><p>支持扩展设备与中心设备角色互换。支持蓝牙 4.1 标准的耳机、手表、键鼠，可以不用通过 PC、平板、手机等数据枢纽，实现自主收发数据。例如智能手表和计步器可以绕过智能手机，直接实现对话。 </p><h5 id="2014-年：蓝牙-4-2"><a href="#2014-年：蓝牙-4-2" class="headerlink" title="2014 年：蓝牙 4.2"></a>2014 年：蓝牙 4.2</h5><p>蓝牙 4.2 的传输速度更加快速，比上代提高了 2.5 倍，因为蓝牙智能（Bluetooth Smart）数据包的容量提高，其可容纳的数据量相当于此前的10倍左右。 </p><p>改善了传输速率和隐私保护程度，蓝牙信号想要连接或者追踪用户设备，必须经过用户许可。用户可以放心使用可穿戴设备而不用担心被跟踪。 </p><p>支持 6LoWPAN，6LoWPAN 是一种基于 IPv6 的低速无线个域网标准。蓝牙 4.2 设备可以直接通过 IPv6 和 6LoWPAN 接入互联网。这一技术允许多个蓝牙设备通过一个终端接入互联网或者局域网，这样，大部分智能家居产品可以抛弃相对复杂的WiFi 连接，改用蓝牙传输，让个人传感器和家庭间的互联更加便捷快速。 </p><h4 id="第五代蓝牙：开启物联网时代大门"><a href="#第五代蓝牙：开启物联网时代大门" class="headerlink" title="第五代蓝牙：开启物联网时代大门"></a>第五代蓝牙：开启物联网时代大门</h4><h4 id="2016-年：蓝牙-5-0"><a href="#2016-年：蓝牙-5-0" class="headerlink" title="2016 年：蓝牙 5.0"></a>2016 年：蓝牙 5.0</h4><p>蓝牙 5.0 在低功耗模式下具备更快更远的传输能力，传输速率是蓝牙 4.2 的两倍（速度上限为 2Mbps），有效传输距离是蓝牙 4.2 的四倍（理论上可达 300 米），数据包容量是蓝牙 4.2 的八倍。 </p><p>支持室内定位导航功能，结合 WiFi 可以实现精度小于 1 米的室内定位。 </p><p>针对 IoT 物联网进行底层优化，力求以更低的功耗和更高的性能为智能家居服务。 </p><p>Mesh 网状网络：实现物联网的关键钥匙 </p><p>Mesh 网状网络是一项独立研发的网络技术，它能够将蓝牙设备作为信号中继站，将数据覆盖到非常大的物理区域，兼容蓝牙 4 和 5 系列的协议。 </p><p>传统的蓝牙连接是通过一台设备到另一台设备的「配对」实现的，建立「一对一」或「一对多」的微型网络关系。 而 Mesh 网络能够使设备实现「多对多」的关系。Mesh 网络中每个设备节点都能发送和接收信息，只要有一个设备连上网关，信息就能够在节点之间被中继，从而让消息传输至比无线电波正常传输距离更远的位置。 </p><p>这样，Mesh 网络就可以分布在制造工厂、办公楼、购物中心、商业园区以及更广的场景中，为照明设备、工业自动化设备、安防摄像机、烟雾探测器和环境传感器提供更稳定的控制方案。 </p><h5 id="2019年：蓝牙5-1"><a href="#2019年：蓝牙5-1" class="headerlink" title="2019年：蓝牙5.1"></a>2019年：蓝牙5.1</h5><p>蓝牙 5.1 技术规范利用测向功能检测蓝牙信号方向，进而提升位置服务。借助蓝牙测向功能，开发者能够将可探测设备方向及实现厘米级定位精度的产品推向市场。 Bluetooth local services用RSSI来测量两个设备的距离，在RTLS和IPS场景中，用三遍测距和加上测向技术就可以达到厘米级别的定位，测向技术依赖两种天线阵列技术来决定Blooth 的signal：Angle of arrival（AOA）技术和Angle of departure（AOD）技术</p><ul><li><p>1、Direction Finding之AOA技术：<br>当传输信号穿过接收机的天线阵列的时候，接收机的天线阵列从不同的角度和方向接受到这个传输信号，每个方向可以看作是这个传输信号的矢量相位，接受机会在天线阵列中提取活跃的天线的IQ样本，根据IQ样本，接收机可以算出信号的方向。AOA测向可以应用在RTLS、item finding、POL等 Local Services之后。 </p></li><li><p>2、Direction Finding之AOD技术：<br>AOD测向一般用在IPS场景中用来寻路导航，定位器locator采用天线阵列，接收机是一般的手机就可以（当然要有相应的app），只需一个天线就可以。当信号从当locator的多个信号发出时，这些信号会穿越手机的天线，手机会提取IQ样本，根据IQ样本，就可以计算出信号的方向。</p></li></ul><h3 id="二、蓝牙4-0和低功耗蓝牙"><a href="#二、蓝牙4-0和低功耗蓝牙" class="headerlink" title="二、蓝牙4.0和低功耗蓝牙"></a>二、蓝牙4.0和低功耗蓝牙</h3><p>相信一部分人在了解蓝牙的时候都有过这样的一个疑问，蓝牙4.0和低功耗蓝牙是一回事吗？这个说法是错误的，是对蓝牙4.0的绝对错误的认识。蓝牙4.0标准包括两个蓝牙标准：一个是双模标准，它包括传统蓝牙（或称经典蓝牙）、高速蓝牙和低功耗蓝牙部分；另一个就是单独的低功耗标准。<br>传统蓝牙（或称经典蓝牙）可以用于数据量较大的传输，如语音、音乐等，而低功耗蓝牙主要应用于实时性要求比较高但数据速率相对较低的产品中，如传感设备的数据发送和遥控装置设备等。<br>所以蓝牙4.0是集成了传统蓝牙、高速蓝牙和低功耗蓝牙三个标准的，并不只是低功耗蓝牙。</p><p>关于低功耗蓝牙</p><p>低功耗蓝牙，也可称其为智能蓝牙，是一种智能、低功耗的无线技术。这项技术通过缩小智能设备的尺寸、降低其价格与复杂性，进一步提高了其智能化程度。</p><p>低功耗蓝牙一开始是蓝牙4.0核心规格的一部分，最初的目标是提供功耗最低的无线标准，并且专门在低成本、低带宽与低功耗等方面进行了优化。目前，低功耗蓝牙技术已被广泛使用，并且只需一粒纽扣电池就能运行很长时间。</p><h3 id="三、蓝牙5-0的实际传输距离"><a href="#三、蓝牙5-0的实际传输距离" class="headerlink" title="三、蓝牙5.0的实际传输距离"></a>三、蓝牙5.0的实际传输距离</h3><p>蓝牙5无线电链路的实际传输距离是多少？经过测试我们得出结论使用新125 kbps编码PHY（PHYsical）格式的两个低功耗SimpleLink™蓝牙CC2640R2F无线微控制器（MCU）LaunchPad™开发套件之间的连接距离在室外可达1.6千米，这数字非常令人印象深刻。那么，为什么在CC2640R2F无线MCU数据表中的传输距离不规定为1.6千米？ </p><p>但是，在将RF设备带进现实生活中后，“最终结果”的连接距离会发生明显变化，其中许多反射、障碍物和干扰RF的活动都会成为两个随机变量，这将决定两个设备连接的位置之间是否可以建立连接。所以两个设备的实际连接距离取决于很多因素，如果在BLE蓝牙模块中加入外接天线，设备的连接范围将会扩大。</p><p>如上所述，虽然实际的连接距离将根据环境和应用而变化，但是从测试中可以看出，蓝牙5肯定比蓝牙4.x系列显著地增长距离，这打开了用于新应用的可能性。 </p><p>最后，蓝牙无线通信技术的功耗仍然是大多数低功耗蓝牙应用的关键。在各种环境应用测试中使用的发射功率水平仅为+ 5dBm，在TX中消耗大约9mA的峰值功率，在RX中消耗6mA的峰值功率。加上CC2640R2F器件具有非常低的待机电流消耗，此特性将可以实现卓越的室内和室外覆盖的蓝牙低功耗应用，可以使用纽扣大小般的电池运行很多年。</p><p><strong><em>参考连接</em></strong></p><p><a href="https://www.minewtech.com/news/industry-2019-09-02-01.html" target="_blank" rel="noopener">1.https://www.minewtech.com/news/industry-2019-09-02-01.html</a><br><a href="https://www.sohu.com/a/206352458_404276" target="_blank" rel="noopener">2.https://www.sohu.com/a/206352458_404276</a><br><a href="http://www.openpcba.com/web/contents/get?id=2629&amp;tid=9" target="_blank" rel="noopener">3.http://www.openpcba.com/web/contents/get?id=2629&amp;tid=9</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; &lt;em&gt;蓝牙相关总结1&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;一、蓝牙版本和传输距离&quot;&gt;&lt;a href=&quot;#一、蓝牙版本和传输距离&quot; class=&quot;headerlink&quot; title=&quot;一、蓝牙版本和传输距离:&quot;&gt;&lt;/a&gt;一、蓝牙版本和传输距离:&lt;/h3&gt;&lt;figure cl
      
    
    </summary>
    
      <category term="Android" scheme="https:mubai.site/categories/Android/"/>
    
    
      <category term="Android" scheme="https:mubai.site/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>沉浸式状态栏</title>
    <link href="https:mubai.site/2019-12-20-%E6%B2%89%E6%B5%B8%E5%BC%8F%E7%8A%B6%E6%80%81%E6%A0%8F/"/>
    <id>https:mubai.site/2019-12-20-沉浸式状态栏/</id>
    <published>2019-12-19T16:00:00.000Z</published>
    <updated>2020-05-09T15:03:58.286Z</updated>
    
    <content type="html"><![CDATA[<p> <em>沉浸式状态栏怎么搞</em></p><h3 id="实现沉浸式状态栏主要跟以下四个Api相关"><a href="#实现沉浸式状态栏主要跟以下四个Api相关" class="headerlink" title="实现沉浸式状态栏主要跟以下四个Api相关:"></a>实现沉浸式状态栏主要跟以下四个Api相关:</h3><ul><li><p>View#setSystemUiVisibility()</p></li><li><p>Window#addFlags()</p></li><li><p>View#setFitsSystemWindows</p></li><li><p>Window#setStatusBarColor()</p></li></ul><h4 id="View-setSystemUiVisibility-及其各种Flags"><a href="#View-setSystemUiVisibility-及其各种Flags" class="headerlink" title="View#setSystemUiVisibility()及其各种Flags"></a>View#setSystemUiVisibility()及其各种Flags</h4><p>首先setSystemUiVisibility()这个方法就是设置状态栏或者导航栏的各种属性的。</p><ul><li><p>View.SYSTEM_UI_FLAG_FULLSCREEN:<br>  视图全屏并隐藏状态栏，当用户交互时（如下滑状态栏）会恢复隐藏的状态栏（例子：电子书阅读）缺点：进入Activity会产生一个从非全屏到全屏的闪动效果</p></li><li><p>View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY：<br>  粘性沉浸模式，需要和SYSTEM_UI_FLAG_FULLSCREEN或者SYSTEM_UI_FLAG_HIDE_NAVIGATION联用，当使用View.setSystemUiVisibility(View.SYSTEM_UI_FLAG_FULLSCREEN|View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY)联用时视图全屏，当用户产生交互时（如下滑状态栏）不会恢复状态栏，只会以半透明的方式覆盖在视图上面并在一定时间内自动消失</p></li><li><p>View.SYSTEM_UI_FLAG_IMMERSIVE：<br>  沉浸模式，只能和SYSTEM_UI_FLAG_FULLSCREEN联用，效果和View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY一样，目前已被后者替代</p></li><li><p>View.SYSTEM_UI_FLAG_LOW_PROFILE:<br>  低配模式，会隐藏一些不重要的状态栏和导航栏的图标</p></li><li><p>View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN：<br>  视图全屏且不会产生闪动，状态栏会覆盖在视图上面</p></li><li><p>View.SYSTEM_UI_FLAG_LAYOUT_STABLE：<br>  使视图稳定，当使用fitSystemWindows（）（下面会单独介绍这个方法）需要视图稳定，一般和View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN联用</p></li><li><p>View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR:<br>Android6.0系统以上增加的属性，设置了这个属性，状态栏会以与状态栏背景颜色兼容的模式绘制。什么意思呢？就是说如果当前的状态栏颜色是浅色，那么就有可能造成状态栏上的图标看不清了，但是如果你设置这个属性以后，状态栏的图标就会以深色绘制，这样就没有什么UI上的问题了。</p></li></ul><h4 id="Window-addFlags-及其各种Flags"><a href="#Window-addFlags-及其各种Flags" class="headerlink" title="Window.addFlags()及其各种Flags"></a>Window.addFlags()及其各种Flags</h4><p>WindowManager.LayoutParams相关属性：</p><ul><li><p>FLAG_TRANSLUCENT_STATUS:<br>Android4.4系统增加的属性，它会使状态栏透明透明并且自动执行View.SYSTEM_UI_FLAG_LAYOUT_STABLE和View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN</p></li><li><p>FLAG_FULLSCREEN:<br>视图全屏并隐藏状态栏，效果相当于View.SYSTEM_UI_FLAG_FULLSCREEN+View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY，并且视图稳定（不会因为系统控件的变化（如输入法），而重新布局）</p></li><li><p>FLAG_FORCE_NOT_FULLSCREEN：<br>重写了FLAG_FULLSCREEN并强制显示状态栏（没有啥卵用）</p></li><li><p>FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS：<br>Android5.0系统以上支持，如果设置了该属性，系统栏（状态栏和导航栏）将以透明背景绘制，并且该窗口中的相应区域将填充setStatusBar（）和setNavigationBarColor（）中设置的颜色</p></li></ul><h4 id="View-setFitsSystemWindows"><a href="#View-setFitsSystemWindows" class="headerlink" title="View#setFitsSystemWindows"></a>View#setFitsSystemWindows</h4><p>此方法只有当设置SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN或者SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION才有有效，当窗口发生变化时，View需要调整自身内容以适应窗口的变化，你可以理解为当和SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN一起联用的时候，是给View加了个bottomTop属性，宽度填充视图，高度就是状态栏的高度；当和SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION一起联用的时候，是给View加了个bottomBottom属性，宽度填充视图，高度就是导航栏的高度，建议给布局的顶层ViewGroup使用</p><h4 id="Window-setStatusBarColor"><a href="#Window-setStatusBarColor" class="headerlink" title="Window#setStatusBarColor()"></a>Window#setStatusBarColor()</h4><p>Android5.0系统及以上开始支持，设置状态栏的颜色，为了使这个状态有效必须要设置FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS而且不能设置FLAG_TRANSLUCENT_STATUS</p><h3 id="实现沉浸式状态栏的具体套路"><a href="#实现沉浸式状态栏的具体套路" class="headerlink" title="实现沉浸式状态栏的具体套路"></a>实现沉浸式状态栏的具体套路</h3><p>实现沉浸式状态栏分为三个阶段，</p><ul><li>Android4.4~Android5.0以下;</li><li>Android5.0~Android6.0以下；</li><li>Android6.0以上；</li></ul><h4 id="Android4-4-Android5-0阶段以下："><a href="#Android4-4-Android5-0阶段以下：" class="headerlink" title="Android4.4~Android5.0阶段以下："></a>Android4.4~Android5.0阶段以下：</h4><p>Android真正可以实现沉浸式状态栏是从4.4开始的，因为4.4系统加入了一个重要的属性Window.LayoutParams.FLAG_TRANSLUCENT_STATUS，这个属性能干嘛，前面已经说过了，下面直接开搞。<br>首先，沉浸式状态栏一般有两种情况，一种是背景是一张图片，一种是颜色跟标题栏一致的</p><ul><li>背景是一张图片的情况：非常非常好实现，一行代码直接搞定</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">activity.getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);</span><br></pre></td></tr></table></figure><p>FLAG_TRANSLUCENT_STATUS这个属性会让状态栏以白色绘制，同时还会执行SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN和SYSTEM_UI_FLAG_LAYOUT_STABLE这样就会让状态栏浮在图片的上面，这样就形成了沉浸式的效果</p><ul><li>颜色跟标题栏一致的情况</li></ul><p>这种情况在4.4~5.0以下这个阶段实现起来就稍微复杂了一点，因为这个阶段还没有执行setStatusBarColor（）这个方法，因此这个阶段实现的套路是，先制造一个假的View背景颜色跟标题栏的颜色一致，高度跟状态栏的高度一致，添加到顶层DecorView上面，然后让Android的最顶层的内容布局调用setFitsSystemWindows空出来状态栏的高度，最后调用FLAG_TRANSLUCENT_STATUS这个属性即可，让状态栏透明并浮在假View上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">View statusView = new View(activity);</span><br><span class="line">ViewGroup.LayoutParams statusViewLayoutParams = new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, getStatusBarHeight(activity));</span><br><span class="line">ViewGroup decorView = (ViewGroup) activity.getWindow().getDecorView();</span><br><span class="line">decorView.addView(statusView, statusViewLayoutParams);</span><br><span class="line">ViewGroup rootView = decorView.findViewById(Window.ID_ANDROID_CONTENT);</span><br><span class="line">if (rootView != null) &#123;</span><br><span class="line">    rootView.setFitsSystemWindows(true);</span><br><span class="line">&#125;</span><br><span class="line">activity.getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);</span><br></pre></td></tr></table></figure><p>注意：从两张效果图的图片可以看出，沉浸式状态在这一阶段的表现还不是太好，上面会有一层黑色的半透明浮层，但是也基本可以实现了沉浸式。</p><h4 id="Android5-0-Android6-0以下"><a href="#Android5-0-Android6-0以下" class="headerlink" title="Android5.0~Android6.0以下"></a>Android5.0~Android6.0以下</h4><p>这一阶段Android系统为我们增加了一个非常重要的API，Window#setStatusBarColor()，关于它的用法前面已经有所介绍，这里不再赘述，以及一个配合这个api使用的属性FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS，直接开搞</p><ul><li>背景是一张图的情况</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">activity.getWindow().addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);</span><br><span class="line">activity.getWindow().setStatusBarColor(Color.TRANSPARENT);</span><br><span class="line">activity.getWindow().clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);</span><br><span class="line">activity.getWindow().getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN);</span><br></pre></td></tr></table></figure><p>这里简单解释一下，我们把状态栏的颜色设置成透明，同时让状态栏浮在视图上面且保持稳定，这样图片就会顶到视图的顶部，因此就实现了沉浸式的效果，代码很简单，万一看不懂就翻翻上面对各种api的介绍</p><ul><li><p>颜色状态栏</p><ul><li><p>直接给状态栏设置对应的颜色</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">activity.getWindow().addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);</span><br><span class="line">       activity.getWindow().clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);</span><br><span class="line">activity.getWindow().setStatusBarColor(color);</span><br></pre></td></tr></table></figure></li><li><p>给状态栏设置透明色并让状态栏浮在视图顶层，配合setFitsSystemWindows（）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">activity.getWindow().getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_STABLE);</span><br><span class="line">activity.getWindow().addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);     activity.getWindow().clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);</span><br><span class="line">activity.getWindow().setStatusBarColor(Color.TRANSPARENT);</span><br><span class="line">toolBar.setFitsSystemWindows(true);//这里根据自己的布局情况</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="Android6-0及以上"><a href="#Android6-0及以上" class="headerlink" title="Android6.0及以上"></a>Android6.0及以上</h4><p>之所以又分了这一个阶段，是因为我们在5.0~6.0阶段发现了一个小问题，就是当我们要给状态栏设置的颜色是白色或者浅色的时候，因为默认的状态上图标的颜色是白色就会造成看不清的现象</p><p>为了避免这种情况，Android系统在6.0的时候增加了一个属性SYSTEM_UI_FLAG_LIGHT_STATUS_BAR，此前已经介绍过这个属性，这里不再赘述，使用了它以后，状态栏上的图标文字就会默认使用黑色绘制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">activity.getWindow().addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);</span><br><span class="line">activity.getWindow().clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);</span><br><span class="line">activity.getWindow().setStatusBarColor(color);</span><br><span class="line">if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123;           activity.getWindow().getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ps:小米和魅族系统在Android5.0修改自家系统的源码，因此他们在5.0的时候就提供这个API，也就是说小米和魅族Android5.0系统的手机就支持了浅色主题模式。</p><h4 id="沿着别人走过的路，跟上去发现不一样的风景"><a href="#沿着别人走过的路，跟上去发现不一样的风景" class="headerlink" title="沿着别人走过的路，跟上去发现不一样的风景"></a>沿着别人走过的路，跟上去发现不一样的风景</h4><p>参考链接：</p><ul><li>转载自：<a href="https://www.jianshu.com/p/f84f7e07e0d6" target="_blank" rel="noopener">https://www.jianshu.com/p/f84f7e07e0d6</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; &lt;em&gt;沉浸式状态栏怎么搞&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;实现沉浸式状态栏主要跟以下四个Api相关&quot;&gt;&lt;a href=&quot;#实现沉浸式状态栏主要跟以下四个Api相关&quot; class=&quot;headerlink&quot; title=&quot;实现沉浸式状态栏主要跟以下四个Api相关:&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="Android" scheme="https:mubai.site/categories/Android/"/>
    
    
      <category term="Android" scheme="https:mubai.site/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Rxjava2 太多方法了，记不住呀</title>
    <link href="https:mubai.site/2019-12-2-Rxjava2%20%E5%A4%AA%E5%A4%9A%E6%96%B9%E6%B3%95%E4%BA%86%EF%BC%8C%E8%AE%B0%E4%B8%8D%E4%BD%8F%E5%91%80/"/>
    <id>https:mubai.site/2019-12-2-Rxjava2 太多方法了，记不住呀/</id>
    <published>2019-12-01T16:00:00.000Z</published>
    <updated>2020-05-09T08:53:52.380Z</updated>
    
    <content type="html"><![CDATA[<p> <em>Rxjava2 太多方法了，记不住呀</em></p><p> 总结下</p><h4 id="一、什么是Rxjava以及Obserable的多种创建方式"><a href="#一、什么是Rxjava以及Obserable的多种创建方式" class="headerlink" title="一、什么是Rxjava以及Obserable的多种创建方式"></a>一、什么是Rxjava以及Obserable的多种创建方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">1.create():创建一个完成的被观察者(Observable)---&gt;:RxJava中创建被观察者最基本的操作符</span><br><span class="line"></span><br><span class="line">2.empty():快速创建后只发送complete事件，直接通知完成</span><br><span class="line"></span><br><span class="line">3.error():快速创建后只发送error事件，直接通知异常</span><br><span class="line"></span><br><span class="line">4.never():快速创建后不发送任何事件</span><br><span class="line"></span><br><span class="line">5.just():快速创建后直接发送传入的事件---&gt;参数最多只能10个，即发送的事件最多10个</span><br><span class="line"></span><br><span class="line">6.fromArray():快速创建后直接发送传入的数组数据---&gt;参数为数组，子类型为任意类型，可10个以上</span><br><span class="line"></span><br><span class="line">7.fromIterable():快速创建后直接发送传入的集合List数据---&gt;参数为集合List，子类型为任意类型，可10个以上</span><br><span class="line"></span><br><span class="line">8.defer():直到观察者Observer订阅被观察者Observable时，才动态创建被观察者&amp;发送事件---&gt;通过Observable工厂方法创建被观察者，每次订阅后都会得到一个最新创建的被观察者Observable，确保里面的数据是最新的</span><br><span class="line"></span><br><span class="line">9.timer():快速创建被观察者，指定延时时间，发送一个数值为0的事件---&gt;延时指定时间后发送一个参数为0的事件，相当于onNext（0）</span><br><span class="line"></span><br><span class="line">10.interval():快速创建被观察者，每隔指定时间发送事件---&gt;发送事件序列，从0开始，无限递增1</span><br><span class="line"></span><br><span class="line">11.intervalRange():快速创建被观察者，每隔指定时间发送事件，可指定发送事件数---&gt;发送无限递增1的事件序列，可指定起始值大小和事件次数，可延时，类似interval()</span><br><span class="line"></span><br><span class="line">12.range():快速创建被观察者，连续发送一个时间序列，可指定范围---&gt;发送无限递增1的事件序列，可指定起始值大小和事件次数，不可延时，类似intervalRange()</span><br><span class="line"></span><br><span class="line">13.rangeLong():同上，区别在于数据参数为类型Long</span><br></pre></td></tr></table></figure><h4 id="二、操作符"><a href="#二、操作符" class="headerlink" title="二、操作符"></a>二、操作符</h4><h5 id="一-变换操作符"><a href="#一-变换操作符" class="headerlink" title="(一).变换操作符"></a>(一).变换操作符</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.map():对Observable发送的每一个事件进行转换</span><br><span class="line"></span><br><span class="line">2.flatMap():对Observable发送的整个个事件进行转换（无序）</span><br><span class="line"></span><br><span class="line">3.concatMap():对Observable发送的整个个事件进行转换（有序）</span><br><span class="line"></span><br><span class="line">4.buffer():从Observable的事件中获取事件放到缓存区再发送事件</span><br></pre></td></tr></table></figure><h5 id="二-组合操作符"><a href="#二-组合操作符" class="headerlink" title="(二).组合操作符"></a>(二).组合操作符</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.concat()与concatArray():组合多个被观察者发送数据，合并后按照顺序执行---&gt;区别：组合被观察者数量：concat()&lt;=4,concatArray()无限制</span><br><span class="line"></span><br><span class="line">2.Merge()与MergeArray():组合多个被观察者发送数据，合并后按照时间顺序执行---&gt;区别：组合被观察者数量：Merge()&lt;=4,MergeArray()无限制</span><br><span class="line"></span><br><span class="line">3.concatDelayError():将错误事件延迟到所以事件执行完后才执行错误事件</span><br><span class="line"> </span><br><span class="line">4.megreDelayError():类似上面concatDelayError</span><br><span class="line"></span><br><span class="line">5.startWith()与startWithArray():在一个被观察者发送数据前，追加发送一些数据---&gt;调用顺序：先追加的后调用，后追加的先调用</span><br></pre></td></tr></table></figure><h5 id="三-合并操作符"><a href="#三-合并操作符" class="headerlink" title="(三).合并操作符"></a>(三).合并操作符</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.zip():合并多个被观察者发送的事件，生成一个新的事件序列。---&gt;严格按照事件序列进行合并,最后Observable的数据=多个Observable中数量最少的</span><br><span class="line"></span><br><span class="line">2.combineLatest():将两个Observable产生的结果进行合并，合并新的Observable发送给订阅者---&gt;当其中一个Observable发送数据，都与另一个Observable最后发送的数据结合，类似zip()，不同的是按照时间点合并</span><br><span class="line"></span><br><span class="line">3.combineLatestDelayError():将错误事件延迟到所以事件执行完后才执行错误事件</span><br><span class="line"></span><br><span class="line">4.reduce():把观察者需要发送的事件聚合成一个事件并且发送。---&gt;前两个被观察者聚合成新的被观察者，再与下一数据聚合，一次类推</span><br><span class="line"></span><br><span class="line">5.collect():将被观察者发送的数据放到一个容器中处理</span><br></pre></td></tr></table></figure><h5 id="四-统计发送事件的数量"><a href="#四-统计发送事件的数量" class="headerlink" title="(四).统计发送事件的数量"></a>(四).统计发送事件的数量</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count()方法是统计Observable(被观察者)发送的事件的数量</span><br></pre></td></tr></table></figure><h5 id="五-延迟操作符"><a href="#五-延迟操作符" class="headerlink" title="(五).延迟操作符"></a>(五).延迟操作符</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1.doOnNext():执行onNext()事件前调用</span><br><span class="line"></span><br><span class="line">2.doOnEach():当Observable每发送一次数据就调用一次</span><br><span class="line"></span><br><span class="line">3.doAfterNext():执行onNext()事件后调用</span><br><span class="line"></span><br><span class="line">4.doOnError():发送错误事件时调用</span><br><span class="line"></span><br><span class="line">5.doAfterTerminate():无论是正常发送事件完毕/异常终止都回调</span><br><span class="line"></span><br><span class="line">6.doOnSubscribe():观察者订阅时回调</span><br><span class="line"></span><br><span class="line">7.doOnComplete():正常发送事件完毕后</span><br><span class="line"></span><br><span class="line">8.doFinally():最后执行</span><br></pre></td></tr></table></figure><h5 id="六-错误处理操作符"><a href="#六-错误处理操作符" class="headerlink" title="(六).错误处理操作符"></a>(六).错误处理操作符</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.onErrorReturn():Observable发生错误或异常时发送一个相同类型的特殊事件，并且终止事件发送。</span><br><span class="line"></span><br><span class="line">2.onErrorResumeNext():Observable发生错误或异常时产生新的Observable发送一个特殊事件，并且终止事件发送。</span><br><span class="line"></span><br><span class="line">3.onExceptionResumeNext():同上，不同点：这里只能拦截异常不能拦截错误</span><br><span class="line"></span><br><span class="line">4.retry():发生异常或错误时重试源Observable的请求</span><br><span class="line"></span><br><span class="line">5.retryWhen():同上，不同点：将错误异常传递给新的Observable通知源Observable</span><br><span class="line"></span><br><span class="line">6.repeat():重复源Observable发送事件（抛出异常错误不能重复发送）</span><br><span class="line"></span><br><span class="line">7.repeatWhen():在回调方法中创建新的Observable，通过新的observable是否重复订阅和发送事件。</span><br></pre></td></tr></table></figure><h5 id="七-过滤操作符"><a href="#七-过滤操作符" class="headerlink" title="(七).过滤操作符"></a>(七).过滤操作符</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1.filter():按照指定的条件(自定义)对被观察者发出的结果进行过滤，再提交给被观察者---&gt;在回调方法中实现规则过滤</span><br><span class="line"></span><br><span class="line">2.ofType():根据指定的数据类型对被观察者发出的结果进行过滤，再提交给被观察者---&gt;参数传入对结果过滤的类型</span><br><span class="line"></span><br><span class="line">3.elementAt():将指定索引被观察者发出的事件提交给观察者，索引为0---&gt;参数传入索引</span><br><span class="line"></span><br><span class="line">4.distinct():去重，去掉被观察者产生的重复的结果，将不重复的提交给观察者</span><br><span class="line"></span><br><span class="line">5.debounce():只接收到倒计时时间外的被观察者发出的事件，每个事件发出时会重置倒计时时间。---&gt;参数传入每个事件的倒计时时间</span><br><span class="line"></span><br><span class="line">6.first():将被观察者产生的第一个结果提交给被观察者处理</span><br><span class="line"></span><br><span class="line">7.last():将被观察者产生的最后一个结果提交给观察者处理</span><br><span class="line"></span><br><span class="line">8.skip():跳过前n个被观察者产生的结果，将后面的提交给观察者处理---&gt;参数传入指定跳过的数量</span><br><span class="line"></span><br><span class="line">9.take():将前n个被观察者产生的结果提交给观察者处理，其他的不做处理---&gt;参数传入指定执行的数量</span><br></pre></td></tr></table></figure><h5 id="八-其他他操作符"><a href="#八-其他他操作符" class="headerlink" title="(八).其他他操作符"></a>(八).其他他操作符</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.groupBy():对于源Observable(被观察者)产生的结果进行分组，形成一个类型为GroupedObservable的结果集，存在一个方法为getKey()，通过该方法获取结果集的key值---&gt;如果事件结果没有处理，那么take()处理一下，否则会内存泄漏</span><br><span class="line"></span><br><span class="line">2.cast():用于类型转换，将源Observable的源类型转为指定的.class---&gt;如果类型不正确则会抛出转换异常。</span><br><span class="line"></span><br><span class="line">3.scan()遍历源Observable产生的结果，依次每个结果按照指定的规则进行计算，计算后的结果作为下一项迭代的参数，每一次迭代项都会把计算结果输出给订阅者。---&gt;每次计算的结果用于下次计算</span><br><span class="line"></span><br><span class="line">4.join():把两个Observable产生的结果进行合并，合并结果组成一个新的Observable，可以控制每个Observable产生结果的生命周期，在每个结果的生命周期内，可以与另一个Observable产生的结果按照一定的规则进行合并---&gt;合并结果产生新的Observable</span><br><span class="line"></span><br><span class="line">5.groupJoin():类似上述，第三个参数不一致，返回新的Observable处理</span><br></pre></td></tr></table></figure><h3 id="背压"><a href="#背压" class="headerlink" title="背压"></a>背压</h3><ul><li>背压指的是上游的被观察者发送的速度太快，而观察者处理的速度较慢，处理不过来，就会出现异常Backpressure</li></ul><ul><li><p>Hot Obserable:创建后Obserable就立马发送事件，都不支持背压</p></li><li><p>Cold Obserable:订阅后才开始发送事件，部分支持，部分不支持</p></li><li><p>解决方案就是通过下游告诉上游的被观察者降低发送速度</p></li><li><p>在RxJava1.0中，由于Obserable部分支持部分不支持，在支持背压的Obserable中 我们可以通过响应式拉取，即让观察者去通知被观察者发送事件，request，不支持背压的可以通过过滤事件结果，合并事件结果等方式来解决。</p></li><li><p>在RxJava2.0中，有了新的Flowable来解决背压，通过Flowable创建的都是非阻塞背压，注意的是这边的观察者是实现Subscriber。(Flowable的队列长度是128)</p></li></ul><h4 id="沿着别人走过的路，跟上去发现不一样的风景"><a href="#沿着别人走过的路，跟上去发现不一样的风景" class="headerlink" title="沿着别人走过的路，跟上去发现不一样的风景"></a>沿着别人走过的路，跟上去发现不一样的风景</h4><p>参考链接：</p><ul><li>转载：<a href="https://blog.csdn.net/m0_37796683/article/details/102525484" target="_blank" rel="noopener">https://blog.csdn.net/m0_37796683/article/details/102525484</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; &lt;em&gt;Rxjava2 太多方法了，记不住呀&lt;/em&gt;&lt;/p&gt;
&lt;p&gt; 总结下&lt;/p&gt;
&lt;h4 id=&quot;一、什么是Rxjava以及Obserable的多种创建方式&quot;&gt;&lt;a href=&quot;#一、什么是Rxjava以及Obserable的多种创建方式&quot; class=&quot;heade
      
    
    </summary>
    
      <category term="Android" scheme="https:mubai.site/categories/Android/"/>
    
    
      <category term="Android" scheme="https:mubai.site/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Activity 布局加载分析</title>
    <link href="https:mubai.site/2019-11-2-Activity%20%E5%B8%83%E5%B1%80%E5%8A%A0%E8%BD%BD%E5%88%86%E6%9E%90/"/>
    <id>https:mubai.site/2019-11-2-Activity 布局加载分析/</id>
    <published>2019-11-01T16:00:00.000Z</published>
    <updated>2020-05-07T08:27:26.194Z</updated>
    
    <content type="html"><![CDATA[<p> <em>关于Activity需要知道的更多内容</em></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>关于Activity的创建以及执行回调onCreate方法我们已经知道了（看这里：<a href="https://www.jianshu.com/p/3de730c145be" target="_blank" rel="noopener">https://www.jianshu.com/p/3de730c145be</a><br>），然后我们今天想知道我们在onCreate中调用setContentView方法的时候，xml是如何加载的，所以今天就跟着源码来看看。<br>ps：源码版本为 android-26</p><p>一般来说我们写一个XxxActivity都会去继承Activity、FragmentActivity、AppCompatActivity这3个的其中一个，我们今天就分别对这几个父类Activity去分析</p><ul><li>1、Activity的xml加载过程</li><li>2、FragmentActivity的xml加载过程</li><li>3、AppCompatActivity的xml加载过程</li></ul><h3 id="一、Activity的xml加载过程"><a href="#一、Activity的xml加载过程" class="headerlink" title="一、Activity的xml加载过程"></a>一、Activity的xml加载过程</h3><p>进入我们setContentView方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">## Activity</span><br><span class="line">public void setContentView(@LayoutRes int layoutResID) &#123;</span><br><span class="line">      getWindow().setContentView(layoutResID);//1、调用phoneWindow的setContentView方法</span><br><span class="line">      initWindowDecorActionBar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这边注释的地方getWindow方法获取的一个window对象，它的实现类是PhoneWindow，它在Activity的attach中进行创建出来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">## Activity</span><br><span class="line">final void attach(Context context, ...,</span><br><span class="line">           Window window, ActivityConfigCallback activityConfigCallback) &#123;</span><br><span class="line">       ...</span><br><span class="line">       mWindow = new PhoneWindow(this, window, activityConfigCallback);//这边进行window对象的初始化</span><br><span class="line">       ...</span><br><span class="line">       mWindow.setColorMode(info.colorMode);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>我们跟进PhoneWindow，看看它里面的setContentView方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">##PhoneWindow</span><br><span class="line">@Override</span><br><span class="line">public void setContentView(int layoutResID) &#123;</span><br><span class="line">    if (mContentParent == null) &#123;</span><br><span class="line">        installDecor();//1、加载DecorView</span><br><span class="line">    &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        mContentParent.removeAllViews();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,</span><br><span class="line">                getContext());</span><br><span class="line">        transitionTo(newScene);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mLayoutInflater.inflate(layoutResID, mContentParent);//2、布局加载器</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注释1是加载DecorView，注释2通过布局加载器将xml解析成view树，并且将view树添加到mContentParent中</p><h4 id="1、加载DecorView"><a href="#1、加载DecorView" class="headerlink" title="1、加载DecorView"></a>1、加载DecorView</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">### PhoneWindow</span><br><span class="line">/**</span><br><span class="line"> * 加载DecorView</span><br><span class="line"> */</span><br><span class="line">private void installDecor() &#123;</span><br><span class="line">        mForceDecorInstall = false;</span><br><span class="line">        if (mDecor == null) &#123;</span><br><span class="line">            mDecor = generateDecor(-1);//1、创建DecorView</span><br><span class="line">            ...</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mDecor.setWindow(this);//2、DecorView绑定到Window</span><br><span class="line">        &#125;</span><br><span class="line">        if (mContentParent == null) &#123;</span><br><span class="line">            mContentParent = generateLayout(mDecor);//3、根据DecorView生成Layout，得到一个mContentParent</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * 1、创建DecorView</span><br><span class="line"> */</span><br><span class="line">protected DecorView generateDecor(int featureId) &#123;</span><br><span class="line">    ... //这边去创建DecorView</span><br><span class="line">    return new DecorView(context, featureId, this, getAttributes());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> *2、调用DecorView的setWindow，传入PhoneWindow对象</span><br><span class="line"> */</span><br><span class="line"> void setWindow(PhoneWindow phoneWindow) &#123;</span><br><span class="line">        mWindow = phoneWindow;</span><br><span class="line">        ...</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> *3、根据DecorView生成Layout</span><br><span class="line"> */</span><br><span class="line">protected ViewGroup generateLayout(DecorView decor) &#123;</span><br><span class="line">    // Apply data from current theme.</span><br><span class="line">    //1、获取当前的主题，然后设置相关数据到window上</span><br><span class="line">    TypedArray a = getWindowStyle();</span><br><span class="line">    ...</span><br><span class="line">    mIsFloating = a.getBoolean(R.styleable.Window_windowIsFloating, false);//2、当前Window是否浮动在上面，默认为false</span><br><span class="line">    int flagsToUpdate = (FLAG_LAYOUT_IN_SCREEN|FLAG_LAYOUT_INSET_DECOR)</span><br><span class="line">            &amp; (~getForcedWindowFlags());</span><br><span class="line">    if (mIsFloating) &#123;</span><br><span class="line">        setLayout(WRAP_CONTENT, WRAP_CONTENT);//3、传入window的宽、高</span><br><span class="line">        setFlags(0, flagsToUpdate);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        setFlags(FLAG_LAYOUT_IN_SCREEN|FLAG_LAYOUT_INSET_DECOR, flagsToUpdate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (a.getBoolean(R.styleable.Window_windowNoTitle, false)) &#123;//4、window是否有title</span><br><span class="line">        requestFeature(FEATURE_NO_TITLE);//5、请求指定Window的风格，它必须在setContentView之前</span><br><span class="line">    &#125; else if (a.getBoolean(R.styleable.Window_windowActionBar, false)) &#123;</span><br><span class="line">        // Don&apos;t allow an action bar if there is no title.</span><br><span class="line">        requestFeature(FEATURE_ACTION_BAR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    //6、这边会很多的设置窗口属性的判断和方法，具体可以大家可以去看源码</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    // Inflate the window decor.</span><br><span class="line">    //7、根据上面设置的窗口的属性 ，设置相应的 layoutResource</span><br><span class="line">    int layoutResource;</span><br><span class="line">    int features = getLocalFeatures();</span><br><span class="line">    if ((features &amp; (1 &lt;&lt; FEATURE_SWIPE_TO_DISMISS)) != 0) &#123;</span><br><span class="line">        layoutResource = R.layout.screen_swipe_dismiss;</span><br><span class="line">        setCloseOnSwipeEnabled(true);</span><br><span class="line">    &#125; else if ((features &amp; ((1 &lt;&lt; FEATURE_LEFT_ICON) | (1 &lt;&lt; FEATURE_RIGHT_ICON))) != 0) &#123;</span><br><span class="line">        if (mIsFloating) &#123;</span><br><span class="line">            TypedValue res = new TypedValue();</span><br><span class="line">            getContext().getTheme().resolveAttribute(</span><br><span class="line">                    R.attr.dialogTitleIconsDecorLayout, res, true);</span><br><span class="line">            layoutResource = res.resourceId;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            layoutResource = R.layout.screen_title_icons;</span><br><span class="line">        &#125;</span><br><span class="line">        removeFeature(FEATURE_ACTION_BAR);</span><br><span class="line">    &#125; else if ((features &amp; ((1 &lt;&lt; FEATURE_PROGRESS) | (1 &lt;&lt; FEATURE_INDETERMINATE_PROGRESS))) != 0</span><br><span class="line">            &amp;&amp; (features &amp; (1 &lt;&lt; FEATURE_ACTION_BAR)) == 0) &#123;</span><br><span class="line">        layoutResource = R.layout.screen_progress;</span><br><span class="line">    &#125; else if ((features &amp; (1 &lt;&lt; FEATURE_CUSTOM_TITLE)) != 0) &#123;</span><br><span class="line">        if (mIsFloating) &#123;</span><br><span class="line">            TypedValue res = new TypedValue();</span><br><span class="line">            getContext().getTheme().resolveAttribute(</span><br><span class="line">                    R.attr.dialogCustomTitleDecorLayout, res, true);</span><br><span class="line">            layoutResource = res.resourceId;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            layoutResource = R.layout.screen_custom_title;</span><br><span class="line">        &#125;</span><br><span class="line">        removeFeature(FEATURE_ACTION_BAR);</span><br><span class="line">    &#125; else if ((features &amp; (1 &lt;&lt; FEATURE_NO_TITLE)) == 0) &#123;</span><br><span class="line">        if (mIsFloating) &#123;</span><br><span class="line">            TypedValue res = new TypedValue();</span><br><span class="line">            getContext().getTheme().resolveAttribute(</span><br><span class="line">                    R.attr.dialogTitleDecorLayout, res, true);</span><br><span class="line">            layoutResource = res.resourceId;</span><br><span class="line">        &#125; else if ((features &amp; (1 &lt;&lt; FEATURE_ACTION_BAR)) != 0) &#123;</span><br><span class="line">            layoutResource = a.getResourceId(</span><br><span class="line">                  R.styleable.Window_windowActionBarFullscreenDecorLayout,</span><br><span class="line">                    R.layout.screen_action_bar);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            layoutResource = R.layout.screen_title;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if ((features &amp; (1 &lt;&lt; FEATURE_ACTION_MODE_OVERLAY)) != 0) &#123;</span><br><span class="line">        layoutResource = R.layout.screen_simple_overlay_action_mode;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // Embedded, so no decoration is needed.</span><br><span class="line">        layoutResource = R.layout.screen_simple;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mDecor.startChanging();//8、开始DecorView的变化</span><br><span class="line">    mDecor.onResourcesLoaded(mLayoutInflater, layoutResource);//9、根据布局文件xml加载得到View树</span><br><span class="line"></span><br><span class="line">    ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);//10、根据content id返回一个contentParent，是一个viewGroup</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    mDecor.finishChanging(); //11、结束DecorView的变化</span><br><span class="line"></span><br><span class="line">    return contentParent; //12、返回一个contentParent</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面这段源码中，我们主要是做了几件事：</p><ul><li>1、注释1这里的样式通常是用来描述窗口的，通常view的样式是通过layout来描述的，而窗口的样式是通过Androidmanifest.xml来配置的，所以我们这里通过调用getWindowStyle方法，然后得到一个TypedArray对象，这个类我们比较熟悉，在我们自定义View的时候，如果需要自定义style，我们都会在初始化的时候得到一个TypedArray对象，然后去设置相关的样式。</li><li>2、注释2返回一个boolean值，表示我们的window是否悬浮在上面，然后根据这个值去设置相关的window宽高和其他的标签，注释4和注释6的地方判断window是否有title或者是否没有ActionBar，然后通过注释5的地方调用requestFeature去设置相关属性，所以我们这边会是否能联想到我们去如果在Activity的onCreat方法里去设置全屏的时候，需要在setConentView之前去设置，因为在setContentView之后的话，installDecor方法就已经执行完毕了，那我们设置的window属性就没有作用了。</li><li>3、注释7的地方根据上面设置的窗口的属性，来设置相关的layoutResource，我们可以去源码中查找相应的layout，具体位置在：frameworks/base/core/res/res/layout下<br><img src="https://upload-images.jianshu.io/upload_images/4248391-c7d5b09e0da27884.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/540" alt="image.png"></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">##screen_simple</span><br><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    android:fitsSystemWindows=&quot;true&quot;</span><br><span class="line">    android:orientation=&quot;vertical&quot;&gt;</span><br><span class="line">    &lt;ViewStub android:id=&quot;@+id/action_mode_bar_stub&quot;</span><br><span class="line">              android:inflatedId=&quot;@+id/action_mode_bar&quot;</span><br><span class="line">              android:layout=&quot;@layout/action_mode_bar&quot;</span><br><span class="line">              android:layout_width=&quot;match_parent&quot;</span><br><span class="line">              android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">              android:theme=&quot;?attr/actionBarTheme&quot; /&gt;</span><br><span class="line">    &lt;FrameLayout</span><br><span class="line">         android:id=&quot;@android:id/content&quot;</span><br><span class="line">         android:layout_width=&quot;match_parent&quot;</span><br><span class="line">         android:layout_height=&quot;match_parent&quot;</span><br><span class="line">         android:foregroundInsidePadding=&quot;false&quot;</span><br><span class="line">         android:foregroundGravity=&quot;fill_horizontal|top&quot;</span><br><span class="line">         android:foreground=&quot;?android:attr/windowContentOverlay&quot; /&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/4248391-8f83b29234587d89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/540" alt="image.png"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">##screen_simple_overlay_action_mode</span><br><span class="line">&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    android:fitsSystemWindows=&quot;true&quot;&gt;</span><br><span class="line">    &lt;FrameLayout</span><br><span class="line">         android:id=&quot;@android:id/content&quot;</span><br><span class="line">         android:layout_width=&quot;match_parent&quot;</span><br><span class="line">         android:layout_height=&quot;match_parent&quot;</span><br><span class="line">         android:foregroundInsidePadding=&quot;false&quot;</span><br><span class="line">         android:foregroundGravity=&quot;fill_horizontal|top&quot;</span><br><span class="line">         android:foreground=&quot;?android:attr/windowContentOverlay&quot; /&gt;</span><br><span class="line">    &lt;ViewStub android:id=&quot;@+id/action_mode_bar_stub&quot;</span><br><span class="line">              android:inflatedId=&quot;@+id/action_mode_bar&quot;</span><br><span class="line">              android:layout=&quot;@layout/action_mode_bar&quot;</span><br><span class="line">              android:layout_width=&quot;match_parent&quot;</span><br><span class="line">              android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">              android:theme=&quot;?attr/actionBarTheme&quot; /&gt;</span><br><span class="line">&lt;/FrameLayout&gt;</span><br></pre></td></tr></table></figure></p><p>我们能够发现这几个layout里面都包含了一个id为content的FrameLayout，它是用来添加我们自己的布局。</p><ul><li>4、注释9根据我们上面得到的布局文件加载onResourcesLoaded得到view树<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">##DecorView</span><br><span class="line">void onResourcesLoaded(LayoutInflater inflater, int layoutResource) &#123;</span><br><span class="line">    ...</span><br><span class="line">   //创建一个DecorCaptionView，它是Decor的标题View, 它包含了标题和窗口控件按钮，它的可见性取决于工作空间和窗口类型</span><br><span class="line">    mDecorCaptionView = createDecorCaptionView(inflater);</span><br><span class="line">    final View root = inflater.inflate(layoutResource, null);//1、用LayoutInflate来加载xml布局文件得到view</span><br><span class="line">    //2、 若不 null 则先添加 mDecorCaptionView, 再向 mDecorCaptionView 中添加 root</span><br><span class="line">    if (mDecorCaptionView != null) &#123;</span><br><span class="line">        if (mDecorCaptionView.getParent() == null) &#123;</span><br><span class="line">            //将 mDecorCaptionView 添加到DecorView</span><br><span class="line">            addView(mDecorCaptionView,</span><br><span class="line">                    new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));</span><br><span class="line">        &#125;</span><br><span class="line">        //获取的到root add到 mDecorCaptionView 中</span><br><span class="line">        mDecorCaptionView.addView(root,</span><br><span class="line">                new ViewGroup.MarginLayoutParams(MATCH_PARENT, MATCH_PARENT));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 3、若mDecorCaptionView为 null, 则直接添加调用addView将 root 加到 DecorView 中</span><br><span class="line">        // Put it below the color views.</span><br><span class="line">        addView(root, 0, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));</span><br><span class="line">    &#125;</span><br><span class="line">    // 4、强转成 ViewGroup, 传递给 mContentRoot</span><br><span class="line">    mContentRoot = (ViewGroup) root;</span><br><span class="line">    initializeElevation();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private DecorCaptionView createDecorCaptionView(LayoutInflater inflater) &#123;</span><br><span class="line">    ...</span><br><span class="line">   //这里将源码稍微变动下，直接调用inflateDecorCaptionView方法</span><br><span class="line">    DecorCaptionView decorCaptionView =  inflateDecorCaptionView(inflater)</span><br><span class="line">    ...</span><br><span class="line">    return decorCaptionView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private DecorCaptionView inflateDecorCaptionView(LayoutInflater inflater) &#123;</span><br><span class="line">    final Context context = getContext();</span><br><span class="line">    inflater = inflater.from(context);</span><br><span class="line">    //这边通过LayoutInflater来获到DecorCaptionView</span><br><span class="line">    final DecorCaptionView view = (DecorCaptionView) inflater.inflate(R.layout.decor_caption,</span><br><span class="line">            null);</span><br><span class="line">    setDecorCaptionShade(context, view);</span><br><span class="line">    return view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>可以看到在onResourcesLoaded这里是我们做了4件事：</p><ul><li>4.1、注释1是根据LayoutInflate加载xml布局文件得到View对象 root</li><li>4.2、注释2判断DecorCaptionView是否为null，不为null，先去添加DecorCaptionView，再去添加root（DecorCaptionView是一个标题view，这个类表示用于控制自由格式上窗口的特殊屏幕元素）</li><li>4.3、注释3如果DecorCaptionView为null，就直接将root添加到DecorView中</li><li>4.4、注释4是将root强转成一个ViewGroup并传递给mContentRoot</li></ul><ul><li>5、在注释10这里根据我们的ID_ANDROID_CONTENT通过findViewById返回一个contentParent，它是我们在步骤3中的DecorView中mContentRoot中的FrameLayout的Id，也就是我们通过setContentView将布局添加进去的地方。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">##Window</span><br><span class="line"> public static final int ID_ANDROID_CONTENT = com.android.internal.R.id.content</span><br></pre></td></tr></table></figure></li></ul><h4 id="2、布局加载器加载xml生成View树"><a href="#2、布局加载器加载xml生成View树" class="headerlink" title="2、布局加载器加载xml生成View树"></a>2、布局加载器加载xml生成View树</h4><p>通过LayoutInflater布局加载器去生成View树<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">##LayoutInflater</span><br><span class="line">public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) &#123;</span><br><span class="line">    final Resources res = getContext().getResources();</span><br><span class="line">    ...</span><br><span class="line">    final XmlResourceParser parser = res.getLayout(resource);//1、根据xml id 得到一个xml解析器资源</span><br><span class="line">    try &#123;</span><br><span class="line">        return inflate(parser, root, attachToRoot);//2、传入xml解析器资源和mContentParent</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        parser.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>1、注释1得到一个xml解析器资源</li><li>2、注释3 调用inflate返回view<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">##LayoutInflater</span><br><span class="line">public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) &#123;</span><br><span class="line">    synchronized (mConstructorArgs) &#123;</span><br><span class="line">        ...</span><br><span class="line">        View result = root;//1、它就是我们最终返回的view对象</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            // Look for the root node.</span><br><span class="line">            int type;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">          </span><br><span class="line">            final String name = parser.getName();//XmlPullParser解析xml，获取里面的标签name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            if (TAG_MERGE.equals(name)) &#123;//这里获取的name如果是merge，则root不能为null，否则会抛出异常</span><br><span class="line">                if (root == null || !attachToRoot) &#123;</span><br><span class="line">                    throw new InflateException(&quot;&lt;merge /&gt; can be used only with a valid &quot;</span><br><span class="line">                            + &quot;ViewGroup root and attachToRoot=true&quot;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                rInflate(parser, root, inflaterContext, attrs, false);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // Temp is the root view that was found in the xml</span><br><span class="line">                //2、这边创建得到一个临时的view对象 temp</span><br><span class="line">                final View temp = createViewFromTag(root, name, inflaterContext, attrs);</span><br><span class="line"></span><br><span class="line">                ViewGroup.LayoutParams params = null;</span><br><span class="line"></span><br><span class="line">                ...</span><br><span class="line">                if (root != null &amp;&amp; attachToRoot) &#123;//3、这边判断如果root不为null，则将临时的view对象temp添加到root中</span><br><span class="line">                    root.addView(temp, params);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (root == null || !attachToRoot) &#123;//4、如果root为null，将temp传递给我们的最终view</span><br><span class="line">                    result = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>这里通过一系列的判断和传递最终会得到一个View对象，它就是我们根据xml去解析加载出来的View树。</p><p>附加一张window和contentView的层次结构图</p><p><img src="https://upload-images.jianshu.io/upload_images/4147272-00b5f60232885fac.jpg" alt="image.png"></p><h3 id="二、AppCompatActivity的xml加载"><a href="#二、AppCompatActivity的xml加载" class="headerlink" title="二、AppCompatActivity的xml加载"></a>二、AppCompatActivity的xml加载</h3><p>跟进AppCompatActivity的setContentView方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">##AppCompatActivity</span><br><span class="line">@Override</span><br><span class="line">public void setContentView(@LayoutRes int layoutResID) &#123;</span><br><span class="line">    getDelegate().setContentView(layoutResID);//调用getDelegate的setContentView</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这边的getDelegate返回的是一个AppCompatDelegate，它是一个抽象类，这边我们跟踪发现最后是在AppCompatDelegateImplV9中调用了setContentView方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">##AppCompatDelegateImplV9</span><br><span class="line">@Override</span><br><span class="line">public void setContentView(int resId) &#123;</span><br><span class="line">    ensureSubDecor();//1、创建DecorView</span><br><span class="line">    ViewGroup contentParent = (ViewGroup) mSubDecor.findViewById(android.R.id.content);//2、这边根据content id去返回一个contentParent</span><br><span class="line">    contentParent.removeAllViews();</span><br><span class="line">    LayoutInflater.from(mContext).inflate(resId, contentParent);//3、通过LayoutInflater布局加载器将xml解析得到View树，添加到contentParent中</span><br><span class="line">    mOriginalWindowCallback.onContentChanged();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="1、注释1创建DecorView"><a href="#1、注释1创建DecorView" class="headerlink" title="1、注释1创建DecorView"></a>1、注释1创建DecorView</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">##AppCompatDelegateImplV9</span><br><span class="line">private void ensureSubDecor() &#123;</span><br><span class="line">    if (!mSubDecorInstalled) &#123;</span><br><span class="line">        mSubDecor = createSubDecor();//调用createSubDecor方法</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private ViewGroup createSubDecor() &#123;</span><br><span class="line">    TypedArray a = mContext.obtainStyledAttributes(R.styleable.AppCompatTheme);</span><br><span class="line"></span><br><span class="line">//获取当前的主题，然后设置相关数据到window上</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    mWindow.getDecorView();//1、调用PhoneWindow的getDecorView方法</span><br><span class="line"></span><br><span class="line">    final LayoutInflater inflater = LayoutInflater.from(mContext);</span><br><span class="line">    ViewGroup subDecor = null;//定义一个viewgroup</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //2、根据window的样式不同去加载不同的layout</span><br><span class="line">    if (!mWindowNoTitle) &#123;</span><br><span class="line">        if (mIsFloating) &#123;</span><br><span class="line">           ...</span><br><span class="line">            subDecor = (ViewGroup) inflater.inflate(</span><br><span class="line">                    R.layout.abc_dialog_title_material, null);</span><br><span class="line">            ...</span><br><span class="line">        &#125; else if (mHasActionBar) &#123;</span><br><span class="line">           ...</span><br><span class="line">            subDecor = (ViewGroup) LayoutInflater.from(themedContext)</span><br><span class="line">                    .inflate(R.layout.abc_screen_toolbar, null);</span><br><span class="line">          ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (mOverlayActionMode) &#123;</span><br><span class="line">            subDecor = (ViewGroup) inflater.inflate(</span><br><span class="line">                    R.layout.abc_screen_simple_overlay_action_mode, null);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            subDecor = (ViewGroup) inflater.inflate(R.layout.abc_screen_simple, null);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">   //3、下面具体分析</span><br><span class="line">    // Make the decor optionally fit system windows, like the window&apos;s decor</span><br><span class="line">    ViewUtils.makeOptionalFitsSystemWindows(subDecor);</span><br><span class="line"></span><br><span class="line">    final ContentFrameLayout contentView = (ContentFrameLayout) subDecor.findViewById(</span><br><span class="line">            R.id.action_bar_activity_content);</span><br><span class="line"></span><br><span class="line">    final ViewGroup windowContentView = (ViewGroup) mWindow.findViewById(android.R.id.content);</span><br><span class="line">    if (windowContentView != null) &#123;</span><br><span class="line">        while (windowContentView.getChildCount() &gt; 0) &#123;</span><br><span class="line">            final View child = windowContentView.getChildAt(0);</span><br><span class="line">            windowContentView.removeViewAt(0);</span><br><span class="line">            contentView.addView(child);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Change our content FrameLayout to use the android.R.id.content id.</span><br><span class="line">        // Useful for fragments.</span><br><span class="line">        windowContentView.setId(View.NO_ID);</span><br><span class="line">        contentView.setId(android.R.id.content);</span><br><span class="line"></span><br><span class="line">        // The decorContent may have a foreground drawable set (windowContentOverlay).</span><br><span class="line">        // Remove this as we handle it ourselves</span><br><span class="line">        if (windowContentView instanceof FrameLayout) &#123;</span><br><span class="line">            ((FrameLayout) windowContentView).setForeground(null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //4、调用PhoneWindow的setContentView方法</span><br><span class="line">    // Now set the Window&apos;s content view with the decor</span><br><span class="line">    mWindow.setContentView(subDecor);</span><br><span class="line">    ...</span><br><span class="line">    return subDecor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ensureSubDecor调用了createSubDecor方法：</p><ul><li><p>1、注释1调用了PhoneWindow的getDecorView方法，我们可以看到这里去调用了installDecor方法，这个方法我们在本篇的Activity的xml加载过程已经分析过了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">##PhoneWindow</span><br><span class="line">@Override</span><br><span class="line">public final View getDecorView() &#123;</span><br><span class="line">    if (mDecor == null || mForceDecorInstall) &#123;</span><br><span class="line">        installDecor();</span><br><span class="line">    &#125;</span><br><span class="line">    return mDecor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>2、注释2根据不同的window主题样式去加载不同的layout，然后通过布局加载器将xml解析成subDecor，每一个layout中都会include一个名为abc_screen_content_include.xml的layout，这个layout包含id为action_bar_activity_content的ContentFrameLayout。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">源码位置：/frameworks/support/v7/appcompat/res/layout/abc_dialog_title_material.xml</span><br><span class="line"></span><br><span class="line">##abc_screen_simple_overlay_action_mode</span><br><span class="line">&lt;android.support.v7.widget.FitWindowsFrameLayout</span><br><span class="line">        xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">        android:id=&quot;@+id/action_bar_root&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;</span><br><span class="line">        android:fitsSystemWindows=&quot;true&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;include layout=&quot;@layout/abc_screen_content_include&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;android.support.v7.widget.ViewStubCompat</span><br><span class="line">            android:id=&quot;@+id/action_mode_bar_stub&quot;</span><br><span class="line">            android:inflatedId=&quot;@+id/action_mode_bar&quot;</span><br><span class="line">            android:layout=&quot;@layout/abc_action_mode_bar&quot;</span><br><span class="line">            android:layout_width=&quot;match_parent&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/android.support.v7.widget.FitWindowsFrameLayout&gt;</span><br><span class="line"></span><br><span class="line">##abc_screen_content_include</span><br><span class="line">&lt;merge xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;android.support.v7.widget.ContentFrameLayout</span><br><span class="line">            android:id=&quot;@id/action_bar_activity_content&quot;</span><br><span class="line">            android:layout_width=&quot;match_parent&quot;</span><br><span class="line">            android:layout_height=&quot;match_parent&quot;</span><br><span class="line">            android:foregroundGravity=&quot;fill_horizontal|top&quot;</span><br><span class="line">            android:foreground=&quot;?android:attr/windowContentOverlay&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/merge&gt;</span><br></pre></td></tr></table></figure></li><li><p>3、在注释3调用调用findViewById找到id为action_bar_activity_content的contentView，然后在通过PhoneWindow找到id为content的windowContentView，然后去循环遍历windowContentView，将它的的子View添加到contentView中去，然后在把windowContentView的id设置为-1，contentView的id设置为原来windowContentView的id content，这个地方可以简单的理解为就是将DecorView(windowContentView)中的view转移到subDecor(contentView)中。</p></li><li><p>4、注释4调用PhoneWindow的setContentView方法，将subDecor传递进去，然后将subDecor存放到mContentParent中，这边我们可以发现它和上一部分(Activity)的区别，在Activity中mContentParent是直接用来存放我们自定义xml布局的，在AppCompatActivity中，mContentParent会先存放一个subDecor，然后在subDecor才是真正存放我们的自定义xml布局。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">##PhoneWindow</span><br><span class="line">@Override</span><br><span class="line">public void setContentView(View view) &#123;</span><br><span class="line">    setContentView(view, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void setContentView(View view, ViewGroup.LayoutParams params) &#123;</span><br><span class="line">    if (mContentParent == null) &#123;</span><br><span class="line">        installDecor();</span><br><span class="line">    &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        mContentParent.removeAllViews();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        view.setLayoutParams(params);</span><br><span class="line">        final Scene newScene = new Scene(mContentParent, view);</span><br><span class="line">        transitionTo(newScene);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mContentParent.addView(view, params);</span><br><span class="line">    &#125;</span><br><span class="line">    mContentParent.requestApplyInsets();</span><br><span class="line">    final Callback cb = getCallback();</span><br><span class="line">    if (cb != null &amp;&amp; !isDestroyed()) &#123;</span><br><span class="line">        cb.onContentChanged();</span><br><span class="line">    &#125;</span><br><span class="line">    mContentParentExplicitlySet = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>一张层次结构图带你理解：</p><p><img src="https://upload-images.jianshu.io/upload_images/19552390-f9a55e06bc240d60.png" alt="image.png"></p><h3 id="三、FragmentActivity的xml加载"><a href="#三、FragmentActivity的xml加载" class="headerlink" title="三、FragmentActivity的xml加载"></a>三、FragmentActivity的xml加载</h3><p>关于FragmentActivity，我们可以发现它自己是没有实现setContentView的，它是直接调用了父类Activity的setContentView方法，所以我们可以看上面的Activity的xml加载过程就可以了。<br>但是为什么会有FragmentActivity以及它的作用呢，这就要从Fragment说起来，在Android3.0以前是没有Fragment的，为了能让3.0以前能使用Fragment我们需要引入了support包，然后去继承FragmentActivity就可以使用Fragment，在3.0以后我们可以选择直接继承Activity，就可以正常使用Fragment了。而且3.0以前获取FragmentManager的方法是getSupportFragmentManager，3.0以后直接用getFragmentManager就可以了。<br>关于Fragment和FragmentManager我们会在另外的文字里进行分析，这里就不多讲。</p><p>ps：关于FragmentActivity的api原文</p><p>FragmentActivity is a special activity provided in the Support Library to handle fragments on system versions older than API level 11. If the lowest system version you support is API level 11 or higher, then you can use a regular Activity.</p><h4 id="沿着别人走过的路，跟上去发现不一样的风景"><a href="#沿着别人走过的路，跟上去发现不一样的风景" class="headerlink" title="沿着别人走过的路，跟上去发现不一样的风景"></a>沿着别人走过的路，跟上去发现不一样的风景</h4><p>参考链接：</p><ul><li>1、<a href="https://www.jianshu.com/p/3872219cc07a" target="_blank" rel="noopener">https://www.jianshu.com/p/3872219cc07a</a></li><li>2、<a href="https://www.jianshu.com/p/fc717b47b322" target="_blank" rel="noopener">https://www.jianshu.com/p/fc717b47b322</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; &lt;em&gt;关于Activity需要知道的更多内容&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;关于Activity的创建以及执行回调onCreate方法我们已经
      
    
    </summary>
    
      <category term="Android" scheme="https:mubai.site/categories/Android/"/>
    
    
      <category term="Android" scheme="https:mubai.site/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Application的创建、Activity的创建</title>
    <link href="https:mubai.site/2019-10-28-Application%E7%9A%84%E5%88%9B%E5%BB%BA%E3%80%81Activity%E7%9A%84%E5%88%9B%E5%BB%BA/"/>
    <id>https:mubai.site/2019-10-28-Application的创建、Activity的创建/</id>
    <published>2019-10-27T16:00:00.000Z</published>
    <updated>2020-05-07T08:27:31.948Z</updated>
    
    <content type="html"><![CDATA[<p> <em>关于Activity需要知道的更多内容</em></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Activity作为作为四大组件中我们最常见的一个组件，经常接触使用，但是往往每次让我们对这个组件进行说明的时候，我们只知道它的几个生命周期，几种启动模式，但是具体的更多的就讲不出来了。<br>ps：我在写这个之前实际上也是一知半解，所以今天我们一起去看看Activity更多的东西，源码版本为 android-26</p><ul><li>1、Application的创建</li><li>2、Activity的创建和生命周期</li></ul><h4 id="一、Application的创建"><a href="#一、Application的创建" class="headerlink" title="一、Application的创建"></a>一、Application的创建</h4><p>我们知道，java程序想运行都是通过调用main方法来启动，我们的Android应用程序也是如此，但是我们每次都是直接点击手机屏幕的应用图标就直接启动了app，这时候难免有疑惑，我们为什么不需要调用main方法就可以直接启动我们的程序呢，虽然我们没有直接的去写main方法，但是实际上还是通过ActivityThread类的main方法来作为我们应用程序的入口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># ActivityThread类</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        ...</span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line">        ActivityThread thread = new ActivityThread();//1、这边new了一个ActivityThread对象</span><br><span class="line">        thread.attach(false);//2、这边去进行连接，连接什么？</span><br><span class="line">        if (sMainThreadHandler == null) &#123;</span><br><span class="line">            sMainThreadHandler = thread.getHandler();</span><br><span class="line">        &#125;</span><br><span class="line">        if (false) &#123;</span><br><span class="line">            Looper.myLooper().setMessageLogging(new</span><br><span class="line">                    LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;));</span><br><span class="line">        &#125;</span><br><span class="line">        Looper.loop();</span><br><span class="line">        throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>在ActivityThread类中，能看到一个main方法，它就是我们程序的入口，在注释1的地方，会去创建一个ActivityThread对象，在注释2的地方，调用thread的attach方法去连接，具体的连接什么我们继续看下面的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#ActivityThread类</span><br><span class="line">private void attach(boolean system) &#123;</span><br><span class="line">      ...</span><br><span class="line">      if (!system) &#123;</span><br><span class="line">          ...</span><br><span class="line">          final IActivityManager mgr = ActivityManager.getService();//1、通过AIDL，获取AMS的代理对象IActivityManager</span><br><span class="line">          try &#123;</span><br><span class="line">              mgr.attachApplication(mAppThread);//2、这边将AMS和我们的应用进程application进行连接</span><br><span class="line">          &#125; catch (RemoteException ex) &#123;</span><br><span class="line">              throw ex.rethrowFromSystemServer();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          ...</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>关于AIDL，这边不进行展开，我们关心的是注释2，这边通过AIDL将AMS和我们应用进程application进行连接，具体的是调用ActivityManagerService的attachApplication方法进行连接。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#ActivityManagerService类</span><br><span class="line">@Override</span><br><span class="line">public final void attachApplication(IApplicationThread thread) &#123;</span><br><span class="line">      synchronized (this) &#123;</span><br><span class="line">          int callingPid = Binder.getCallingPid();//1、获取pid</span><br><span class="line">          final long origId = Binder.clearCallingIdentity();</span><br><span class="line">          attachApplicationLocked(thread, callingPid);//2、传入pid进行连接</span><br><span class="line">          Binder.restoreCallingIdentity(origId);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>这边的注释1通过Binder对象获取应用的pid，注释2处调用attachApplicationLocked的方法传入pid连接application。需要注意的这边加了synchronized关键字，表示我们需要等待这里执行完毕才能下一步，也就是说我们一个应用需要当我们application被连接后才能走下面的流程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">##ActivityManagerService</span><br><span class="line">private final boolean attachApplicationLocked(IApplicationThread thread,</span><br><span class="line">                                                  int pid, int callingUid, long startSeq) &#123;</span><br><span class="line">        ProcessRecord app;  //1、进程记录类，保存相关的信息</span><br><span class="line">        long startTime = SystemClock.uptimeMillis();</span><br><span class="line">        if (pid != MY_PID &amp;&amp; pid &gt;= 0) &#123;</span><br><span class="line">            synchronized (mPidsSelfLocked) &#123;</span><br><span class="line">                app = mPidsSelfLocked.get(pid);  //2、根据id获取相关信息赋值给记录对象</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        ...</span><br><span class="line">        if (app.instr != null) &#123;  //3、判断进程是否正在活跃</span><br><span class="line">           //Application 4、绑定到当前线程</span><br><span class="line">           thread.bindApplication(processName, appInfo, providers, app.instr.mClass,</span><br><span class="line">                    profilerInfo, app.instr.mArguments, app.instr.mWatcher, app.instr.mUiAutomationConnection,</span><br><span class="line">                    testMode, mBinderTransactionTrackingEnabled, enableTrackAllocation,</span><br><span class="line">                    isRestrictedBackupMode || !normalMode, app.persistent, new Configuration(getGlobalConfiguration()),</span><br><span class="line">                    app.compat, getCommonServicesLocked(app.isolated), mCoreSettingsObserver.getCoreSettingsLocked(),</span><br><span class="line">                    buildSerial, isAutofillCompatEnabled);   </span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //Application 4、绑定到当前线程</span><br><span class="line">            thread.bindApplication(processName, appInfo, providers, null, profilerInfo,</span><br><span class="line">                    null, null, null, testMode, mBinderTransactionTrackingEnabled,</span><br><span class="line">                    enableTrackAllocation, isRestrictedBackupMode || !normalMode, app.persistent,</span><br><span class="line">                    new Configuration(getGlobalConfiguration()), app.compat, getCommonServicesLocked(app.isolated),</span><br><span class="line">                    mCoreSettingsObserver.getCoreSettingsLocked(), buildSerial, isAutofillCompatEnabled);  </span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        // See if the top visible activity is waiting to run in this process...</span><br><span class="line">        //查看顶部可见活动是否正在等待在此进程中进行</span><br><span class="line">        if (normalMode) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                //TODO 5、Activity创建的分析</span><br><span class="line">                //检测top的Activity是否在运行中等待</span><br><span class="line">                if (mStackSupervisor.attachApattachApplicationplicationLocked(app)) &#123;</span><br><span class="line">                    didSomething = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                Slog.wtf(TAG, &quot;Exception thrown launching activities in &quot; + app, e);</span><br><span class="line">                badApp = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Find any services that should be running in this process...</span><br><span class="line">        //查看在此进程中进行的服务</span><br><span class="line">        if (!badApp) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                didSomething |= mServices.attachApplicationLocked(app, processName);</span><br><span class="line">                checkTime(startTime, &quot;attachApplicationLocked: after mServices.attachApplicationLocked&quot;);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                Slog.wtf(TAG, &quot;Exception thrown starting services in &quot; + app, e);</span><br><span class="line">                badApp = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Check if a next-broadcast receiver is in this process...</span><br><span class="line">        //查看在此进程中进行的广播接收者</span><br><span class="line">        if (!badApp &amp;&amp; isPendingBroadcastProcessLocked(pid)) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                didSomething |= sendPendingBroadcastsLocked(app);</span><br><span class="line">                checkTime(startTime, &quot;attachApplicationLocked: after sendPendingBroadcastsLocked&quot;);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                // If the app died trying to launch the receiver we declare it &apos;bad&apos;</span><br><span class="line">                Slog.wtf(TAG, &quot;Exception thrown dispatching broadcasts in &quot; + app, e);</span><br><span class="line">                badApp = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Check whether the next backup agent is in this process...</span><br><span class="line">        //检测下一个备份代理是否在此进程中</span><br><span class="line">        if (!badApp &amp;&amp; mBackupTarget != null &amp;&amp; mBackupTarget.app == app) &#123;</span><br><span class="line">            if (DEBUG_BACKUP) Slog.v(TAG_BACKUP,</span><br><span class="line">                    &quot;New app is backup target, launching agent for &quot; + app);</span><br><span class="line">            notifyPackageUse(mBackupTarget.appInfo.packageName,</span><br><span class="line">                    PackageManager.NOTIFY_PACKAGE_USE_BACKUP);</span><br><span class="line">            try &#123;</span><br><span class="line">                thread.scheduleCreateBackupAgent(mBackupTarget.appInfo,</span><br><span class="line">                        compatibilityInfoForPackageLocked(mBackupTarget.appInfo),</span><br><span class="line">                        mBackupTarget.backupMode);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                Slog.wtf(TAG, &quot;Exception thrown creating backup agent in &quot; + app, e);</span><br><span class="line">                badApp = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看具体的attachApplicationLocked方法里面，注释1处创建了一个进程记录对象用来保存进程的相关信息，注释2根据id获取到相关信息赋值给记录对象，注释3先判断进行是否活跃，然后调用bindApplication的方法进行application的绑定，这边的thread是IApplicationThread对象，IApplicationThread它是一个AIDL的接口，是系统进程调用应用进程的接口，它的实现类是ApplicationThread，是一个在ActivityThread的内部类，注释5的地方是关于Activity的创建，我们这边先跳过，等我们将Application进行绑定完成后在来分析。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">##ActivityThread.ApplicationThread</span><br><span class="line">public final void bindApplication(String processName, ApplicationInfo appInfo...，String buildSerial) &#123;</span><br><span class="line"></span><br><span class="line">            if (services != null) &#123;</span><br><span class="line">                // Setup the service cache in the ServiceManager</span><br><span class="line">                ServiceManager.initServiceCache(services);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            setCoreSettings(coreSettings);//1、添加核心设置</span><br><span class="line"></span><br><span class="line">            //2、将bindApplication带进来的信息封装到AppBindData类中，通过handler发送出去</span><br><span class="line">            AppBindData data = new AppBindData();</span><br><span class="line">            data.processName = processName;</span><br><span class="line">            data.appInfo = appInfo;</span><br><span class="line">            data.providers = providers;</span><br><span class="line">            ...</span><br><span class="line">            sendMessage(H.BIND_APPLICATION, data);//3、将data通过handler发送出去，具体的WHAT 是 H.BIND_APPLICATION</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><p>在注释1会去添加一些核心的设置，我们这边就不去关注，我们看注释2的地方，去将带进来的信息封装到data中然后在注释3通过handler发送出去，具体的WHAT 是 H.BIND_APPLICATION。H是一个继承Handler的子类，这边我们去看下消息是如何被分发处理的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">##ActivityThread.H</span><br><span class="line">public void handleMessage(Message msg) &#123;</span><br><span class="line">            ...</span><br><span class="line">        switch (msg.what) &#123;</span><br><span class="line">            ...</span><br><span class="line">           case BIND_APPLICATION:</span><br><span class="line">                    //1、这边进行handler消息的处理 处理创建Application的消息</span><br><span class="line">                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;bindApplication&quot;);</span><br><span class="line">                    AppBindData data = (AppBindData) msg.obj;</span><br><span class="line">                    handleBindApplication(data);</span><br><span class="line">                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                    break;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这边注释1处理创建Application的消息，调用handleBindApplication的方法去绑定application<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">##ActivityThread</span><br><span class="line">private void handleBindApplication(AppBindData data) &#123;</span><br><span class="line"></span><br><span class="line">      final InstrumentationInfo ii;//1、创建InstrumentationInfo对象</span><br><span class="line"></span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line">      final ContextImpl appContext = ContextImpl.createAppContext(this, data.info); 2、 //获取application的context上下文</span><br><span class="line">      </span><br><span class="line">      //  3、加载instrumentation</span><br><span class="line">      if (ii != null) &#123;</span><br><span class="line">          ...</span><br><span class="line">          </span><br><span class="line">          mInstrumentation.init(this, instrContext, appContext, component,</span><br><span class="line">                  data.instrumentationWatcher, data.instrumentationUiAutomationConnection); //4、instrumentation初始化</span><br><span class="line">          ...</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          mInstrumentation = new Instrumentation();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      try &#123;</span><br><span class="line">        </span><br><span class="line">          Application app = data.info.makeApplication(data.restrictedBackupMode, null);//5、通过makeApplication方法创建application</span><br><span class="line"></span><br><span class="line">          ...</span><br><span class="line">          </span><br><span class="line">          // Do this after providers, since instrumentation tests generally start their</span><br><span class="line">          // test thread at this point, and we don&apos;t want that racing.</span><br><span class="line">          try &#123;</span><br><span class="line">              mInstrumentation.onCreate(data.instrumentationArgs);</span><br><span class="line">          &#125; catch (Exception e) &#123;</span><br><span class="line">              throw new RuntimeException(</span><br><span class="line">                      &quot;Exception thrown in onCreate() of &quot;</span><br><span class="line">                              + data.instrumentationName + &quot;: &quot; + e.toString(), e);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          try &#123;</span><br><span class="line">              mInstrumentation.callApplicationOnCreate(app);//6、回调application的onCreate方法</span><br><span class="line">          &#125; catch (Exception e) &#123;</span><br><span class="line">              if (!mInstrumentation.onException(app, e)) &#123;</span><br><span class="line">                  throw new RuntimeException(</span><br><span class="line">                          &quot;Unable to create application &quot; + app.getClass().getName()</span><br><span class="line">                                  + &quot;: &quot; + e.toString(), e);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">          StrictMode.setThreadPolicy(savedPolicy);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>这个方法里面处理了许多事情，注释1创建了一个InstrumentationInfo对象，在注释2获取了application的上下文，注释3和4去加载并初始化了InstrumentationInfo，注释5是我们的关键地方，通过调用makeApplication的方法创建了我们的application，我们看下makeApplication的方法都做了什么操作。然后在注释6调用InstrumentationInfo去回调application的onCreate方法，到这里我们的application就创建并且回到了我们熟悉onCreate方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">##LoadedApk</span><br><span class="line">public Application makeApplication(boolean forceDefaultAppClass,</span><br><span class="line">           Instrumentation instrumentation) &#123;</span><br><span class="line">       if (mApplication != null) &#123;//1、如果mApplication不为null，直接返回mApplication对象</span><br><span class="line">           return mApplication;</span><br><span class="line">       &#125;</span><br><span class="line">     </span><br><span class="line">       Application app = null;</span><br><span class="line">      //如果是有自定义的application，就用这个，如果没有，就用系统的application</span><br><span class="line">       String appClass = mApplicationInfo.className;</span><br><span class="line">       if (forceDefaultAppClass || (appClass == null)) &#123;</span><br><span class="line">           appClass = &quot;android.app.Application&quot;;</span><br><span class="line">       &#125;</span><br><span class="line">       try &#123;</span><br><span class="line">           //2、获得类加载器然后通过反射去new一个Appliction</span><br><span class="line">           java.lang.ClassLoader cl = getClassLoader();</span><br><span class="line">           ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this);</span><br><span class="line">           app = mActivityThread.mInstrumentation.newApplication(</span><br><span class="line">                   cl, appClass, appContext);</span><br><span class="line">           appContext.setOuterContext(app);</span><br><span class="line">       &#125; catch (Exception e) &#123;</span><br><span class="line">           ...</span><br><span class="line">       &#125;</span><br><span class="line">       mActivityThread.mAllApplications.add(app);</span><br><span class="line">       mApplication = app;//3、赋值给mApplication</span><br><span class="line"></span><br><span class="line">       if (instrumentation != null) &#123;//4、这边会为instrumentation是为null的</span><br><span class="line">           try &#123;</span><br><span class="line">               instrumentation.callApplicationOnCreate(app);//5、这边如果instrumentation不为null，才能执行到这里</span><br><span class="line">           &#125; catch (Exception e) &#123;</span><br><span class="line">               if (!instrumentation.onException(app, e)) &#123;</span><br><span class="line">                  ...</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       ...</span><br><span class="line">       return app;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这边我们首先判断mApplication如果不为null，直接返回这个对象，如果为null的话，我们通过类加载然后反射去new出一个application对象并且赋值给mApplication，还有这边因为我们在调用makeApplication方法时传入的Instrumentation是个null对象，所以我们这边不会去执行<br>callApplicationOnCreate回调onCreate方法的。具体的回调onCreate会在上面的源码注释6的地方去执行回调。</p><h4 id="二、Activity的创建"><a href="#二、Activity的创建" class="headerlink" title="二、Activity的创建"></a>二、Activity的创建</h4><p>这边我们首先需要知道Activity的状态和生命周期</p><p>状态：运行、暂停、停止、销毁(运行和暂停是不可见的，停止和销毁是不可见的)<br>生命周期：包括了常见的onCreate、onResume、onStart、onPause、onStop、onDestory等</p><p>上面的分析过程中我们在ActivityManagerService类中留了一个<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">##ActivityManagerService</span><br><span class="line">private final boolean attachApplicationLocked(IApplicationThread thread,</span><br><span class="line">                                                  int pid, int callingUid, long startSeq) &#123;</span><br><span class="line">        ...</span><br><span class="line"> //5、检测最可见的Activity是否在运行进程中等待，如果再则创建Activity</span><br><span class="line">        //TODO 待分析Activity的创建</span><br><span class="line">        if (mStackSupervisor.attachApplicationLocked(app)) &#123;  </span><br><span class="line">            didSomething = true;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>这边我们对它进行深入下看看是如何创建的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">##ActivityStackSupervisor</span><br><span class="line">boolean attachApplicationLocked(ProcessRecord app) throws RemoteException &#123;</span><br><span class="line">       ...</span><br><span class="line">       for (int displayNdx = mActivityDisplays.size() - 1; displayNdx &gt;= 0; --displayNdx) &#123;</span><br><span class="line">           ArrayList&lt;ActivityStack&gt; stacks = mActivityDisplays.valueAt(displayNdx).mStacks;</span><br><span class="line">           for (int stackNdx = stacks.size() - 1; stackNdx &gt;= 0; --stackNdx) &#123;</span><br><span class="line">               final ActivityStack stack = stacks.get(stackNdx);</span><br><span class="line">               if (!isFocusedStack(stack)) &#123;</span><br><span class="line">                   continue;</span><br><span class="line">               &#125;</span><br><span class="line">               //ActivityRecord来维护Activity运行时的状态信息，需要将Activity绑定到AMS，ActivityRecord才能开始Activity的生命周期</span><br><span class="line">               ActivityRecord hr = stack.topRunningActivityLocked();</span><br><span class="line">               if (hr != null) &#123;</span><br><span class="line">                   if (hr.app == null &amp;&amp; app.uid == hr.info.applicationInfo.uid</span><br><span class="line">                           &amp;&amp; processName.equals(hr.processName)) &#123;</span><br><span class="line">                       try &#123;</span><br><span class="line">                           if (realStartActivityLocked(hr, app, true, true)) &#123;//1、真正的创建Activity</span><br><span class="line">                               didSomething = true;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125; catch (RemoteException e) &#123;</span><br><span class="line">                           throw e;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       ...</span><br><span class="line">       return didSomething;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>在realStartActivityLocked我们会创建Activity<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">##ActivityStackSupervisor</span><br><span class="line"> final boolean realStartActivityLocked(ActivityRecord r, ProcessRecord app,</span><br><span class="line">            boolean andResume, boolean checkConfig) throws RemoteException &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        r.startFreezingScreenLocked(app, 0);//1、开始屏幕相关的启动</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        // schedule launch ticks to collect information about slow apps.</span><br><span class="line">        r.startLaunchTickingLocked();//2、启动定时锁定</span><br><span class="line"></span><br><span class="line">        r.app = app;</span><br><span class="line">        app.waitingToKill = null;</span><br><span class="line">        r.launchCount++;//3、每启动一次launchCount的数量自增</span><br><span class="line">        r.lastLaunchTime = SystemClock.uptimeMillis();//4、修改最后一次的启动时间</span><br><span class="line"></span><br><span class="line">        final ActivityStack stack = task.getStack();</span><br><span class="line">        try &#123;</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            //5、根据具体的包名，通知应用</span><br><span class="line"></span><br><span class="line">         mService.notifyPackageUse(r.intent.getComponent().getPackageName(),</span><br><span class="line">                                      PackageManager.NOTIFY_PACKAGE_USE_ACTIVITY);</span><br><span class="line">            </span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            //6、调用ApplicationThread的scheduleLaunchActivity 方法去启动LaunchActivity</span><br><span class="line">            app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken,</span><br><span class="line">                    System.identityHashCode(r), r.info,</span><br><span class="line">                    // TODO: Have this take the merged configuration instead of separate global and</span><br><span class="line">                    // override configs.</span><br><span class="line">                    mergedConfiguration.getGlobalConfiguration(),</span><br><span class="line">                    mergedConfiguration.getOverrideConfiguration(), r.compat,</span><br><span class="line">                    r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle,</span><br><span class="line">                    r.persistentState, results, newIntents, !andResume,</span><br><span class="line">                    mService.isNextTransitionForward(), profilerInfo);</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        if (isFocusedStack(stack)) &#123;</span><br><span class="line">            mService.startSetupActivityLocked();7、开始设置活动锁</span><br><span class="line">        &#125;</span><br><span class="line">        if (r.app != null) &#123;</span><br><span class="line">            mService.mServices.updateServiceConnectionActivitiesLocked(r.app);//8、更新服务连接活动锁</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这边的注释很多，但是我们主要关心的是注释6，这边调用ApplicationThread的scheduleLaunchActivity 方法去启动LaunchActivity，我们回到ApplicationThread</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">##ActivityThread.ApplicationThread</span><br><span class="line">@Override</span><br><span class="line">public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident,</span><br><span class="line">                                       ..., ProfilerInfo profilerInfo) &#123;</span><br><span class="line"></span><br><span class="line">    updateProcessState(procState, false);</span><br><span class="line"></span><br><span class="line">    ActivityClientRecord r = new ActivityClientRecord();</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    sendMessage(H.LAUNCH_ACTIVITY, r);//通过handler发送启动Activity的消息</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这边是不是很眼熟，我们刚刚的application的绑定也是通过handler去发送消息去处理(这边我们能发现handler是有多么重要了吧，哈哈)，我们去ActivityThread的子类H去看下具体的activity创建的消息处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void handleMessage(Message msg) &#123;</span><br><span class="line">        switch (msg.what) &#123;</span><br><span class="line">            case LAUNCH_ACTIVITY: &#123;//1、接收到关于创建Activity的消息，进行处理</span><br><span class="line">                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityStart&quot;);</span><br><span class="line">                final ActivityClientRecord r = (ActivityClientRecord) msg.obj;</span><br><span class="line">                r.packageInfo = getPackageInfoNoCheck(</span><br><span class="line">                        r.activityInfo.applicationInfo, r.compatInfo);</span><br><span class="line">                handleLaunchActivity(r, null, &quot;LAUNCH_ACTIVITY&quot;);//2、去创建LaunchActivity</span><br><span class="line">                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>根据message的what值我们找到了具体的消息处理，这边会通过handleLaunchActivity去处理我们Activity创建<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">##ActivityThread</span><br><span class="line"> private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) &#123;</span><br><span class="line">        ...</span><br><span class="line">        Activity a = performLaunchActivity(r, customIntent);//1、去执行LaunchActivity</span><br><span class="line"></span><br><span class="line">        if (a != null) &#123;</span><br><span class="line">            r.createdConfig = new Configuration(mConfiguration);</span><br><span class="line">            reportSizeConfigurations(r);</span><br><span class="line">            Bundle oldState = r.state;</span><br><span class="line">            handleResumeActivity(r.token, false, r.isForward,</span><br><span class="line">                    !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason);//2、处理可见Activity</span><br><span class="line">            ...</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // If there was an error, for any reason, tell the activity manager to stop us.</span><br><span class="line">            try &#123;</span><br><span class="line">            //3、这边如何activity是个null的对象，直接通过ActivityManagerService调用finishActivity去关闭掉</span><br><span class="line">                ActivityManager.getService()</span><br><span class="line">                        .finishActivity(r.token, Activity.RESULT_CANCELED, null,</span><br><span class="line">                                Activity.DONT_FINISH_TASK_WITH_ACTIVITY);</span><br><span class="line">            &#125; catch (RemoteException ex) &#123;</span><br><span class="line">                throw ex.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这边我们先看注释1的performLaunchActivity方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">##ActivityThread</span><br><span class="line">private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        ActivityInfo aInfo = r.activityInfo;//1、获取Activity的信息</span><br><span class="line">        if (r.packageInfo == null) &#123;</span><br><span class="line">            r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo,</span><br><span class="line">                    Context.CONTEXT_INCLUDE_CODE);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        ContextImpl appContext = createBaseContextForActivity(r);//2、获取Acitivty的上下文</span><br><span class="line">        Activity activity = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            java.lang.ClassLoader cl = appContext.getClassLoader();//3、获取类加载器，使用cl(类加载器）加载出Activity，再使用反射new出Activity</span><br><span class="line">            activity = mInstrumentation.newActivity(</span><br><span class="line">                    cl, component.getClassName(), r.intent);</span><br><span class="line">            StrictMode.incrementExpectedActivityCount(activity.getClass());</span><br><span class="line">            r.intent.setExtrasClassLoader(cl);</span><br><span class="line">            r.intent.prepareToEnterProcess();</span><br><span class="line">            if (r.state != null) &#123;</span><br><span class="line">                r.state.setClassLoader(cl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">           ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            //4、这边又去调用一次makeApplication方法</span><br><span class="line">            Application app = r.packageInfo.makeApplication(false, mInstrumentation);</span><br><span class="line">            if (activity != null) &#123;</span><br><span class="line">                ...</span><br><span class="line">                appContext.setOuterContext(activity);</span><br><span class="line"></span><br><span class="line">                activity.attach(appContext, this, getInstrumentation(), r.token,</span><br><span class="line">                        r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">                        r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">                        r.referrer, r.voiceInteractor, window, r.configCallback);</span><br><span class="line"></span><br><span class="line">                ...</span><br><span class="line">                if (r.isPersistable()) &#123;//5、这边去调用Activity的onCreate方法</span><br><span class="line">                    mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">                &#125;</span><br><span class="line">                ...</span><br><span class="line"></span><br><span class="line">        &#125; catch (SuperNotCalledException e) &#123;</span><br><span class="line">            throw e;</span><br><span class="line"></span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">           ...</span><br><span class="line">        &#125;</span><br><span class="line">        return activity;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在注释3我们会发现这边是获取类加载去然后通过反射去new出一个Activity，然后在注释5去回调Activity的onCreate方法，到这边我们就能去调用我们的setContentView去加载布局了。注释4的地方又调用了一次makeApplication方法，如果Application不为null，直接返回application对象。<br>现在我们回到上一个源码的注释2那里，看看handleResumeActivity都做了什么?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">##ActivityThread</span><br><span class="line"> final void handleResumeActivity(IBinder token,</span><br><span class="line">                                    boolean clearHide, boolean isForward, boolean reallyResume, int seq, String reason) &#123;</span><br><span class="line">        ...</span><br><span class="line">        r = performResumeActivity(token, clearHide, reason);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这个方法里面有很多代码，我们只需要去看performResumeActivity方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">##ActivityThread</span><br><span class="line">public final ActivityClientRecord performResumeActivity(IBinder token, boolean clearHide, String reason) &#123;</span><br><span class="line">    ...</span><br><span class="line">    r.activity.performResume();//主要是这个方法</span><br><span class="line">    ...</span><br><span class="line">    return r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这边是调用Activity的performResume方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">##Activity</span><br><span class="line">final void performResume() &#123;</span><br><span class="line">        performRestart();</span><br><span class="line"></span><br><span class="line">        mFragments.execPendingActions();</span><br><span class="line"></span><br><span class="line">        mLastNonConfigurationInstances = null;</span><br><span class="line"></span><br><span class="line">        mCalled = false;</span><br><span class="line">        // mResumed is set by the instrumentation</span><br><span class="line">        mInstrumentation.callActivityOnResume(this);//回调Activity的onResume方法</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>到这边我们就能发现它跟Activity的onCreate的回调是类似的，都是通过mInstrumentation.callActivityxxx去回调执行。</p><h4 id="沿着别人走过的路，跟上去发现不一样的风景"><a href="#沿着别人走过的路，跟上去发现不一样的风景" class="headerlink" title="沿着别人走过的路，跟上去发现不一样的风景"></a>沿着别人走过的路，跟上去发现不一样的风景</h4><p>参考链接：<a href="https://www.jianshu.com/p/f55467033146" target="_blank" rel="noopener">https://www.jianshu.com/p/f55467033146</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; &lt;em&gt;关于Activity需要知道的更多内容&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;Activity作为作为四大组件中我们最常见的一个组件，经常接触使
      
    
    </summary>
    
      <category term="Android" scheme="https:mubai.site/categories/Android/"/>
    
    
      <category term="Android" scheme="https:mubai.site/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>5.1节日旅游攻略</title>
    <link href="https:mubai.site/2019-3-31-5.1%E6%97%85%E6%B8%B8%E6%94%BB%E7%95%A5/"/>
    <id>https:mubai.site/2019-3-31-5.1旅游攻略/</id>
    <published>2019-03-30T16:00:00.000Z</published>
    <updated>2019-04-03T08:48:06.696Z</updated>
    
    <content type="html"><![CDATA[<p>5.1节日旅游攻略、未完待续</p><a id="more"></a><h3 id="5-1节日旅游攻略"><a href="#5-1节日旅游攻略" class="headerlink" title="5.1节日旅游攻略"></a>5.1节日旅游攻略</h3><h4 id="第一站：乌镇"><a href="#第一站：乌镇" class="headerlink" title="第一站：乌镇"></a>第一站：乌镇</h4><pre><code>出发站：杭州出发时间：5.1 动车：        G7572：9:57    ￥21.5*2    G7316：10:12  ￥21.5*2时间：5.1-5.2酒店：乌镇小宿 ￥468门票：西栅+东栅联票 ￥190*2景点：列举了主要景点    1、西栅：最适合夜游及住宿的区域，夜晚的水上莲花可以look look        1.1、中国邮政：光绪年间的邮局        1.2、草木本色染坊：拍照        1.3、白莲塔：乌镇最高建筑        1.4、三寸金莲馆：中国女性裹足史        1.5、月老庙：许愿        1.6、邵明书院：邵明太子读书处        1.7、囍庆堂：江南婚礼        1.8、西市河：最美夜景地        1.9、天下第一锅：申请吉尼斯纪录        1.10、乌镇大剧院/大戏院：感受当地人文生活        1.11、茅盾纪念堂：纪念馆    2、东栅        2.1、茅盾故居：文学大师茅盾故居        2.2、宏源泰染坊：拍照        2.3、三白酒坊：酿酒过程        2.4、江南百床馆：中国第一家收藏、展出江南古床的博物馆        2.5、逢源双桥：按男左女右走一遍可以左右逢源        2.6、江南民俗馆：江南民俗文化展示        2.7、江南木雕陈列馆：古代木雕展览        2.8、财神湾：发财啊，去去去。        2.9、立志书院：茅盾的手稿、作品、提字        2.10、修真观广场        2.11、余榴梁钱币馆：各个国家的钱币展示    3、南栅和北栅都属于未开发的地段，原生态美食：找找看</code></pre><h4 id="第二站：苏州"><a href="#第二站：苏州" class="headerlink" title="第二站：苏州"></a>第二站：苏州</h4><pre><code>出发站：乌镇出发时间：5.2动车：        G7586：10：04    ￥85.5*2    G7572：10:126 ￥90.5*2时间：5.2-5.4酒店：苏州小院  ￥530*2景点：苏州景点太多    1、观前街        1.1、拙政园：天下园林之母，门票：70*2        1.2、苏州博物馆：苏州园林风格        1.3、平江路：苏州保存最好的古街        1.4、狮子林：叠石最有名，四大名园之一        1.5、苏州古典园林：世界文化遗产        1.6、太平天国忠王符：苏式彩绘    2、十全街        2.1、网师园：苏州四大名园之一        2.2、沧浪亭：苏州最古老园林        2.3、苏州大学：中国十大最美校园之一        2.4、苏州云岩寺塔：中国第一斜塔    3、石路商圈        3.1、虎丘：吴中第一名胜        3.2、七里山塘：姑苏第一名街        3.3、留园：小家碧玉式，四大名园之一        3.4、剑池：虎丘最神秘的名胜        3.5、万景山庄：苏派盆景精品园        3.6、山塘书院：听苏州评弹        3.7、拥翠山庄：苏州唯一无水园林    4、金鸡湖：        4.1、金鸡湖：骑行、夜景        4.2、月光码头：苏州十大最美夜景之首    5、周庄        5.1、周庄古镇：中国第一水乡        5.2、双桥：故乡的回忆蓝本        5.3、沈万三故居：沈万三        5.4、沈厅：沈万三后人的宅子        5.5、南湖秋月园：水中佛国        5.6、周庄博物馆：了解周庄历史        5.7、富安桥：周庄最古老的桥    6、同里        6.1、同里古镇：江南六大古镇之一        6.2、退思园：世界文化遗产        6.3、珍珠塔：同里最大园林        6.4、耕乐堂：同里八景之一    7、阳澄湖        7.1阳澄湖半岛旅游度假区：阳澄湖大闸蟹    8、太湖        8.1、苏州东山景区：太湖山水第一镇        8.2、苏州西山景区：太湖第一大岛美食：找找</code></pre><h4 id="终点站：杭州"><a href="#终点站：杭州" class="headerlink" title="终点站：杭州"></a>终点站：杭州</h4><pre><code>时间：5.4</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;5.1节日旅游攻略、未完待续&lt;/p&gt;
    
    </summary>
    
      <category term="闲文" scheme="https:mubai.site/categories/%E9%97%B2%E6%96%87/"/>
    
    
      <category term="闲文" scheme="https:mubai.site/tags/%E9%97%B2%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>Me</title>
    <link href="https:mubai.site/Me/"/>
    <id>https:mubai.site/Me/</id>
    <published>2019-02-19T16:00:00.000Z</published>
    <updated>2019-04-03T08:48:21.874Z</updated>
    
    <content type="html"><![CDATA[<p>个人简历，更新中</p><a id="more"></a><script src="https://cdn1.lncld.net/static/js/av-mini-0.6.10.js"></script><script src="http://jerry-cdn.b0.upaiyun.com/hit-kounter/hit-kounter-lc-0.2.0.js"></script><p><span data-hk-page="current"> - </span></p><h3 id="个人简历"><a href="#个人简历" class="headerlink" title="个人简历"></a>个人简历</h3><ul><li><strong>姓名：</strong> 林志文</li><li><strong>花名：</strong> 沐白</li><li><strong>Email：</strong> <a href="mailto:quickly520@126.com" target="_blank" rel="noopener">quickly520@126.com</a></li></ul><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><p>…</p><h4 id="工作经历"><a href="#工作经历" class="headerlink" title="工作经历"></a>工作经历</h4><ul><li><strong>杭州筑家易网络科技股份有限公司 2016.8-至今</strong></li></ul><ul><li><strong>杭州一幅画网络科技有限公司 2016.4-2016.7</strong></li></ul><h4 id="项目经历"><a href="#项目经历" class="headerlink" title="项目经历"></a>项目经历</h4><p>…</p><h4 id="自我评价"><a href="#自我评价" class="headerlink" title="自我评价"></a>自我评价</h4><p>…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;个人简历，更新中&lt;/p&gt;
    
    </summary>
    
    
      <category term="简历" scheme="https:mubai.site/tags/%E7%AE%80%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>物联网设备-WiFi/Bluetooth/ZigBee配网方式</title>
    <link href="https:mubai.site/2018-10-9-%E7%89%A9%E8%81%94%E7%BD%91%E9%80%9A%E4%BF%A1-WiFi:BT:ZigBee%E8%8A%AF%E7%89%87%E7%BA%A7%E6%96%B9%E6%A1%88%E8%A7%A3%E6%9E%90/"/>
    <id>https:mubai.site/2018-10-9-物联网通信-WiFi:BT:ZigBee芯片级方案解析/</id>
    <published>2018-10-08T16:00:00.000Z</published>
    <updated>2019-04-03T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、WIFI设备配网"><a href="#一、WIFI设备配网" class="headerlink" title="一、WIFI设备配网"></a>一、WIFI设备配网</h3><p>智能家居的设备智能化，很多家电设备都安装上了WiFi模块, 方便用户通过手机控制和远程查看家里情况，典型的设备如智能插座，智能空调，智能空气净化器。<br>智能设备首次配置，这个过程简单来讲就是把WiFi设备初始化后，连到家里的无线路由器上。第一次配置成功后，基本就一劳永逸了。</p><a id="more"></a><h4 id="1、目前流行的wifi配置模式一般有以下2种"><a href="#1、目前流行的wifi配置模式一般有以下2种" class="headerlink" title="1、目前流行的wifi配置模式一般有以下2种:"></a>1、目前流行的wifi配置模式一般有以下2种:</h4><ul><li><p>AP模式：</p><p>  智能硬件处于AP模式，手机用于station模式,手机连接智能插座的AP后组成局域网,手机发送需要连接路由的SSID及密码至智能插座,智能硬件主动去连接指定路由后,完成连接</p></li></ul><pre><code>AP（兼容） 模式AP 是 (Wireless) Access Point 的缩写，即 (无线) 访问接入点。简单来讲就像是无线路由器一样，设备打开后进入 AP 模式，在手机的网络列表里面，可以搜索到类似 TPLINK_XXX 的名字（SSID）。连接步骤：1、连接路由器（获取路由器名称）2、请求配网token，用户输入 WiFi 名字和密码后3、初始化硬件设备，使设备进入 AP 模式，Wifi 灯慢闪4、手机切回 WiFi：接入上述 设备出现的 WiFi 名字（SSID）的网络 （类似 TPLINK_XXX）。连上设备后，通过 UDP 发送 经过 AES 加密过的 ssid/password/token5、设备通过 UDP 包获取配置信息，切换网络模式，连接上家里 WiFi，配置完成。断开设备热点。发送token，注册到服务端，登录MQTT服务器6、手机切回到家里面的 WiFi ，根据token，去服务端查找设备。7、服务器返回智能设备的信息</code></pre><ul><li><p>一键配置(smartconfig)模式:</p><p>  智能硬件处于混杂模式下,监听网络中的所有报文;手机APP将SSID和密码编码到UDP报文中,通过广播包或组播报发送,智能硬件接收到UDP报文后解码,得到正确的SSID和密码,然后主动连接指定SSID的路由,完成连接</p><p>  EZ（快捷）Easy-Connect 模式</p><p>  这种快速连接方式，相对于 AP 模式连接简化操作，省了很多步骤，首次配置速度更快。</p><p>  1、手机连上 WiFi，开启 APP 软件，点击”添加新设备”，进入配置界面，输入手机所在 WiFi 密码，请求配网token</p><p>  2、智能硬件开启混杂模式监听所有网络数据包，Wifi 灯快闪</p><p>  3、手机通过广播、组播循环发送 ssid/password/token</p><p>  4、硬件设备通过 UDP 包（长度）获取配置信息捕捉到ssid/password/token，Wifi灯熄灭，连接路由器，连接成功后Wifi灯常亮。发送token，注册到服务端，注册成功后登录MQTT服务器。（广播根据 UDP 包长度，组播根据 IP 地址信息）</p><p>  5、手机根据token，去服务端查找设备，返回设备信息</p></li></ul><h4 id="2、当前主流IOT的wifi方案有"><a href="#2、当前主流IOT的wifi方案有" class="headerlink" title="2、当前主流IOT的wifi方案有:"></a>2、当前主流IOT的wifi方案有:</h4><p>这个功能最早是TI提出并应用于CC3200上;不过从原理上讲,只要芯片驱动支持开启混杂模式(WiFi Promiscuous),就可以支持一键配网功能,只是各个厂家叫法及实现编码方式不同而已;</p><p>手机编码发送采用有UDP组播或广播,不同的发送方式和编码,对应的解码过程也不一样.,当前测试发现,微信是通过UDP广播包实现的;TI是通过往一固定IP地址发送udp包;其他芯片厂家提供的一般为UDP组播方式;</p><p>由于无线数据传播必定是广播的,所以必然可以被监听到;如果AP没有加密的话,UDP直接可以把相关的信息发送出来.但是路由器AP一般都是加密的,而且加密方式不固定.wifi模块在无法直接解析出数据包</p><p>1、广播：发送方可通过改变其所需要发送数据包的长度进行控制<br>所以只要指定出一套利用长度编码的通讯协议,就可利用数据包的Lenght字段进行数据传递</p><p>2、 组播：组播地址是保留的D类地址从224.0.0.0-239.255.255.255<br>IP地址与MAC地址映射关系为:将MAC地址的前25位设定为01.00.5e,而MAC地址的后23位对应IP地址的位;故发送端可以将数据编码在组播ip的后23bit中,通过组播包发送,接收端进行解码即可</p><h3 id="二、Bluetooth配网"><a href="#二、Bluetooth配网" class="headerlink" title="二、Bluetooth配网"></a>二、Bluetooth配网</h3><h3 id="三、Zjgbee"><a href="#三、Zjgbee" class="headerlink" title="三、Zjgbee"></a>三、Zjgbee</h3><hr><p>参考资料：</p><p>Wifi:</p><blockquote><p>WLAN(Wireless Local Area Network)无线局域网络，是一个概念，网络技术术语，IEEE802.11标准是无线局域网最通用的标准<br>Wifi(Wireless Fidelity)是设备商成立的一个联盟，负责测试认证，是使用802.11技术实现的</p></blockquote><p>ZjgBee:</p><blockquote><p>目前在国内采用ZigBee协议智能家居的有3家公司的芯片，恩智浦（NXP）公司（小米智能家居采用的就是该公司的ZigBee芯片），TI公司（德州仪器）CC2530芯片（国内95%以上的公司采用该ZigBee芯片），芯科（Silicon Labs）公司（国内只有极少数公司采用该公司芯片，如聪明屋智能家居采用的是该公司的EM357芯片），该芯片属于ZigBee芯片领域的工业级高性能级别，应用到智能家居居有绝对的优势，规避了传统ZigBee芯片智能家居组网规模小、易丢包不稳定的顽疾。事实证明芯科芯片的智能网关，在保证智能家居系统稳定运行的前提下可以携带120个以上的节点，TI和恩智浦的只能带30个以内的节点。<br>另外芯科（Silicon Labs）公司又发布EFR32MG系列ZigBee芯片，其中部分芯片能同时支持4种无线协议：ZigBee、Thread、BLE（蓝牙）、Proprietary（sub GHZ，小无线），说通俗一点就是用芯科（Silicon Labs）ZigBee芯片开发的ZigBee智能家居可以兼容Thread、BLE（蓝牙）、Proprietary（sub GHZ，小无线）这3种通讯协议的产品，能和这3种通信协议的设备互联互通，技术创新遥遥领先，所以说要做好ZigBee技术智能家居，芯片选择至关重要。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、WIFI设备配网&quot;&gt;&lt;a href=&quot;#一、WIFI设备配网&quot; class=&quot;headerlink&quot; title=&quot;一、WIFI设备配网&quot;&gt;&lt;/a&gt;一、WIFI设备配网&lt;/h3&gt;&lt;p&gt;智能家居的设备智能化，很多家电设备都安装上了WiFi模块, 方便用户通过手机控制和远程查看家里情况，典型的设备如智能插座，智能空调，智能空气净化器。&lt;br&gt;智能设备首次配置，这个过程简单来讲就是把WiFi设备初始化后，连到家里的无线路由器上。第一次配置成功后，基本就一劳永逸了。&lt;/p&gt;
    
    </summary>
    
      <category term="物联网" scheme="https:mubai.site/categories/%E7%89%A9%E8%81%94%E7%BD%91/"/>
    
    
      <category term="物联网" scheme="https:mubai.site/tags/%E7%89%A9%E8%81%94%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>Nexus+Maven搭建私有库</title>
    <link href="https:mubai.site/2018-7-12-Nexus+Maven%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E5%BA%93/"/>
    <id>https:mubai.site/2018-7-12-Nexus+Maven搭建私有库/</id>
    <published>2018-07-11T16:00:00.000Z</published>
    <updated>2019-04-03T08:47:42.234Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Maven：项目管理和自动构建的工具,maven包集中存放的地方就是maven仓库。这些仓库可以放在本地，也可以放在某个远程服务器上，可以是私有的，也可以是共有的。</p></blockquote><blockquote><p>Nexus：强大的maven仓库管理器，简化了本地仓库的维护和外部仓库的访问</p></blockquote><a id="more"></a><h5 id="1-下载安装Nexus3-0"><a href="#1-下载安装Nexus3-0" class="headerlink" title="1.下载安装Nexus3.0"></a>1.下载安装Nexus3.0</h5><p>nexus的下载地址：<strong><a href="https://blog.sonatype.com/" target="_blank" rel="noopener">https://blog.sonatype.com/</a></strong></p><h5 id="2-启动Nexus"><a href="#2-启动Nexus" class="headerlink" title="2.启动Nexus"></a>2.启动Nexus</h5><p>将下载后的zip解压到某个路径下执行</p><blockquote><p>/Users/***/nexus-3.12.1-01-mac/nexus-3.12.1-01/bin/nexus start</p></blockquote><p>执行成功后</p><blockquote><p>Starting nexus</p></blockquote><h5 id="3-浏览器打开Nexus"><a href="#3-浏览器打开Nexus" class="headerlink" title="3.浏览器打开Nexus"></a>3.浏览器打开Nexus</h5><p><strong><a href="http://127.0.0.1:8081/nexus/" target="_blank" rel="noopener">http://127.0.0.1:8081/nexus/</a></strong></p><blockquote><p>注：启动服务需要等待一会</p></blockquote><h5 id="4-用户登录"><a href="#4-用户登录" class="headerlink" title="4.用户登录"></a>4.用户登录</h5><p>默认的是游客身份，可以查看，但是不能配置<br>需要配置的时候使用管理员身份登录：</p><blockquote><p><strong>admin/admin123</strong></p></blockquote><h5 id="5-Blob-Stroes"><a href="#5-Blob-Stroes" class="headerlink" title="5.Blob Stroes"></a>5.Blob Stroes</h5><p>依赖index存储目录，默认存储在default下：</p><p>\sonatype-work\nexus3\blobs\default</p><p>也可以自己新建一个目录专门存在某个仓库的索引，在创建repository可以选择</p><h5 id="6-reponsitory"><a href="#6-reponsitory" class="headerlink" title="6.reponsitory"></a>6.reponsitory</h5><p>Nexus默认创建了几个仓库<br>group:是一个仓库组，包含了hosted和proxy两种库，下载时按配置顺序从中依次查找<br>hosted:一般是部署我们项目打包的jar，供内部人员下载<br>proxy：代理远程仓库，maven-central是默认maven中央仓库代理，通过代理从远程仓库中下载的依赖都会被缓存到nexus的proxy库中</p><h5 id="7-创建自己的reponsitory"><a href="#7-创建自己的reponsitory" class="headerlink" title="7.创建自己的reponsitory"></a>7.创建自己的reponsitory</h5><p>一般情况下我们会选择创建一个hosted仓库</p><p>步骤为<em>repositories –&gt; Add –&gt; hosted repository</em>，在页面的下半部分输入框中填入repository id和repository name即可，另外把deployment policy设置为Allow Redeploy，点击save就创建完成了</p><p>这边我们可以看到我们创建成功的reponsitory，这里有个仓库的地址<br><strong><a href="http://127.0.0.1:8081/repository/test-comment-release/" target="_blank" rel="noopener">http://127.0.0.1:8081/repository/test-comment-release/</a></strong><br>可以复制出来</p><h5 id="8-创建完成后我们在androidStudio创建一个项目，项目中创建一个model"><a href="#8-创建完成后我们在androidStudio创建一个项目，项目中创建一个model" class="headerlink" title="8.创建完成后我们在androidStudio创建一个项目，项目中创建一个model"></a>8.创建完成后我们在androidStudio创建一个项目，项目中创建一个model</h5><p>在根目录的build.gradle的repositories中添加：</p><p><strong>maven{ url ‘<a href="http://127.0.0.1:8081/repository/test-comment-release/&#39;}" target="_blank" rel="noopener">http://127.0.0.1:8081/repository/test-comment-release/&#39;}</a></strong></p><p>然后在model的build.gradle中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">uploadArchives &#123;</span><br><span class="line">    configuration = configurations.archives</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenDeployer &#123;</span><br><span class="line">            snapshotRepository(url: MAVEN_REPO_SNAPSHOT_URL) &#123;</span><br><span class="line">                authentication(userName: NEXUS_USERNAME, password: NEXUS_PASSWORD)</span><br><span class="line">            &#125;</span><br><span class="line">            repository(url: MAVEN_REPO_RELEASE_URL) &#123;</span><br><span class="line">                authentication(userName: NEXUS_USERNAME, password: NEXUS_PASSWORD)</span><br><span class="line">            &#125;</span><br><span class="line">            pom.project &#123;</span><br><span class="line">                version &apos;1.0.0&apos;//版本号可以直接指定</span><br><span class="line">                artifactId &apos;comment-sdk&apos;//这边的id我们可以指定</span><br><span class="line">                groupId GROUP_ID</span><br><span class="line">                packaging TYPE</span><br><span class="line">                description DESCRIPTION</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">artifacts &#123;</span><br><span class="line">    archives file(&apos;model名称.aar&apos;)//我们的model名.aar</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意的是需要在model的build.gradle中添加(使得这个model可以作为maven)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &apos;maven&apos;</span><br></pre></td></tr></table></figure><h5 id="9-在gradle-properties中添加："><a href="#9-在gradle-properties中添加：" class="headerlink" title="9.在gradle.properties中添加："></a>9.在gradle.properties中添加：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Maven仓库的URL</span><br><span class="line">MAVEN_REPO_RELEASE_URL=http://127.0.0.1:8081/repository/mubai-comment-release/  这边是正式的仓库的地址</span><br><span class="line">MAVEN_REPO_SNAPSHOT_URL=http://127.0.0.1:8081/repository/mubai-comment-snapshot/  这边是snapshot的仓库的地址</span><br><span class="line"></span><br><span class="line"># 对应maven的GroupId的值</span><br><span class="line">GROUP = com.comment.sdk  这边我们可以自己指定</span><br><span class="line">##### 登录nexus ossde的用户名</span><br><span class="line"></span><br><span class="line">NEXUS_USERNAME=admin</span><br><span class="line"># 登录nexus oss的密码</span><br><span class="line"></span><br><span class="line">NEXUS_PASSWORD=admin123</span><br><span class="line"></span><br><span class="line"># groupid</span><br><span class="line">GROUP_ID = com.comment.sdk  这边我们可以自己指定</span><br><span class="line"></span><br><span class="line"># type</span><br><span class="line">TYPE = aar</span><br><span class="line"></span><br><span class="line"># description</span><br><span class="line">DESCRIPTION = This is comment sdk 描述</span><br></pre></td></tr></table></figure><p>然后点击右侧的Gradle找到我们需要上传的model，然后里面的upload中的<strong>uploadArchives</strong>双击，然后等待上传aar成功</p><h5 id="10-上传成功后我们可以在nexus上看到我们的上传的aar"><a href="#10-上传成功后我们可以在nexus上看到我们的上传的aar" class="headerlink" title="10.上传成功后我们可以在nexus上看到我们的上传的aar"></a>10.上传成功后我们可以在nexus上看到我们的上传的aar</h5><h5 id="11-然后我们在需要用到的项目中，先去根目录build的地方添加："><a href="#11-然后我们在需要用到的项目中，先去根目录build的地方添加：" class="headerlink" title="11.然后我们在需要用到的项目中，先去根目录build的地方添加："></a>11.然后我们在需要用到的项目中，先去根目录build的地方添加：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">maven&#123; url &apos;http://可以换成服务器的ip地址:8081/repository/mubai-comment-release/&apos;&#125;</span><br></pre></td></tr></table></figure><p>然后在具体的app的build中添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#前面是我们GROUP_ID:ArtifactId:版本号(这些id我们都可以自己在配置的时候去指定)</span><br><span class="line">compile &apos;com.comment.sdk:comment-sdk-debug:1.1.0&apos;</span><br></pre></td></tr></table></figure><p>然后我们就可以引用我们aar包里面的东西</p><p><strong>实际上使用nexus只是作为一个管理aar包的托管服务器，我们在利用gradle将aar包上传到nexus上面</strong></p><hr><p>补充说明：</p><p>maven仓库地址和ID的命名规则</p><p>正式仓库地址：<br><strong>MAVEN_REPO_RELEASE_URL=<a href="http://192.168.1.20:8081/nexus/content/groups/app-public/" target="_blank" rel="noopener">http://192.168.1.20:8081/nexus/content/groups/app-public/</a></strong></p><p>快照仓库地址：<br><strong>MAVEN_REPO_SNAPSHOT_URL=<a href="http://192.168.1.20:8081/nexus/content/repositories/snapshots/" target="_blank" rel="noopener">http://192.168.1.20:8081/nexus/content/repositories/snapshots/</a></strong></p><p><strong>GroupId:  com.zjy.iot.app</strong></p><p><strong>artifactId ‘iot-app-xxx-sdk’</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Maven：项目管理和自动构建的工具,maven包集中存放的地方就是maven仓库。这些仓库可以放在本地，也可以放在某个远程服务器上，可以是私有的，也可以是共有的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Nexus：强大的maven仓库管理器，简化了本地仓库的维护和外部仓库的访问&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Android" scheme="https:mubai.site/categories/Android/"/>
    
    
      <category term="Maven" scheme="https:mubai.site/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>Android Gradle</title>
    <link href="https:mubai.site/2018-2-26-Android%20Gradle%20%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https:mubai.site/2018-2-26-Android Gradle 中遇到的问题/</id>
    <published>2018-02-25T16:00:00.000Z</published>
    <updated>2019-04-03T08:47:32.682Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Failed to resolve: xxx.xxx.xxx:xxx:x.x.x Show in File Show in Project Structure dialog</span><br></pre></td></tr></table></figure><p>有时候在我们创建项目引入一个新的依赖或者打开一个从网上clone下来的项目的时候会遇到这样的问题</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Failed to resolve: xxx.xxx.xxx:xxx:x.x.x Show in File Show in Project Structure dialog&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;有时候在我们创建项目引入一个新的依赖或者打开一个从网上clone下来的项目的时候会遇到这样的问题&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https:mubai.site/categories/Android/"/>
    
    
      <category term="Android" scheme="https:mubai.site/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android9.0曝光新特性</title>
    <link href="https:mubai.site/2018-2-5-Android9.0%E6%9B%9D%E5%85%89%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>https:mubai.site/2018-2-5-Android9.0曝光新特性/</id>
    <published>2018-02-04T16:00:00.000Z</published>
    <updated>2019-04-03T08:47:21.589Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>安卓9.0将加入电话录音功能：提高通话安全性</p><p>通话录音是目前许多手机都有的功能，但安卓原生系统并没有自带这项功能。</p></blockquote><a id="more"></a><p>据外媒<strong>Android Headlines</strong>消息称，发现Google在下个安卓开放源代码（AOSP）中发现新的代码，(此代码可能指向记录录音功能)说明下个安卓版本将会具有记录录音功能。</p><p>据悉，原声<strong>Android9.0</strong>的版本可以提供通话录音，而且通过提示用户进行操作，并且双方在通话的过程中，手机系统每15秒钟会发出一次蜂鸣声(手机将会把频率为1400Hz、每15秒钟重复一次的提示音添加到通话中，该声音将会被通话双方都听到，让对方确认你正在录音)，这种声音是提示呼叫者他们的对话正在被录音。</p><p>为了保证安全性，这段录音文件极有可能会存在Google云服务器中(话说国内如何访问呢…)</p><p>另外，据说<strong>Android9.0</strong>会提高系统的封闭性，让一些高度自由化的操作断绝掉(比如高权限插件、自动签到、个性化UI定制等)，整体的系统机制向iOS靠拢，对于用户来说只能说是喜忧参半，采用封闭机制，APP自启动、高敏感权限申请，等不再会出现，安全性、流畅度、稳定性都将大幅提升，但是却要牺牲原本的可玩性，只能说鱼与熊掌不能兼得吧！</p><p>当然对于开发者来说，提高系统的封闭性后，缺点在于我们对于一些需要的权限、操作需要更多的实现代码，同时原本的一些功能需要通过不同的方式方法实现，好处在于我们可以开发出安全性、稳定性更高的App！</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;安卓9.0将加入电话录音功能：提高通话安全性&lt;/p&gt;
&lt;p&gt;通话录音是目前许多手机都有的功能，但安卓原生系统并没有自带这项功能。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Android" scheme="https:mubai.site/categories/Android/"/>
    
    
      <category term="Android" scheme="https:mubai.site/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android各大应用商店应用图标、截图尺寸</title>
    <link href="https:mubai.site/2018-2-5-Android%E5%90%84%E5%A4%A7%E5%95%86%E5%BA%97%E5%BA%94%E7%94%A8%E5%9B%BE%E6%A0%87%E3%80%81%E6%88%AA%E5%9B%BE%E5%B0%BA%E5%AF%B8/"/>
    <id>https:mubai.site/2018-2-5-Android各大商店应用图标、截图尺寸/</id>
    <published>2018-02-04T16:00:00.000Z</published>
    <updated>2019-04-03T08:47:27.494Z</updated>
    
    <content type="html"><![CDATA[<h3 id="360"><a href="#360" class="headerlink" title="360"></a>360</h3><ul><li>应用图标：512 * 512png</li><li>应用截图：480 * 800 5张 png</li></ul><a id="more"></a><h3 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h3><ul><li>应用图标：512*512 png</li><li>应用截图：480 * 800 5张 </li></ul><h3 id="腾讯"><a href="#腾讯" class="headerlink" title="腾讯"></a>腾讯</h3><ul><li>应用图标：16 <em> 16一张，512 </em> 512一张 png</li><li>应用截图：480 * 800 5张 png</li></ul><h3 id="华为"><a href="#华为" class="headerlink" title="华为"></a>华为</h3><ul><li>应用图标：16 <em> 16一张，512 </em> 512一张 png</li><li>应用截图：480 * 800 5张 png</li></ul><h3 id="魅族"><a href="#魅族" class="headerlink" title="魅族"></a>魅族</h3><ul><li>应用图标：16 <em> 16一张，512 </em> 512一张 png</li><li>应用截图：480 * 800 5张 png</li></ul><h3 id="Oppo"><a href="#Oppo" class="headerlink" title="Oppo"></a>Oppo</h3><ul><li>应用图标：16 <em> 16一张，512 </em> 512一张 png</li><li>应用截图：480 * 800 5张 png</li></ul><h3 id="Vivo"><a href="#Vivo" class="headerlink" title="Vivo"></a>Vivo</h3><ul><li>应用图标：16 <em> 16一张，512 </em> 512一张 png</li><li>应用截图：480 * 800 5张 png</li></ul><h3 id="锤子"><a href="#锤子" class="headerlink" title="锤子"></a>锤子</h3><ul><li>应用图标：16 <em> 16一张，512 </em> 512一张 png</li><li>应用截图：480 * 800 5张 png</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;360&quot;&gt;&lt;a href=&quot;#360&quot; class=&quot;headerlink&quot; title=&quot;360&quot;&gt;&lt;/a&gt;360&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;应用图标：512 * 512png&lt;/li&gt;
&lt;li&gt;应用截图：480 * 800 5张 png&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Android" scheme="https:mubai.site/categories/Android/"/>
    
    
      <category term="Android" scheme="https:mubai.site/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>TensorFlow入门</title>
    <link href="https:mubai.site/2018-2-3-TensorFlow%E5%85%A5%E9%97%A8/"/>
    <id>https:mubai.site/2018-2-3-TensorFlow入门/</id>
    <published>2018-02-02T16:00:00.000Z</published>
    <updated>2019-04-03T08:47:14.943Z</updated>
    
    <content type="html"><![CDATA[<h4 id="MNIST机器学习入门"><a href="#MNIST机器学习入门" class="headerlink" title="MNIST机器学习入门"></a><a href="http://wiki.jikexueyuan.com/project/tensorflow-zh/tutorials/mnist_beginners.html" target="_blank" rel="noopener">MNIST机器学习入门</a></h4><p>MNIST:机器学习的入门，是一个入门级的计算机视觉数据集，包含了2部分：</p><ul><li>手写的数字图片</li><li>数字图片对应的标签</li></ul><a id="more"></a><p>MNIST数据集：官网地址是<a href="http://yann.lecun.com/exdb/mnist/" target="_blank" rel="noopener">Yann LeCun’s website</a><br>下载下来的数据集被分成了2部分：60000行的训练数据集(mnist.train)和10000行的测试数据集(mnist.test)</p><blockquote><p>这么切分的好处在于：在机器学习模式设计时必须有一个单独的测试数据集不用与训练而是用来评估这个模型的性能，从而更加容易把设计的模型推广到其他数据集上(泛化)</p></blockquote><hr><p>参考链接</p><p><a href="http://tensorflow.org/" target="_blank" rel="noopener">英文官方网站</a></p><p><a href="http://wiki.jikexueyuan.com/project/tensorflow-zh/" target="_blank" rel="noopener">TensorFlow 官方文档中文版</a></p><p><a href="https://github.com/tensorflow/tensorflow" target="_blank" rel="noopener">英文版GithHub仓库</a></p><p><a href="https://github.com/jikexueyuanwiki/tensorflow-zh" target="_blank" rel="noopener">中文版GithHub仓库</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;MNIST机器学习入门&quot;&gt;&lt;a href=&quot;#MNIST机器学习入门&quot; class=&quot;headerlink&quot; title=&quot;MNIST机器学习入门&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://wiki.jikexueyuan.com/project/tensorflow-zh/tutorials/mnist_beginners.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MNIST机器学习入门&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;MNIST:机器学习的入门，是一个入门级的计算机视觉数据集，包含了2部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;手写的数字图片&lt;/li&gt;
&lt;li&gt;数字图片对应的标签&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="机器学习" scheme="https:mubai.site/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="https:mubai.site/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Android仓库托管平台</title>
    <link href="https:mubai.site/2018-2-1-Android%E4%BB%93%E5%BA%93%E6%89%98%E7%AE%A1%E5%B9%B3%E5%8F%B0/"/>
    <id>https:mubai.site/2018-2-1-Android仓库托管平台/</id>
    <published>2018-01-31T16:00:00.000Z</published>
    <updated>2019-04-03T08:46:57.904Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Android-Library的托管平台介绍"><a href="#Android-Library的托管平台介绍" class="headerlink" title="Android Library的托管平台介绍"></a>Android Library的托管平台介绍</h4><blockquote><p>Android Studio是从build.gradle里面定义的Maven仓库服务器上下载library</p></blockquote><a id="more"></a><p>在build.gradle中会看到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()//使用Jcenter作为Maven</span><br><span class="line">        mavenCentral()//使用mavenCentral作为Maven</span><br><span class="line">        maven &#123;//自定义maven</span><br><span class="line">            url &apos;https://maven.google.com/&apos;</span><br><span class="line">            name &apos;Google&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过</p><ul><li><p>Jcenter</p><blockquote><p>Jcenter是一个由bintray.com维护的Maven仓库</p></blockquote></li><li><p>mavenCentral</p><blockquote><p>MavenCentral是由sonatype.org维护的Maven仓库</p></blockquote></li><li><p>maven { url ‘自己的仓库服务器地址’ }</p><blockquote><p>有时候会将library放在自己的服务器上，这时候就需要我们添加maven地址</p></blockquote></li></ul><p>但是一般来说我们只会使用<strong>Jcenter</strong>和<strong>mavenCentral</strong>，毕竟自己维护一个服务器地址成本较高，而且对于使用者来说他们只需要添加代码的依赖地址</p><blockquote><p>实际上除了Maven仓库外还有另外一种仓库：<a href="http://ant.apache.org/ivy/" target="_blank" rel="noopener">Ivy仓库</a></p></blockquote><h4 id="Jcenter和mavenCentral比较"><a href="#Jcenter和mavenCentral比较" class="headerlink" title="Jcenter和mavenCentral比较"></a>Jcenter和mavenCentral比较</h4><p>两个仓库都具有相同的使命：提供Java或者Android的Library服务</p><p>最开始的时候，AndroidStudio选择<strong>MavenCentral</strong>作为默认仓库，后来由于<strong>MavenCentral</strong>的不友好，对于开发者上传Library很难，同时由于其他的种种原因，AndroidStudio决定把<strong>MavenCentral</strong>换成<strong>Jcenter</strong></p><pre><code>* jcenter通过CDN发送library，开发者可以享受到更快的下载体验。* jcenter是全世界最大的Java仓库，因此在Maven Central 上有的 在jcenter上也极有可能有。换句话说jcenter是Maven Central的超集。* 上传library到仓库很简单，不需要像在 Maven Central上做很多复杂的事情* 友好的用户界面</code></pre><hr><blockquote><p>其他相关问题</p></blockquote><ul><li>如果要了解如何发布自己的library到Jcenter，可以查看<a href="http://mubai.site/%E9%A1%B9%E7%9B%AE%E5%8F%91%E5%B8%83%E5%88%B0%E5%85%AC%E5%85%B1%E7%9A%84jcenter%E4%BB%93%E5%BA%93/" target="_blank" rel="noopener">发布Library到Jcenter</a></li><li>有时候我们通过Jcenter依赖Library的时候加载很慢，可以查看<a href="http://blog.csdn.net/xiongbatianxia30146/article/details/63686359" target="_blank" rel="noopener">解决JCenter下载太慢的问题</a>来解决</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Android-Library的托管平台介绍&quot;&gt;&lt;a href=&quot;#Android-Library的托管平台介绍&quot; class=&quot;headerlink&quot; title=&quot;Android Library的托管平台介绍&quot;&gt;&lt;/a&gt;Android Library的托管平台介绍&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;Android Studio是从build.gradle里面定义的Maven仓库服务器上下载library&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Android" scheme="https:mubai.site/categories/Android/"/>
    
    
      <category term="Android" scheme="https:mubai.site/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>项目发布到jcenter仓库</title>
    <link href="https:mubai.site/2018-1-25-Jcenter%20/"/>
    <id>https:mubai.site/2018-1-25-Jcenter /</id>
    <published>2018-01-24T16:00:00.000Z</published>
    <updated>2019-04-03T08:46:50.286Z</updated>
    
    <content type="html"><![CDATA[<h3 id="项目所需的步骤"><a href="#项目所需的步骤" class="headerlink" title="项目所需的步骤"></a>项目所需的步骤</h3><h4 id="一、添加插件"><a href="#一、添加插件" class="headerlink" title="一、添加插件"></a>一、添加插件</h4><h5 id="在项目目录的build-gradle-中的-dependencies-添加："><a href="#在项目目录的build-gradle-中的-dependencies-添加：" class="headerlink" title="在项目目录的build.gradle 中的 dependencies 添加："></a>在项目目录的build.gradle 中的 dependencies 添加：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">classpath &quot;com.jfrog.bintray.gradle:gradle-bintray-plugin:1.5&quot; </span><br><span class="line">classpath &apos;com.github.dcendents:android-maven-gradle-plugin:1.4.1&apos;</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="二、配置gradle"><a href="#二、配置gradle" class="headerlink" title="二、配置gradle"></a>二、配置gradle</h4><h5 id="同时在需要添加到jcenter的libary的build-gradle根目录添加："><a href="#同时在需要添加到jcenter的libary的build-gradle根目录添加：" class="headerlink" title="同时在需要添加到jcenter的libary的build.gradle根目录添加："></a>同时在需要添加到jcenter的libary的build.gradle根目录添加：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &apos;com.github.dcendents.android-maven&apos; </span><br><span class="line">apply plugin: &apos;com.jfrog.bintray&apos;</span><br><span class="line">version = &quot;1.0.1&quot; //这里的version是可以更新的版本号*</span><br></pre></td></tr></table></figure><h5 id="1-在local-properties添加用户名和key"><a href="#1-在local-properties添加用户名和key" class="headerlink" title="(1)在local.properties添加用户名和key"></a>(1)在local.properties添加用户名和key</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bintray.user=openproject </span><br><span class="line">// your bintrayuser name </span><br><span class="line">bintray.apikey=****** </span><br><span class="line">// your bintray api key`</span><br></pre></td></tr></table></figure><h5 id="2-继续在根目录添加："><a href="#2-继续在根目录添加：" class="headerlink" title="(2)继续在根目录添加："></a>(2)继续在根目录添加：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def siteUrl = &apos;https://github.com/MoMuBai/Test&apos; </span><br><span class="line">// #修改# // 项目的主页地址，我这里是我的PickerView项目在github的链接地址 </span><br><span class="line">def gitUrl = &apos;https://github.com/MoMuBai/Test.git&apos; </span><br><span class="line">// #修改# // 项目 git 地址，我这里同样是用Github上的git地址 </span><br><span class="line">group = &quot;com.mubai&quot; </span><br><span class="line">// #修改# // 组名称</span><br></pre></td></tr></table></figure><h5 id="3-打包javadocjar和sourcejar"><a href="#3-打包javadocjar和sourcejar" class="headerlink" title="(3)打包javadocjar和sourcejar"></a>(3)打包javadocjar和sourcejar</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">install &#123; </span><br><span class="line">    repositories.mavenInstaller &#123;</span><br><span class="line">        // This generates POM.xml with proper parameters</span><br><span class="line">        pom &#123;</span><br><span class="line">            project &#123;</span><br><span class="line">                packaging &apos;aar&apos;</span><br><span class="line">                name &apos;Less Code For Android&apos;</span><br><span class="line">                url siteUrl</span><br><span class="line">                licenses &#123;</span><br><span class="line">                    license &#123;</span><br><span class="line">                        name &apos;The Apache Software License, Version 2.0&apos;</span><br><span class="line">                        url &apos;http://www.apache.org/licenses/LICENSE-2.0.txt&apos;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                developers &#123;</span><br><span class="line">                    developer &#123;</span><br><span class="line">                        id &apos;mubai&apos;</span><br><span class="line">                        name &apos;mubai.lzw&apos;</span><br><span class="line">                        email &apos;quickly520@126.com&apos;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                scm &#123;</span><br><span class="line">                    connection gitUrl</span><br><span class="line">                    developerConnection gitUrl</span><br><span class="line">                    url siteUrl</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-打包javadocjar和sourcejar"><a href="#4-打包javadocjar和sourcejar" class="headerlink" title="(4)打包javadocjar和sourcejar"></a>(4)打包javadocjar和sourcejar</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">task sourcesJar(type: Jar) &#123;</span><br><span class="line">    from android.sourceSets.main.java.srcDirs</span><br><span class="line">    classifier = &apos;sources&apos;</span><br><span class="line">&#125;</span><br><span class="line">task javadoc(type: Javadoc) &#123;</span><br><span class="line">    source = android.sourceSets.main.java.srcDirs</span><br><span class="line">    classpath += project.files(android.getBootClasspath().join(File.pathSeparator))</span><br><span class="line">&#125;</span><br><span class="line">task javadocJar(type: Jar, dependsOn: javadoc) &#123;</span><br><span class="line">    classifier = &apos;javadoc&apos;</span><br><span class="line">    from javadoc.destinationDir</span><br><span class="line">&#125;</span><br><span class="line">artifacts &#123;</span><br><span class="line">    archives javadocJar</span><br><span class="line">    archives sourcesJar</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-上传到Jcenter仓库-需要去从local-properties中读取"><a href="#5-上传到Jcenter仓库-需要去从local-properties中读取" class="headerlink" title="(5)上传到Jcenter仓库 需要去从local.properties中读取"></a>(5)上传到Jcenter仓库 需要去从local.properties中读取</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Properties properties = new Properties()</span><br><span class="line">properties.load(project.rootProject.file(&apos;local.properties&apos;).newDataInputStream())</span><br><span class="line">bintray &#123;</span><br><span class="line">    user = properties.getProperty(&quot;bintray.user&quot;)</span><br><span class="line">    key = properties.getProperty(&quot;bintray.apikey&quot;)</span><br><span class="line">    configurations = [&apos;archives&apos;]</span><br><span class="line">    pkg &#123;</span><br><span class="line">        repo = &quot;maven&quot;</span><br><span class="line">        name = &quot;test-library&quot;                // project name in jcenter</span><br><span class="line">        websiteUrl = siteUrl</span><br><span class="line">        vcsUrl = gitUrl</span><br><span class="line">        licenses = [&quot;Apache-2.0&quot;]</span><br><span class="line">        publish = true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三、执行命令"><a href="#三、执行命令" class="headerlink" title="三、执行命令"></a>三、执行命令</h4><h5 id="通过命令进入项目目录执行命令"><a href="#通过命令进入项目目录执行命令" class="headerlink" title="通过命令进入项目目录执行命令"></a>通过命令进入项目目录执行命令</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./gradlew javadocJar</span><br><span class="line">./gradlew sourcesJar</span><br><span class="line">./gradlew install</span><br><span class="line">./gradlew bintrayUpload</span><br></pre></td></tr></table></figure><h3 id="Bintray所需的步骤"><a href="#Bintray所需的步骤" class="headerlink" title="Bintray所需的步骤"></a><a href="https://bintray.com/" target="_blank" rel="noopener">Bintray</a>所需的步骤</h3><h4 id="一、注册账号也可以通过Git直接登录"><a href="#一、注册账号也可以通过Git直接登录" class="headerlink" title="一、注册账号也可以通过Git直接登录"></a>一、注册账号也可以通过Git直接登录</h4><h4 id="二、添加一个新的Repository-名字跟在gradle配置的一样"><a href="#二、添加一个新的Repository-名字跟在gradle配置的一样" class="headerlink" title="二、添加一个新的Repository(名字跟在gradle配置的一样)"></a>二、添加一个新的Repository(名字跟在gradle配置的一样)</h4><h4 id="三、在gradle命令执行完成后可以到Bintray进行提交审核-一般几个小时"><a href="#三、在gradle命令执行完成后可以到Bintray进行提交审核-一般几个小时" class="headerlink" title="三、在gradle命令执行完成后可以到Bintray进行提交审核(一般几个小时)"></a>三、在gradle命令执行完成后可以到Bintray进行提交审核(一般几个小时)</h4><h4 id="四、审核通过之后就可以进行依赖的添加使用了"><a href="#四、审核通过之后就可以进行依赖的添加使用了" class="headerlink" title="四、审核通过之后就可以进行依赖的添加使用了"></a>四、审核通过之后就可以进行依赖的添加使用了</h4><p><code>compile &#39;com.mubai:library:1.0.1&#39;</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;项目所需的步骤&quot;&gt;&lt;a href=&quot;#项目所需的步骤&quot; class=&quot;headerlink&quot; title=&quot;项目所需的步骤&quot;&gt;&lt;/a&gt;项目所需的步骤&lt;/h3&gt;&lt;h4 id=&quot;一、添加插件&quot;&gt;&lt;a href=&quot;#一、添加插件&quot; class=&quot;headerlink&quot; title=&quot;一、添加插件&quot;&gt;&lt;/a&gt;一、添加插件&lt;/h4&gt;&lt;h5 id=&quot;在项目目录的build-gradle-中的-dependencies-添加：&quot;&gt;&lt;a href=&quot;#在项目目录的build-gradle-中的-dependencies-添加：&quot; class=&quot;headerlink&quot; title=&quot;在项目目录的build.gradle 中的 dependencies 添加：&quot;&gt;&lt;/a&gt;在项目目录的build.gradle 中的 dependencies 添加：&lt;/h5&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;classpath &amp;quot;com.jfrog.bintray.gradle:gradle-bintray-plugin:1.5&amp;quot; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;classpath &amp;apos;com.github.dcendents:android-maven-gradle-plugin:1.4.1&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android" scheme="https:mubai.site/categories/Android/"/>
    
    
      <category term="Android" scheme="https:mubai.site/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android反编译</title>
    <link href="https:mubai.site/2018-1-18-%E5%8F%8D%E7%BC%96%E8%AF%91/"/>
    <id>https:mubai.site/2018-1-18-反编译/</id>
    <published>2018-01-17T16:00:00.000Z</published>
    <updated>2019-04-02T08:44:43.757Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Android" scheme="https:mubai.site/categories/Android/"/>
    
    
      <category term="Android" scheme="https:mubai.site/tags/Android/"/>
    
  </entry>
  
</feed>

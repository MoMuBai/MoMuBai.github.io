<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>沐白白白</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https:mubai.site/"/>
  <updated>2020-03-21T08:41:44.069Z</updated>
  <id>https:mubai.site/</id>
  
  <author>
    <name>沐白</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>GiftForGirl</title>
    <link href="https:mubai.site/2020-3-21-%E7%A4%BC%E7%89%A9%E4%B8%93%E7%BA%BF/"/>
    <id>https:mubai.site/2020-3-21-礼物专线/</id>
    <published>2020-03-20T16:00:00.000Z</published>
    <updated>2020-03-21T08:41:44.069Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GiftForGirl"><a href="#GiftForGirl" class="headerlink" title="GiftForGirl"></a>GiftForGirl</h2><p><strong><em>专为男士为女士送礼用，包括香水、口红、包包、手链、镯子、耳环、项链、丝巾、帽子、护肤品、化妆品、指甲油、睡衣、内衣等等，仅供参考</em></strong></p><p><em>顺序不分先后，随便排的，开心就好，目前只是大概写写抄抄，内容待补充，未完待续</em></p><hr><ul><li><a href="#1-香水">香水</a></li><li><a href="#2-口红">口红</a></li><li><a href="#3-包包">包包</a></li><li><a href="#4-手链">手链</a></li><li><a href="#5-镯子">镯子</a></li><li><a href="#6-耳环">耳环</a></li><li><a href="#7-项链">项链</a></li><li><a href="#8-丝巾">丝巾</a></li><li><a href="#9-帽子">帽子</a></li><li><a href="#10-护肤品">护肤品</a></li><li><a href="#11-化妆品">化妆品</a></li><li><a href="#12-指甲油">指甲油</a></li><li><a href="#13-太阳眼镜">太阳眼镜</a></li><li><a href="#14-手表">手表</a></li><li><a href="#15-钱包">钱包</a></li><li><a href="#16-内衣">内衣</a></li><li><a href="#17-睡衣">睡衣</a></li></ul><h3 id="1-香水"><a href="#1-香水" class="headerlink" title="1 香水"></a>1 香水</h3><ul><li>Dior</li><li>CHANEL</li><li>菲拉格慕</li><li>范思哲</li><li>伊丽莎白雅顿</li><li>巴宝莉</li><li>阿玛尼</li><li>祖马龙</li><li>兰蔻</li><li>圣罗兰</li><li>橘滋</li></ul><h3 id="2-口红"><a href="#2-口红" class="headerlink" title="2 口红"></a>2 口红</h3><ul><li>圣罗兰YSL</li><li>魅可MAC</li><li>迪奥Dior</li><li>纪梵希Givenchy</li><li>资生堂SHISEIDO</li><li>美宝莲</li><li>阿玛尼Armaani</li><li>兰蔻LANCOME</li><li>香奈儿CHANEL</li><li>欧莱雅</li><li>汤姆福特Tom Ford</li><li>美丽小屋</li></ul><h3 id="3-包包"><a href="#3-包包" class="headerlink" title="3 包包"></a>3 包包</h3><ul><li>路易威登LV</li><li>香奈儿CHANEL</li><li>爱马仕Hermes</li><li>普拉达Prada</li><li>古驰Gucci</li><li>圣大保罗Polo</li><li>登喜路Dunhill</li><li>沙驰SATCHI</li><li>鳄鱼Lacoste</li><li>梦特娇Montagut</li></ul><h3 id="4-手链"><a href="#4-手链" class="headerlink" title="4 手链"></a>4 手链</h3><ul><li>潘多拉</li><li>路易威登LV</li><li>迪奥Dior</li><li>卡地亚</li><li>蒂芙尼</li><li>佐卡伊</li><li>芬迪</li><li>梵克雅宝</li><li>宝格丽</li><li>施华洛世奇</li></ul><h3 id="5-镯子"><a href="#5-镯子" class="headerlink" title="5 镯子"></a>5 镯子</h3><ul><li>施华洛世奇</li><li>潘多拉</li><li>蒂芙尼</li><li>卡地亚</li><li>爱马仕</li></ul><h3 id="6-耳环"><a href="#6-耳环" class="headerlink" title="6 耳环"></a>6 耳环</h3><ul><li>宝格丽</li><li>伯爵</li><li>梵克雅宝</li><li>Qeelin麒麟</li><li>施华洛世奇</li><li>橘滋</li><li>菲尼莎</li><li>依慧达</li><li>御木本</li><li>波米雷特</li><li>Oxette</li><li>尚晨珠宝</li><li>吉盟</li><li>梵蒂诺</li></ul><h3 id="7-项链"><a href="#7-项链" class="headerlink" title="7 项链"></a>7 项链</h3><ul><li>蒂芙尼</li><li>施华洛世奇</li><li>海盗船</li><li>Julie</li><li>卡地亚</li><li>宝格丽</li><li>蒙奇奇</li><li>梵克雅宝</li><li>爱马仕</li><li>迪奥</li><li>周大福</li><li>周生生</li><li>谢瑞麟TSL</li><li>潮宏基CHJ</li><li>周大生</li><li>老凤祥</li><li>六福</li></ul><h3 id="8-丝巾"><a href="#8-丝巾" class="headerlink" title="8 丝巾"></a>8 丝巾</h3><ul><li>爱马仕</li><li>玛利亚·古琦</li><li>万事利</li><li>博柏利</li><li>Zara飒拉</li><li>路易威登LV</li><li>鹿王</li><li>以纯</li><li>维信</li><li>宝石蝶</li><li>龙翔纺织</li><li>丝界</li><li>丝绸故事</li><li>喜得宝</li><li>上海故事</li><li>妩WOO</li><li>绝代佳人</li></ul><h3 id="9-帽子"><a href="#9-帽子" class="headerlink" title="9 帽子"></a>9 帽子</h3><ul><li>彩蓝EB</li><li>来可派</li><li>丽华LH</li><li>爱马仕</li><li>博柏利</li><li>快乐狐狸</li><li>拜丽德</li><li>GAP盖璞</li><li>红日</li><li>盛锡福</li></ul><h3 id="10-护肤品"><a href="#10-护肤品" class="headerlink" title="10 护肤品"></a>10 护肤品</h3><ul><li>法国lancome(兰蔻)-睫毛膏、兰蔻粉水</li><li>美国estee lauder(雅诗兰黛)-adbanced night repair(简称anr)系列、海蓝之谜</li><li>日本shiseido(资生堂)</li><li>法国dior(迪奥)-蓝金唇膏、5色眼影</li><li>法国chanel(香奈尔)</li><li>美国clinique(倩碧)-护肤三步曲</li><li>日本sk-ii-护肤精华露(又称神仙水)</li><li>法国biotherm(碧欧泉)-活泉水分露</li><li>hr(赫莲娜)-极至之美胶原系列、维他命c精华系列</li><li>美国伊丽沙白.雅顿-8小时润泽霜</li><li>雅斯兰黛的眼霜</li><li>sk2的各种护肤品、面膜</li><li>前男友面膜</li><li>luna洗脸仪</li><li>面部按摩仪   </li><li>Dreamtimes 梦幻时光爽肤水</li><li>FANCL芳柯</li><li>Ipsa流金水</li><li>Ipsa自律循环乳液</li><li>CPB水磨精华</li><li>珂润浸润保湿水+保湿面霜</li><li>碧欧泉新活泉爽肤组合</li><li>倩碧(润肤露)黄油</li><li>资生堂红色蜜露</li><li>DHC橄榄滋养套装</li><li>高丝雪肌精乳液</li><li>兰蔻精华肌底液(小黑瓶)</li><li>丝塔芙洁面乳</li><li>AVENE雅漾舒护活泉水</li></ul><h3 id="11-化妆品"><a href="#11-化妆品" class="headerlink" title="11 化妆品"></a>11 化妆品</h3><ul><li><p>欧莱雅：</p><ul><li>顶级品牌：HR(赫莲娜)是旗舰产品</li><li>二线产品：Lancome(兰蔻)，Biotherm(碧欧泉)</li><li>三线或三线以下产品：LOrealParis(欧莱雅)，kiehls(契尔氏)，美爵士、Garnier(卡尼尔)，羽西，小护士，INNEOV</li><li>彩妆品牌：CCBPARIS、shuuemura(植村秀)、Maybelline(美宝莲)</li><li>药妆品牌：Vichy(薇姿)，LAROCHE-POSAY(理肤泉)、SkinCeuticals(杜克)</li><li>香水品牌：GiorgioArmaniParfums(阿玛尼)，RalphLaurenParfums(拉尔夫*劳伦、POLO),caelParfums(卡夏尔)，VIKTOR&amp;ROLF</li><li>发用品牌：KERASTASE卡诗、MATRIX、MIZANI、REDKEN、SOFTSHEENCARSO</li></ul></li><li><p>宝洁公司</p><ul><li>顶级品牌：SK-II(Maxfactor)—就是蜜丝佛陀</li><li>二线品牌：Olay(玉兰油)、Illume(伊奈美)、Always、Zest</li><li>彩妆品牌：Covergirl(封面女郎)</li><li>亚洲区第一彩妆品牌：ANNASUI(安娜苏)</li><li>香水品牌：Hugoboss、Locaste、ANNASUI(安娜苏)、Escada(艾斯卡达)、Dunhill(登喜路)、Valention、Lanvin(朗万)、PaulSmith(保罗史密斯)</li><li>洗护品牌：飘柔、海飞丝、激爽(刚淘汰)、潘婷、润妍、沙宣、伊卡璐(Clairol)、舒肤佳、Wella(威娜)</li></ul></li><li><p>雅诗兰黛</p><ul><li>顶级品牌：LaMer(海蓝之谜)—–港台翻译为海洋之蓝</li><li>一线品牌：雅诗兰黛</li><li>二线品牌：Clinique(倩碧)</li><li>三线品牌：Stila、Origins(品木宣言)、Prescriptives、、Aveda(肯梦)和JoMalone</li><li>顶级限量彩妆品牌：TomFord(汤姆福特)</li><li>彩妆品牌：BobbiBrown(芭比波朗)、M.A.C(魅可).</li><li>香水品牌：TommyHilfiger(唐美希绯格)、DKNY(唐可娜儿)、Aramis(雅男士)</li><li>开架品牌：BeautyBank(目前仅在Kohls百货售卖，总共推出了Flirt、AmericanBeauty、GoodSkin及以Grassroots4个系</li></ul></li><li><p>资生堂</p><ul><li>顶级品牌：CledePeau(CDP)、IPSA(茵芙莎)</li><li>二线品牌：Ettusais(爱杜莎)、CARITA 凯伊黛、Decleor 思妍丽</li><li>底线品牌：ShiseidoFitit、Asplir(爱泊丽)、DeLuxe、ff 、SELFIT(珊妃)、Whitia(白媞雅)、FT Shiseido、泊美</li><li>彩妆品牌：Maquillage</li><li>中国专售：AUPRES欧珀莱、Za姬芮</li><li>香水品牌：JeanPaulGaultier、三宅一生</li><li>洗护品牌：ShiseidoProfessional</li></ul></li><li><p>LVMH</p><ul><li>护肤品牌：Guerlain(娇兰)、ChristianDior(迪奥)、纪梵希(Givenchy)、DomPerignon(唐-裴利农)、Bliss、CLARINS(娇韵诗)</li><li>彩妆品牌：Makeupforever(浮生若梦)、BENEFIT、Cosmetics、AcquadiParma、Fresh、SEPHORA(丝芙兰)</li><li>香水品牌：KENZO(高田贤三)，fendi(芬迪)，Celine(赛琳)、LOEWE、DOLCE&amp;GABBANA(杜嘉班纳)、CHAUMET(舒维)、CalvinKlein(CK)、ChristianLacroi</li></ul></li><li><p>Chanel(香奈儿)</p></li><li>LG<ul><li>顶级护肤品牌：OHUI</li><li>二线护肤品牌：IsaKnox爱之浓思、海皙蓝、LaeVert(莲婷)</li><li>底线品牌：曼丽妃丝、缇兰</li></ul></li></ul><h4 id="12-指甲油"><a href="#12-指甲油" class="headerlink" title="12 指甲油"></a>12 指甲油</h4><ul><li>芭比波朗</li><li>RGB</li><li>NARS</li><li>CND</li><li>莎莉汉森</li><li>巴黎欧莱雅</li><li>ESSIE</li><li>露华浓</li><li>China Glaze</li><li>OPI</li><li>美宝莲Maybelline</li><li>Missha谜尚</li><li>歌诗美COSMAY</li><li>香奈儿</li><li>Za姬芮</li><li>丝芙兰</li><li>安娜苏AnnaSui</li><li>Innisfree悦丝风吟</li><li>TheFaceShop菲斯小铺</li><li>露华浓Revlon</li><li>迪奥Dior</li></ul><h3 id="13-太阳眼镜"><a href="#13-太阳眼镜" class="headerlink" title="13 太阳眼镜"></a>13 太阳眼镜</h3><ul><li>雷德蒙女士太阳镜</li><li>爱靓眼镜女士太阳镜</li><li>阿玛尼女士太阳镜</li><li>暴龙女士太阳镜</li><li>海伦凯勒女士太阳镜</li><li>宝丽来女士太阳镜</li><li>kalikali女士太阳镜</li><li>GUCCI女士太阳镜</li><li>香奈儿女士太阳镜</li><li>雷朋女士太阳镜</li><li>古驰女士太阳镜</li><li>帕莎女士太阳镜</li><li>阿玛尼女士太阳镜</li><li>卡地亚女士太阳镜</li><li>帕莎女士太阳镜</li><li>欣菲特女士太阳镜</li><li>海豚女士太阳镜</li><li>派丽蒙女士太阳镜</li><li>万宝龙女士太阳镜</li><li>保圣女士太阳镜</li><li>宝姿女士太阳镜</li></ul><h3 id="14-手表"><a href="#14-手表" class="headerlink" title="14 手表"></a>14 手表</h3><ul><li>dw手表 尼龙表带简约休闲女士手表、女士简约金属钢带手表、玫瑰金女士手表</li><li>雷达</li><li>浪琴 PRIMALUNA心月 系列L8.111.4.87.6腕表、圆舞曲系列-玫瑰金镶钻腕表</li><li>天梭 T028.210.11.057.01</li><li>名士 灵霓系列MOA10036腕表</li><li>美度 DONNA Caliber 80超长动力储存女士腕表</li><li>艾米龙 净雅系列06.2188.L.6.6.28.6腕表</li><li>万宝龙 明星经典系列U0110304腕表</li><li>艾美 典雅系列LC6016-SS002-130腕表</li><li>欧米茄 星座系列</li><li>卡地亚 蓝气球系列、桑托斯系列、伦敦SOLO系列、「坦克」女款、山度士</li><li>劳力士 日志</li><li>香奈儿BOY FRIEND 系列</li><li>爱彼皇家 橡树满天星</li><li>法穆兰</li></ul><h3 id="15-钱包"><a href="#15-钱包" class="headerlink" title="15 钱包"></a>15 钱包</h3><ul><li>路易威登LV</li><li>古琦欧·古琦Gucci</li><li>香奈儿CHANEL</li><li>普拉达Prada</li><li>圣大保罗Polo</li><li>迪奥Dior</li><li>爱马仕Hermes</li><li>寇兹/寇驰COACH</li><li>登喜路Dunhill</li><li>芬迪Fendi</li></ul><h3 id="16-内衣"><a href="#16-内衣" class="headerlink" title="16 内衣"></a>16 内衣</h3><ul><li>古今</li><li>婷美</li><li>法曼儿</li><li>华歌尔</li><li>仙黛尔</li><li>LA PERLA</li><li>都市丽人</li><li>欧迪芬</li><li>嘉莉诗</li><li>歌瑞尔</li><li>梦芭莎</li><li>猫人</li><li>安莉芳</li><li>维多利亚的秘密</li><li>雅芳</li><li>爱慕</li><li>黛安芬</li><li>曼妮芬</li></ul><h3 id="17-睡衣"><a href="#17-睡衣" class="headerlink" title="17 睡衣"></a>17 睡衣</h3><ul><li>芬腾</li><li>安之伴</li><li>美标Meibiao</li><li>爱慕Aimer</li><li>秋鹿</li><li>歌瑞尔</li><li>康妮雅</li><li>维多利亚的秘密</li><li>美梦</li><li>沃莱卡</li><li>安莉芳</li><li>雪俐</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;GiftForGirl&quot;&gt;&lt;a href=&quot;#GiftForGirl&quot; class=&quot;headerlink&quot; title=&quot;GiftForGirl&quot;&gt;&lt;/a&gt;GiftForGirl&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;专为男士为女士送礼用，包括香水、口红、包包、
      
    
    </summary>
    
      <category term="闲文" scheme="https:mubai.site/categories/%E9%97%B2%E6%96%87/"/>
    
    
      <category term="礼物专线" scheme="https:mubai.site/tags/%E7%A4%BC%E7%89%A9%E4%B8%93%E7%BA%BF/"/>
    
  </entry>
  
  <entry>
    <title>多线程交替打印数组元素</title>
    <link href="https:mubai.site/2019-12-25-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0%E6%95%B0%E7%BB%84/"/>
    <id>https:mubai.site/2019-12-25-多线程交替打印数组/</id>
    <published>2019-12-24T16:00:00.000Z</published>
    <updated>2020-05-13T13:16:30.398Z</updated>
    
    <content type="html"><![CDATA[<p> <em>多线程交替打印数组元素</em></p><h3 id="通过LockSupport"><a href="#通过LockSupport" class="headerlink" title="通过LockSupport:"></a>通过LockSupport:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private  Thread a, b;</span><br><span class="line"></span><br><span class="line">private void threadPrintArray() &#123;</span><br><span class="line">    int[] arr = new int[]&#123;1, 2, 3, 4, 5, 6&#125;;</span><br><span class="line">    //通过Lock.support，可以阻塞一个线程，唤起一个线程</span><br><span class="line">    a = new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            for (int i : arr) &#123;</span><br><span class="line">                System.out.println(&quot;a：&quot; + i);</span><br><span class="line">                LockSupport.unpark(b);//先唤起b线程</span><br><span class="line">                LockSupport.park();//阻塞自己</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    b = new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            for (int i : arr) &#123;</span><br><span class="line">                LockSupport.park();//先阻塞自己，防止先打印b线程的值</span><br><span class="line">                System.out.println(&quot;b：&quot; + i);</span><br><span class="line">                LockSupport.unpark(a);//唤起a线程</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    a.start();</span><br><span class="line">    b.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过Synchronized-wait-notify"><a href="#通过Synchronized-wait-notify" class="headerlink" title="通过Synchronized+wait/notify"></a>通过Synchronized+wait/notify</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">private  Thread a, b;</span><br><span class="line">private void threadPrintArray() &#123;</span><br><span class="line">int[] arr = new int[]&#123;1, 2, 3, 4, 5, 6&#125;;</span><br><span class="line">//通过sync加锁 ，然后通过wait和notify来控制阻塞和唤起</span><br><span class="line">a = new Thread(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        synchronized (arr) &#123;</span><br><span class="line">            for (int i : arr) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println(&quot;a：&quot; + i);</span><br><span class="line">                    arr.notify();//先去唤起其他线程</span><br><span class="line">                    arr.wait();//再去对自己阻塞</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">b = new Thread(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        synchronized (arr) &#123;</span><br><span class="line">            for (int i : arr) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println(&quot;b：&quot; + i);</span><br><span class="line">                    arr.notify();//先去唤起其他线程</span><br><span class="line">                    arr.wait();//再去对自己阻塞</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">a.start();</span><br><span class="line">b.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过ReentrantLock"><a href="#通过ReentrantLock" class="headerlink" title="通过ReentrantLock"></a>通过ReentrantLock</h3><ul><li>单Condition控制(类似Sync+wait/notify)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">private ReentrantLock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">private Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">private  Thread a, b;</span><br><span class="line"></span><br><span class="line">private void threadPrintArray() &#123;</span><br><span class="line">int[] arr = new int[]&#123;1, 2, 3, 4, 5, 6&#125;;</span><br><span class="line">a = new Thread(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            for (int i : arr) &#123;</span><br><span class="line">                System.out.println(&quot;a：&quot; + i);</span><br><span class="line">                condition.singal();//唤起其他线程，即b线程</span><br><span class="line">                condition.await();//阻塞a线程</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">b = new Thread(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            for (int i : arr) &#123;</span><br><span class="line">                System.out.println(&quot;b：&quot; + i);</span><br><span class="line">                condition.signal();//唤起其他线程，即a线程</span><br><span class="line">                condition.await();//阻塞b线程</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">a.start();</span><br><span class="line">b.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>多Condition来控制</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">private ReentrantLock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">private Condition aCondition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">private Condition bCondition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">private  Thread a, b;</span><br><span class="line"></span><br><span class="line">private void threadPrintArray() &#123;</span><br><span class="line">int[] arr = new int[]&#123;1, 2, 3, 4, 5, 6&#125;;</span><br><span class="line">a = new Thread(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            for (int i : arr) &#123;</span><br><span class="line">                System.out.println(&quot;a：&quot; + i);</span><br><span class="line">                bCondition.signal();//唤起b线程</span><br><span class="line">                aCondition.await();//阻塞a线程</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">b = new Thread(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            for (int i : arr) &#123;</span><br><span class="line">                System.out.println(&quot;b：&quot; + i);</span><br><span class="line">                aCondition.signal();//唤起a线程</span><br><span class="line">                bCondition.await();//阻塞b线程</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">a.start();</span><br><span class="line">b.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过原子类-自旋实现"><a href="#通过原子类-自旋实现" class="headerlink" title="通过原子类+自旋实现"></a>通过原子类+自旋实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">AtomicInteger threadNo = new AtomicInteger(1);</span><br><span class="line"></span><br><span class="line">private  Thread a, b;</span><br><span class="line"></span><br><span class="line">private void threadPrintArray() &#123;</span><br><span class="line"></span><br><span class="line">int[] arr = new int[]&#123;1, 2, 3, 4, 5, 6&#125;;</span><br><span class="line"></span><br><span class="line">a = new Thread(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int i : arr) &#123;</span><br><span class="line">        while(threadNo.get() != 1)&#123;&#125;//如果等于1，即不是a线程的 自旋</span><br><span class="line">        System.out.println(&quot;a：&quot; + i);</span><br><span class="line">        threadNo.get.set(2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">b = new Thread(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int i : arr) &#123;</span><br><span class="line">        while(threadNo.get() != 2)&#123;&#125;//如果等于2，即不是b线程的 自旋</span><br><span class="line">            System.out.println(&quot;b：&quot; + i);</span><br><span class="line">            threadNo.get.set(1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">a.start();</span><br><span class="line">b.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; &lt;em&gt;多线程交替打印数组元素&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;通过LockSupport&quot;&gt;&lt;a href=&quot;#通过LockSupport&quot; class=&quot;headerlink&quot; title=&quot;通过LockSupport:&quot;&gt;&lt;/a&gt;通过LockSupport:&lt;/h
      
    
    </summary>
    
      <category term="Android" scheme="https:mubai.site/categories/Android/"/>
    
    
      <category term="Android" scheme="https:mubai.site/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>沉浸式状态栏</title>
    <link href="https:mubai.site/2019-12-20-%E6%B2%89%E6%B5%B8%E5%BC%8F%E7%8A%B6%E6%80%81%E6%A0%8F/"/>
    <id>https:mubai.site/2019-12-20-沉浸式状态栏/</id>
    <published>2019-12-19T16:00:00.000Z</published>
    <updated>2020-05-09T15:03:58.286Z</updated>
    
    <content type="html"><![CDATA[<p> <em>沉浸式状态栏怎么搞</em></p><h3 id="实现沉浸式状态栏主要跟以下四个Api相关"><a href="#实现沉浸式状态栏主要跟以下四个Api相关" class="headerlink" title="实现沉浸式状态栏主要跟以下四个Api相关:"></a>实现沉浸式状态栏主要跟以下四个Api相关:</h3><ul><li><p>View#setSystemUiVisibility()</p></li><li><p>Window#addFlags()</p></li><li><p>View#setFitsSystemWindows</p></li><li><p>Window#setStatusBarColor()</p></li></ul><h4 id="View-setSystemUiVisibility-及其各种Flags"><a href="#View-setSystemUiVisibility-及其各种Flags" class="headerlink" title="View#setSystemUiVisibility()及其各种Flags"></a>View#setSystemUiVisibility()及其各种Flags</h4><p>首先setSystemUiVisibility()这个方法就是设置状态栏或者导航栏的各种属性的。</p><ul><li><p>View.SYSTEM_UI_FLAG_FULLSCREEN:<br>  视图全屏并隐藏状态栏，当用户交互时（如下滑状态栏）会恢复隐藏的状态栏（例子：电子书阅读）缺点：进入Activity会产生一个从非全屏到全屏的闪动效果</p></li><li><p>View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY：<br>  粘性沉浸模式，需要和SYSTEM_UI_FLAG_FULLSCREEN或者SYSTEM_UI_FLAG_HIDE_NAVIGATION联用，当使用View.setSystemUiVisibility(View.SYSTEM_UI_FLAG_FULLSCREEN|View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY)联用时视图全屏，当用户产生交互时（如下滑状态栏）不会恢复状态栏，只会以半透明的方式覆盖在视图上面并在一定时间内自动消失</p></li><li><p>View.SYSTEM_UI_FLAG_IMMERSIVE：<br>  沉浸模式，只能和SYSTEM_UI_FLAG_FULLSCREEN联用，效果和View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY一样，目前已被后者替代</p></li><li><p>View.SYSTEM_UI_FLAG_LOW_PROFILE:<br>  低配模式，会隐藏一些不重要的状态栏和导航栏的图标</p></li><li><p>View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN：<br>  视图全屏且不会产生闪动，状态栏会覆盖在视图上面</p></li><li><p>View.SYSTEM_UI_FLAG_LAYOUT_STABLE：<br>  使视图稳定，当使用fitSystemWindows（）（下面会单独介绍这个方法）需要视图稳定，一般和View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN联用</p></li><li><p>View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR:<br>Android6.0系统以上增加的属性，设置了这个属性，状态栏会以与状态栏背景颜色兼容的模式绘制。什么意思呢？就是说如果当前的状态栏颜色是浅色，那么就有可能造成状态栏上的图标看不清了，但是如果你设置这个属性以后，状态栏的图标就会以深色绘制，这样就没有什么UI上的问题了。</p></li></ul><h4 id="Window-addFlags-及其各种Flags"><a href="#Window-addFlags-及其各种Flags" class="headerlink" title="Window.addFlags()及其各种Flags"></a>Window.addFlags()及其各种Flags</h4><p>WindowManager.LayoutParams相关属性：</p><ul><li><p>FLAG_TRANSLUCENT_STATUS:<br>Android4.4系统增加的属性，它会使状态栏透明透明并且自动执行View.SYSTEM_UI_FLAG_LAYOUT_STABLE和View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN</p></li><li><p>FLAG_FULLSCREEN:<br>视图全屏并隐藏状态栏，效果相当于View.SYSTEM_UI_FLAG_FULLSCREEN+View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY，并且视图稳定（不会因为系统控件的变化（如输入法），而重新布局）</p></li><li><p>FLAG_FORCE_NOT_FULLSCREEN：<br>重写了FLAG_FULLSCREEN并强制显示状态栏（没有啥卵用）</p></li><li><p>FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS：<br>Android5.0系统以上支持，如果设置了该属性，系统栏（状态栏和导航栏）将以透明背景绘制，并且该窗口中的相应区域将填充setStatusBar（）和setNavigationBarColor（）中设置的颜色</p></li></ul><h4 id="View-setFitsSystemWindows"><a href="#View-setFitsSystemWindows" class="headerlink" title="View#setFitsSystemWindows"></a>View#setFitsSystemWindows</h4><p>此方法只有当设置SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN或者SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION才有有效，当窗口发生变化时，View需要调整自身内容以适应窗口的变化，你可以理解为当和SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN一起联用的时候，是给View加了个bottomTop属性，宽度填充视图，高度就是状态栏的高度；当和SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION一起联用的时候，是给View加了个bottomBottom属性，宽度填充视图，高度就是导航栏的高度，建议给布局的顶层ViewGroup使用</p><h4 id="Window-setStatusBarColor"><a href="#Window-setStatusBarColor" class="headerlink" title="Window#setStatusBarColor()"></a>Window#setStatusBarColor()</h4><p>Android5.0系统及以上开始支持，设置状态栏的颜色，为了使这个状态有效必须要设置FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS而且不能设置FLAG_TRANSLUCENT_STATUS</p><h3 id="实现沉浸式状态栏的具体套路"><a href="#实现沉浸式状态栏的具体套路" class="headerlink" title="实现沉浸式状态栏的具体套路"></a>实现沉浸式状态栏的具体套路</h3><p>实现沉浸式状态栏分为三个阶段，</p><ul><li>Android4.4~Android5.0以下;</li><li>Android5.0~Android6.0以下；</li><li>Android6.0以上；</li></ul><h4 id="Android4-4-Android5-0阶段以下："><a href="#Android4-4-Android5-0阶段以下：" class="headerlink" title="Android4.4~Android5.0阶段以下："></a>Android4.4~Android5.0阶段以下：</h4><p>Android真正可以实现沉浸式状态栏是从4.4开始的，因为4.4系统加入了一个重要的属性Window.LayoutParams.FLAG_TRANSLUCENT_STATUS，这个属性能干嘛，前面已经说过了，下面直接开搞。<br>首先，沉浸式状态栏一般有两种情况，一种是背景是一张图片，一种是颜色跟标题栏一致的</p><ul><li>背景是一张图片的情况：非常非常好实现，一行代码直接搞定</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">activity.getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);</span><br></pre></td></tr></table></figure><p>FLAG_TRANSLUCENT_STATUS这个属性会让状态栏以白色绘制，同时还会执行SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN和SYSTEM_UI_FLAG_LAYOUT_STABLE这样就会让状态栏浮在图片的上面，这样就形成了沉浸式的效果</p><ul><li>颜色跟标题栏一致的情况</li></ul><p>这种情况在4.4~5.0以下这个阶段实现起来就稍微复杂了一点，因为这个阶段还没有执行setStatusBarColor（）这个方法，因此这个阶段实现的套路是，先制造一个假的View背景颜色跟标题栏的颜色一致，高度跟状态栏的高度一致，添加到顶层DecorView上面，然后让Android的最顶层的内容布局调用setFitsSystemWindows空出来状态栏的高度，最后调用FLAG_TRANSLUCENT_STATUS这个属性即可，让状态栏透明并浮在假View上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">View statusView = new View(activity);</span><br><span class="line">ViewGroup.LayoutParams statusViewLayoutParams = new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, getStatusBarHeight(activity));</span><br><span class="line">ViewGroup decorView = (ViewGroup) activity.getWindow().getDecorView();</span><br><span class="line">decorView.addView(statusView, statusViewLayoutParams);</span><br><span class="line">ViewGroup rootView = decorView.findViewById(Window.ID_ANDROID_CONTENT);</span><br><span class="line">if (rootView != null) &#123;</span><br><span class="line">    rootView.setFitsSystemWindows(true);</span><br><span class="line">&#125;</span><br><span class="line">activity.getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);</span><br></pre></td></tr></table></figure><p>注意：从两张效果图的图片可以看出，沉浸式状态在这一阶段的表现还不是太好，上面会有一层黑色的半透明浮层，但是也基本可以实现了沉浸式。</p><h4 id="Android5-0-Android6-0以下"><a href="#Android5-0-Android6-0以下" class="headerlink" title="Android5.0~Android6.0以下"></a>Android5.0~Android6.0以下</h4><p>这一阶段Android系统为我们增加了一个非常重要的API，Window#setStatusBarColor()，关于它的用法前面已经有所介绍，这里不再赘述，以及一个配合这个api使用的属性FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS，直接开搞</p><ul><li>背景是一张图的情况</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">activity.getWindow().addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);</span><br><span class="line">activity.getWindow().setStatusBarColor(Color.TRANSPARENT);</span><br><span class="line">activity.getWindow().clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);</span><br><span class="line">activity.getWindow().getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN);</span><br></pre></td></tr></table></figure><p>这里简单解释一下，我们把状态栏的颜色设置成透明，同时让状态栏浮在视图上面且保持稳定，这样图片就会顶到视图的顶部，因此就实现了沉浸式的效果，代码很简单，万一看不懂就翻翻上面对各种api的介绍</p><ul><li><p>颜色状态栏</p><ul><li><p>直接给状态栏设置对应的颜色</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">activity.getWindow().addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);</span><br><span class="line">       activity.getWindow().clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);</span><br><span class="line">activity.getWindow().setStatusBarColor(color);</span><br></pre></td></tr></table></figure></li><li><p>给状态栏设置透明色并让状态栏浮在视图顶层，配合setFitsSystemWindows（）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">activity.getWindow().getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_STABLE);</span><br><span class="line">activity.getWindow().addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);     activity.getWindow().clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);</span><br><span class="line">activity.getWindow().setStatusBarColor(Color.TRANSPARENT);</span><br><span class="line">toolBar.setFitsSystemWindows(true);//这里根据自己的布局情况</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="Android6-0及以上"><a href="#Android6-0及以上" class="headerlink" title="Android6.0及以上"></a>Android6.0及以上</h4><p>之所以又分了这一个阶段，是因为我们在5.0~6.0阶段发现了一个小问题，就是当我们要给状态栏设置的颜色是白色或者浅色的时候，因为默认的状态上图标的颜色是白色就会造成看不清的现象</p><p>为了避免这种情况，Android系统在6.0的时候增加了一个属性SYSTEM_UI_FLAG_LIGHT_STATUS_BAR，此前已经介绍过这个属性，这里不再赘述，使用了它以后，状态栏上的图标文字就会默认使用黑色绘制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">activity.getWindow().addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);</span><br><span class="line">activity.getWindow().clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);</span><br><span class="line">activity.getWindow().setStatusBarColor(color);</span><br><span class="line">if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123;           activity.getWindow().getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ps:小米和魅族系统在Android5.0修改自家系统的源码，因此他们在5.0的时候就提供这个API，也就是说小米和魅族Android5.0系统的手机就支持了浅色主题模式。</p><h4 id="沿着别人走过的路，跟上去发现不一样的风景"><a href="#沿着别人走过的路，跟上去发现不一样的风景" class="headerlink" title="沿着别人走过的路，跟上去发现不一样的风景"></a>沿着别人走过的路，跟上去发现不一样的风景</h4><p>参考链接：</p><ul><li>转载自：<a href="https://www.jianshu.com/p/f84f7e07e0d6" target="_blank" rel="noopener">https://www.jianshu.com/p/f84f7e07e0d6</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; &lt;em&gt;沉浸式状态栏怎么搞&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;实现沉浸式状态栏主要跟以下四个Api相关&quot;&gt;&lt;a href=&quot;#实现沉浸式状态栏主要跟以下四个Api相关&quot; class=&quot;headerlink&quot; title=&quot;实现沉浸式状态栏主要跟以下四个Api相关:&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="Android" scheme="https:mubai.site/categories/Android/"/>
    
    
      <category term="Android" scheme="https:mubai.site/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Rxjava2 太多方法了，记不住呀</title>
    <link href="https:mubai.site/2019-12-2-Rxjava2%20%E5%A4%AA%E5%A4%9A%E6%96%B9%E6%B3%95%E4%BA%86%EF%BC%8C%E8%AE%B0%E4%B8%8D%E4%BD%8F%E5%91%80/"/>
    <id>https:mubai.site/2019-12-2-Rxjava2 太多方法了，记不住呀/</id>
    <published>2019-12-01T16:00:00.000Z</published>
    <updated>2020-05-09T08:53:52.380Z</updated>
    
    <content type="html"><![CDATA[<p> <em>Rxjava2 太多方法了，记不住呀</em></p><p> 总结下</p><h4 id="一、什么是Rxjava以及Obserable的多种创建方式"><a href="#一、什么是Rxjava以及Obserable的多种创建方式" class="headerlink" title="一、什么是Rxjava以及Obserable的多种创建方式"></a>一、什么是Rxjava以及Obserable的多种创建方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">1.create():创建一个完成的被观察者(Observable)---&gt;:RxJava中创建被观察者最基本的操作符</span><br><span class="line"></span><br><span class="line">2.empty():快速创建后只发送complete事件，直接通知完成</span><br><span class="line"></span><br><span class="line">3.error():快速创建后只发送error事件，直接通知异常</span><br><span class="line"></span><br><span class="line">4.never():快速创建后不发送任何事件</span><br><span class="line"></span><br><span class="line">5.just():快速创建后直接发送传入的事件---&gt;参数最多只能10个，即发送的事件最多10个</span><br><span class="line"></span><br><span class="line">6.fromArray():快速创建后直接发送传入的数组数据---&gt;参数为数组，子类型为任意类型，可10个以上</span><br><span class="line"></span><br><span class="line">7.fromIterable():快速创建后直接发送传入的集合List数据---&gt;参数为集合List，子类型为任意类型，可10个以上</span><br><span class="line"></span><br><span class="line">8.defer():直到观察者Observer订阅被观察者Observable时，才动态创建被观察者&amp;发送事件---&gt;通过Observable工厂方法创建被观察者，每次订阅后都会得到一个最新创建的被观察者Observable，确保里面的数据是最新的</span><br><span class="line"></span><br><span class="line">9.timer():快速创建被观察者，指定延时时间，发送一个数值为0的事件---&gt;延时指定时间后发送一个参数为0的事件，相当于onNext（0）</span><br><span class="line"></span><br><span class="line">10.interval():快速创建被观察者，每隔指定时间发送事件---&gt;发送事件序列，从0开始，无限递增1</span><br><span class="line"></span><br><span class="line">11.intervalRange():快速创建被观察者，每隔指定时间发送事件，可指定发送事件数---&gt;发送无限递增1的事件序列，可指定起始值大小和事件次数，可延时，类似interval()</span><br><span class="line"></span><br><span class="line">12.range():快速创建被观察者，连续发送一个时间序列，可指定范围---&gt;发送无限递增1的事件序列，可指定起始值大小和事件次数，不可延时，类似intervalRange()</span><br><span class="line"></span><br><span class="line">13.rangeLong():同上，区别在于数据参数为类型Long</span><br></pre></td></tr></table></figure><h4 id="二、操作符"><a href="#二、操作符" class="headerlink" title="二、操作符"></a>二、操作符</h4><h5 id="一-变换操作符"><a href="#一-变换操作符" class="headerlink" title="(一).变换操作符"></a>(一).变换操作符</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.map():对Observable发送的每一个事件进行转换</span><br><span class="line"></span><br><span class="line">2.flatMap():对Observable发送的整个个事件进行转换（无序）</span><br><span class="line"></span><br><span class="line">3.concatMap():对Observable发送的整个个事件进行转换（有序）</span><br><span class="line"></span><br><span class="line">4.buffer():从Observable的事件中获取事件放到缓存区再发送事件</span><br></pre></td></tr></table></figure><h5 id="二-组合操作符"><a href="#二-组合操作符" class="headerlink" title="(二).组合操作符"></a>(二).组合操作符</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.concat()与concatArray():组合多个被观察者发送数据，合并后按照顺序执行---&gt;区别：组合被观察者数量：concat()&lt;=4,concatArray()无限制</span><br><span class="line"></span><br><span class="line">2.Merge()与MergeArray():组合多个被观察者发送数据，合并后按照时间顺序执行---&gt;区别：组合被观察者数量：Merge()&lt;=4,MergeArray()无限制</span><br><span class="line"></span><br><span class="line">3.concatDelayError():将错误事件延迟到所以事件执行完后才执行错误事件</span><br><span class="line"> </span><br><span class="line">4.megreDelayError():类似上面concatDelayError</span><br><span class="line"></span><br><span class="line">5.startWith()与startWithArray():在一个被观察者发送数据前，追加发送一些数据---&gt;调用顺序：先追加的后调用，后追加的先调用</span><br></pre></td></tr></table></figure><h5 id="三-合并操作符"><a href="#三-合并操作符" class="headerlink" title="(三).合并操作符"></a>(三).合并操作符</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.zip():合并多个被观察者发送的事件，生成一个新的事件序列。---&gt;严格按照事件序列进行合并,最后Observable的数据=多个Observable中数量最少的</span><br><span class="line"></span><br><span class="line">2.combineLatest():将两个Observable产生的结果进行合并，合并新的Observable发送给订阅者---&gt;当其中一个Observable发送数据，都与另一个Observable最后发送的数据结合，类似zip()，不同的是按照时间点合并</span><br><span class="line"></span><br><span class="line">3.combineLatestDelayError():将错误事件延迟到所以事件执行完后才执行错误事件</span><br><span class="line"></span><br><span class="line">4.reduce():把观察者需要发送的事件聚合成一个事件并且发送。---&gt;前两个被观察者聚合成新的被观察者，再与下一数据聚合，一次类推</span><br><span class="line"></span><br><span class="line">5.collect():将被观察者发送的数据放到一个容器中处理</span><br></pre></td></tr></table></figure><h5 id="四-统计发送事件的数量"><a href="#四-统计发送事件的数量" class="headerlink" title="(四).统计发送事件的数量"></a>(四).统计发送事件的数量</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count()方法是统计Observable(被观察者)发送的事件的数量</span><br></pre></td></tr></table></figure><h5 id="五-延迟操作符"><a href="#五-延迟操作符" class="headerlink" title="(五).延迟操作符"></a>(五).延迟操作符</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1.doOnNext():执行onNext()事件前调用</span><br><span class="line"></span><br><span class="line">2.doOnEach():当Observable每发送一次数据就调用一次</span><br><span class="line"></span><br><span class="line">3.doAfterNext():执行onNext()事件后调用</span><br><span class="line"></span><br><span class="line">4.doOnError():发送错误事件时调用</span><br><span class="line"></span><br><span class="line">5.doAfterTerminate():无论是正常发送事件完毕/异常终止都回调</span><br><span class="line"></span><br><span class="line">6.doOnSubscribe():观察者订阅时回调</span><br><span class="line"></span><br><span class="line">7.doOnComplete():正常发送事件完毕后</span><br><span class="line"></span><br><span class="line">8.doFinally():最后执行</span><br></pre></td></tr></table></figure><h5 id="六-错误处理操作符"><a href="#六-错误处理操作符" class="headerlink" title="(六).错误处理操作符"></a>(六).错误处理操作符</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.onErrorReturn():Observable发生错误或异常时发送一个相同类型的特殊事件，并且终止事件发送。</span><br><span class="line"></span><br><span class="line">2.onErrorResumeNext():Observable发生错误或异常时产生新的Observable发送一个特殊事件，并且终止事件发送。</span><br><span class="line"></span><br><span class="line">3.onExceptionResumeNext():同上，不同点：这里只能拦截异常不能拦截错误</span><br><span class="line"></span><br><span class="line">4.retry():发生异常或错误时重试源Observable的请求</span><br><span class="line"></span><br><span class="line">5.retryWhen():同上，不同点：将错误异常传递给新的Observable通知源Observable</span><br><span class="line"></span><br><span class="line">6.repeat():重复源Observable发送事件（抛出异常错误不能重复发送）</span><br><span class="line"></span><br><span class="line">7.repeatWhen():在回调方法中创建新的Observable，通过新的observable是否重复订阅和发送事件。</span><br></pre></td></tr></table></figure><h5 id="七-过滤操作符"><a href="#七-过滤操作符" class="headerlink" title="(七).过滤操作符"></a>(七).过滤操作符</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1.filter():按照指定的条件(自定义)对被观察者发出的结果进行过滤，再提交给被观察者---&gt;在回调方法中实现规则过滤</span><br><span class="line"></span><br><span class="line">2.ofType():根据指定的数据类型对被观察者发出的结果进行过滤，再提交给被观察者---&gt;参数传入对结果过滤的类型</span><br><span class="line"></span><br><span class="line">3.elementAt():将指定索引被观察者发出的事件提交给观察者，索引为0---&gt;参数传入索引</span><br><span class="line"></span><br><span class="line">4.distinct():去重，去掉被观察者产生的重复的结果，将不重复的提交给观察者</span><br><span class="line"></span><br><span class="line">5.debounce():只接收到倒计时时间外的被观察者发出的事件，每个事件发出时会重置倒计时时间。---&gt;参数传入每个事件的倒计时时间</span><br><span class="line"></span><br><span class="line">6.first():将被观察者产生的第一个结果提交给被观察者处理</span><br><span class="line"></span><br><span class="line">7.last():将被观察者产生的最后一个结果提交给观察者处理</span><br><span class="line"></span><br><span class="line">8.skip():跳过前n个被观察者产生的结果，将后面的提交给观察者处理---&gt;参数传入指定跳过的数量</span><br><span class="line"></span><br><span class="line">9.take():将前n个被观察者产生的结果提交给观察者处理，其他的不做处理---&gt;参数传入指定执行的数量</span><br></pre></td></tr></table></figure><h5 id="八-其他他操作符"><a href="#八-其他他操作符" class="headerlink" title="(八).其他他操作符"></a>(八).其他他操作符</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.groupBy():对于源Observable(被观察者)产生的结果进行分组，形成一个类型为GroupedObservable的结果集，存在一个方法为getKey()，通过该方法获取结果集的key值---&gt;如果事件结果没有处理，那么take()处理一下，否则会内存泄漏</span><br><span class="line"></span><br><span class="line">2.cast():用于类型转换，将源Observable的源类型转为指定的.class---&gt;如果类型不正确则会抛出转换异常。</span><br><span class="line"></span><br><span class="line">3.scan()遍历源Observable产生的结果，依次每个结果按照指定的规则进行计算，计算后的结果作为下一项迭代的参数，每一次迭代项都会把计算结果输出给订阅者。---&gt;每次计算的结果用于下次计算</span><br><span class="line"></span><br><span class="line">4.join():把两个Observable产生的结果进行合并，合并结果组成一个新的Observable，可以控制每个Observable产生结果的生命周期，在每个结果的生命周期内，可以与另一个Observable产生的结果按照一定的规则进行合并---&gt;合并结果产生新的Observable</span><br><span class="line"></span><br><span class="line">5.groupJoin():类似上述，第三个参数不一致，返回新的Observable处理</span><br></pre></td></tr></table></figure><h3 id="背压"><a href="#背压" class="headerlink" title="背压"></a>背压</h3><ul><li>背压指的是上游的被观察者发送的速度太快，而观察者处理的速度较慢，处理不过来，就会出现异常Backpressure</li></ul><ul><li><p>Hot Obserable:创建后Obserable就立马发送事件，都不支持背压</p></li><li><p>Cold Obserable:订阅后才开始发送事件，部分支持，部分不支持</p></li><li><p>解决方案就是通过下游告诉上游的被观察者降低发送速度</p></li><li><p>在RxJava1.0中，由于Obserable部分支持部分不支持，在支持背压的Obserable中 我们可以通过响应式拉取，即让观察者去通知被观察者发送事件，request，不支持背压的可以通过过滤事件结果，合并事件结果等方式来解决。</p></li><li><p>在RxJava2.0中，有了新的Flowable来解决背压，通过Flowable创建的都是非阻塞背压，注意的是这边的观察者是实现Subscriber。(Flowable的队列长度是128)</p></li></ul><h4 id="沿着别人走过的路，跟上去发现不一样的风景"><a href="#沿着别人走过的路，跟上去发现不一样的风景" class="headerlink" title="沿着别人走过的路，跟上去发现不一样的风景"></a>沿着别人走过的路，跟上去发现不一样的风景</h4><p>参考链接：</p><ul><li>转载：<a href="https://blog.csdn.net/m0_37796683/article/details/102525484" target="_blank" rel="noopener">https://blog.csdn.net/m0_37796683/article/details/102525484</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; &lt;em&gt;Rxjava2 太多方法了，记不住呀&lt;/em&gt;&lt;/p&gt;
&lt;p&gt; 总结下&lt;/p&gt;
&lt;h4 id=&quot;一、什么是Rxjava以及Obserable的多种创建方式&quot;&gt;&lt;a href=&quot;#一、什么是Rxjava以及Obserable的多种创建方式&quot; class=&quot;heade
      
    
    </summary>
    
      <category term="Android" scheme="https:mubai.site/categories/Android/"/>
    
    
      <category term="Android" scheme="https:mubai.site/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Activity 布局加载分析</title>
    <link href="https:mubai.site/2019-11-2-Activity%20%E5%B8%83%E5%B1%80%E5%8A%A0%E8%BD%BD%E5%88%86%E6%9E%90/"/>
    <id>https:mubai.site/2019-11-2-Activity 布局加载分析/</id>
    <published>2019-11-01T16:00:00.000Z</published>
    <updated>2020-05-07T08:27:26.194Z</updated>
    
    <content type="html"><![CDATA[<p> <em>关于Activity需要知道的更多内容</em></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>关于Activity的创建以及执行回调onCreate方法我们已经知道了（看这里：<a href="https://www.jianshu.com/p/3de730c145be" target="_blank" rel="noopener">https://www.jianshu.com/p/3de730c145be</a><br>），然后我们今天想知道我们在onCreate中调用setContentView方法的时候，xml是如何加载的，所以今天就跟着源码来看看。<br>ps：源码版本为 android-26</p><p>一般来说我们写一个XxxActivity都会去继承Activity、FragmentActivity、AppCompatActivity这3个的其中一个，我们今天就分别对这几个父类Activity去分析</p><ul><li>1、Activity的xml加载过程</li><li>2、FragmentActivity的xml加载过程</li><li>3、AppCompatActivity的xml加载过程</li></ul><h3 id="一、Activity的xml加载过程"><a href="#一、Activity的xml加载过程" class="headerlink" title="一、Activity的xml加载过程"></a>一、Activity的xml加载过程</h3><p>进入我们setContentView方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">## Activity</span><br><span class="line">public void setContentView(@LayoutRes int layoutResID) &#123;</span><br><span class="line">      getWindow().setContentView(layoutResID);//1、调用phoneWindow的setContentView方法</span><br><span class="line">      initWindowDecorActionBar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这边注释的地方getWindow方法获取的一个window对象，它的实现类是PhoneWindow，它在Activity的attach中进行创建出来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">## Activity</span><br><span class="line">final void attach(Context context, ...,</span><br><span class="line">           Window window, ActivityConfigCallback activityConfigCallback) &#123;</span><br><span class="line">       ...</span><br><span class="line">       mWindow = new PhoneWindow(this, window, activityConfigCallback);//这边进行window对象的初始化</span><br><span class="line">       ...</span><br><span class="line">       mWindow.setColorMode(info.colorMode);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>我们跟进PhoneWindow，看看它里面的setContentView方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">##PhoneWindow</span><br><span class="line">@Override</span><br><span class="line">public void setContentView(int layoutResID) &#123;</span><br><span class="line">    if (mContentParent == null) &#123;</span><br><span class="line">        installDecor();//1、加载DecorView</span><br><span class="line">    &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        mContentParent.removeAllViews();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,</span><br><span class="line">                getContext());</span><br><span class="line">        transitionTo(newScene);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mLayoutInflater.inflate(layoutResID, mContentParent);//2、布局加载器</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注释1是加载DecorView，注释2通过布局加载器将xml解析成view树，并且将view树添加到mContentParent中</p><h4 id="1、加载DecorView"><a href="#1、加载DecorView" class="headerlink" title="1、加载DecorView"></a>1、加载DecorView</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">### PhoneWindow</span><br><span class="line">/**</span><br><span class="line"> * 加载DecorView</span><br><span class="line"> */</span><br><span class="line">private void installDecor() &#123;</span><br><span class="line">        mForceDecorInstall = false;</span><br><span class="line">        if (mDecor == null) &#123;</span><br><span class="line">            mDecor = generateDecor(-1);//1、创建DecorView</span><br><span class="line">            ...</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mDecor.setWindow(this);//2、DecorView绑定到Window</span><br><span class="line">        &#125;</span><br><span class="line">        if (mContentParent == null) &#123;</span><br><span class="line">            mContentParent = generateLayout(mDecor);//3、根据DecorView生成Layout，得到一个mContentParent</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * 1、创建DecorView</span><br><span class="line"> */</span><br><span class="line">protected DecorView generateDecor(int featureId) &#123;</span><br><span class="line">    ... //这边去创建DecorView</span><br><span class="line">    return new DecorView(context, featureId, this, getAttributes());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> *2、调用DecorView的setWindow，传入PhoneWindow对象</span><br><span class="line"> */</span><br><span class="line"> void setWindow(PhoneWindow phoneWindow) &#123;</span><br><span class="line">        mWindow = phoneWindow;</span><br><span class="line">        ...</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> *3、根据DecorView生成Layout</span><br><span class="line"> */</span><br><span class="line">protected ViewGroup generateLayout(DecorView decor) &#123;</span><br><span class="line">    // Apply data from current theme.</span><br><span class="line">    //1、获取当前的主题，然后设置相关数据到window上</span><br><span class="line">    TypedArray a = getWindowStyle();</span><br><span class="line">    ...</span><br><span class="line">    mIsFloating = a.getBoolean(R.styleable.Window_windowIsFloating, false);//2、当前Window是否浮动在上面，默认为false</span><br><span class="line">    int flagsToUpdate = (FLAG_LAYOUT_IN_SCREEN|FLAG_LAYOUT_INSET_DECOR)</span><br><span class="line">            &amp; (~getForcedWindowFlags());</span><br><span class="line">    if (mIsFloating) &#123;</span><br><span class="line">        setLayout(WRAP_CONTENT, WRAP_CONTENT);//3、传入window的宽、高</span><br><span class="line">        setFlags(0, flagsToUpdate);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        setFlags(FLAG_LAYOUT_IN_SCREEN|FLAG_LAYOUT_INSET_DECOR, flagsToUpdate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (a.getBoolean(R.styleable.Window_windowNoTitle, false)) &#123;//4、window是否有title</span><br><span class="line">        requestFeature(FEATURE_NO_TITLE);//5、请求指定Window的风格，它必须在setContentView之前</span><br><span class="line">    &#125; else if (a.getBoolean(R.styleable.Window_windowActionBar, false)) &#123;</span><br><span class="line">        // Don&apos;t allow an action bar if there is no title.</span><br><span class="line">        requestFeature(FEATURE_ACTION_BAR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    //6、这边会很多的设置窗口属性的判断和方法，具体可以大家可以去看源码</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    // Inflate the window decor.</span><br><span class="line">    //7、根据上面设置的窗口的属性 ，设置相应的 layoutResource</span><br><span class="line">    int layoutResource;</span><br><span class="line">    int features = getLocalFeatures();</span><br><span class="line">    if ((features &amp; (1 &lt;&lt; FEATURE_SWIPE_TO_DISMISS)) != 0) &#123;</span><br><span class="line">        layoutResource = R.layout.screen_swipe_dismiss;</span><br><span class="line">        setCloseOnSwipeEnabled(true);</span><br><span class="line">    &#125; else if ((features &amp; ((1 &lt;&lt; FEATURE_LEFT_ICON) | (1 &lt;&lt; FEATURE_RIGHT_ICON))) != 0) &#123;</span><br><span class="line">        if (mIsFloating) &#123;</span><br><span class="line">            TypedValue res = new TypedValue();</span><br><span class="line">            getContext().getTheme().resolveAttribute(</span><br><span class="line">                    R.attr.dialogTitleIconsDecorLayout, res, true);</span><br><span class="line">            layoutResource = res.resourceId;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            layoutResource = R.layout.screen_title_icons;</span><br><span class="line">        &#125;</span><br><span class="line">        removeFeature(FEATURE_ACTION_BAR);</span><br><span class="line">    &#125; else if ((features &amp; ((1 &lt;&lt; FEATURE_PROGRESS) | (1 &lt;&lt; FEATURE_INDETERMINATE_PROGRESS))) != 0</span><br><span class="line">            &amp;&amp; (features &amp; (1 &lt;&lt; FEATURE_ACTION_BAR)) == 0) &#123;</span><br><span class="line">        layoutResource = R.layout.screen_progress;</span><br><span class="line">    &#125; else if ((features &amp; (1 &lt;&lt; FEATURE_CUSTOM_TITLE)) != 0) &#123;</span><br><span class="line">        if (mIsFloating) &#123;</span><br><span class="line">            TypedValue res = new TypedValue();</span><br><span class="line">            getContext().getTheme().resolveAttribute(</span><br><span class="line">                    R.attr.dialogCustomTitleDecorLayout, res, true);</span><br><span class="line">            layoutResource = res.resourceId;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            layoutResource = R.layout.screen_custom_title;</span><br><span class="line">        &#125;</span><br><span class="line">        removeFeature(FEATURE_ACTION_BAR);</span><br><span class="line">    &#125; else if ((features &amp; (1 &lt;&lt; FEATURE_NO_TITLE)) == 0) &#123;</span><br><span class="line">        if (mIsFloating) &#123;</span><br><span class="line">            TypedValue res = new TypedValue();</span><br><span class="line">            getContext().getTheme().resolveAttribute(</span><br><span class="line">                    R.attr.dialogTitleDecorLayout, res, true);</span><br><span class="line">            layoutResource = res.resourceId;</span><br><span class="line">        &#125; else if ((features &amp; (1 &lt;&lt; FEATURE_ACTION_BAR)) != 0) &#123;</span><br><span class="line">            layoutResource = a.getResourceId(</span><br><span class="line">                  R.styleable.Window_windowActionBarFullscreenDecorLayout,</span><br><span class="line">                    R.layout.screen_action_bar);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            layoutResource = R.layout.screen_title;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if ((features &amp; (1 &lt;&lt; FEATURE_ACTION_MODE_OVERLAY)) != 0) &#123;</span><br><span class="line">        layoutResource = R.layout.screen_simple_overlay_action_mode;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // Embedded, so no decoration is needed.</span><br><span class="line">        layoutResource = R.layout.screen_simple;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mDecor.startChanging();//8、开始DecorView的变化</span><br><span class="line">    mDecor.onResourcesLoaded(mLayoutInflater, layoutResource);//9、根据布局文件xml加载得到View树</span><br><span class="line"></span><br><span class="line">    ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);//10、根据content id返回一个contentParent，是一个viewGroup</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    mDecor.finishChanging(); //11、结束DecorView的变化</span><br><span class="line"></span><br><span class="line">    return contentParent; //12、返回一个contentParent</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面这段源码中，我们主要是做了几件事：</p><ul><li>1、注释1这里的样式通常是用来描述窗口的，通常view的样式是通过layout来描述的，而窗口的样式是通过Androidmanifest.xml来配置的，所以我们这里通过调用getWindowStyle方法，然后得到一个TypedArray对象，这个类我们比较熟悉，在我们自定义View的时候，如果需要自定义style，我们都会在初始化的时候得到一个TypedArray对象，然后去设置相关的样式。</li><li>2、注释2返回一个boolean值，表示我们的window是否悬浮在上面，然后根据这个值去设置相关的window宽高和其他的标签，注释4和注释6的地方判断window是否有title或者是否没有ActionBar，然后通过注释5的地方调用requestFeature去设置相关属性，所以我们这边会是否能联想到我们去如果在Activity的onCreat方法里去设置全屏的时候，需要在setConentView之前去设置，因为在setContentView之后的话，installDecor方法就已经执行完毕了，那我们设置的window属性就没有作用了。</li><li>3、注释7的地方根据上面设置的窗口的属性，来设置相关的layoutResource，我们可以去源码中查找相应的layout，具体位置在：frameworks/base/core/res/res/layout下<br><img src="https://upload-images.jianshu.io/upload_images/4248391-c7d5b09e0da27884.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/540" alt="image.png"></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">##screen_simple</span><br><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    android:fitsSystemWindows=&quot;true&quot;</span><br><span class="line">    android:orientation=&quot;vertical&quot;&gt;</span><br><span class="line">    &lt;ViewStub android:id=&quot;@+id/action_mode_bar_stub&quot;</span><br><span class="line">              android:inflatedId=&quot;@+id/action_mode_bar&quot;</span><br><span class="line">              android:layout=&quot;@layout/action_mode_bar&quot;</span><br><span class="line">              android:layout_width=&quot;match_parent&quot;</span><br><span class="line">              android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">              android:theme=&quot;?attr/actionBarTheme&quot; /&gt;</span><br><span class="line">    &lt;FrameLayout</span><br><span class="line">         android:id=&quot;@android:id/content&quot;</span><br><span class="line">         android:layout_width=&quot;match_parent&quot;</span><br><span class="line">         android:layout_height=&quot;match_parent&quot;</span><br><span class="line">         android:foregroundInsidePadding=&quot;false&quot;</span><br><span class="line">         android:foregroundGravity=&quot;fill_horizontal|top&quot;</span><br><span class="line">         android:foreground=&quot;?android:attr/windowContentOverlay&quot; /&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/4248391-8f83b29234587d89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/540" alt="image.png"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">##screen_simple_overlay_action_mode</span><br><span class="line">&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    android:fitsSystemWindows=&quot;true&quot;&gt;</span><br><span class="line">    &lt;FrameLayout</span><br><span class="line">         android:id=&quot;@android:id/content&quot;</span><br><span class="line">         android:layout_width=&quot;match_parent&quot;</span><br><span class="line">         android:layout_height=&quot;match_parent&quot;</span><br><span class="line">         android:foregroundInsidePadding=&quot;false&quot;</span><br><span class="line">         android:foregroundGravity=&quot;fill_horizontal|top&quot;</span><br><span class="line">         android:foreground=&quot;?android:attr/windowContentOverlay&quot; /&gt;</span><br><span class="line">    &lt;ViewStub android:id=&quot;@+id/action_mode_bar_stub&quot;</span><br><span class="line">              android:inflatedId=&quot;@+id/action_mode_bar&quot;</span><br><span class="line">              android:layout=&quot;@layout/action_mode_bar&quot;</span><br><span class="line">              android:layout_width=&quot;match_parent&quot;</span><br><span class="line">              android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">              android:theme=&quot;?attr/actionBarTheme&quot; /&gt;</span><br><span class="line">&lt;/FrameLayout&gt;</span><br></pre></td></tr></table></figure></p><p>我们能够发现这几个layout里面都包含了一个id为content的FrameLayout，它是用来添加我们自己的布局。</p><ul><li>4、注释9根据我们上面得到的布局文件加载onResourcesLoaded得到view树<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">##DecorView</span><br><span class="line">void onResourcesLoaded(LayoutInflater inflater, int layoutResource) &#123;</span><br><span class="line">    ...</span><br><span class="line">   //创建一个DecorCaptionView，它是Decor的标题View, 它包含了标题和窗口控件按钮，它的可见性取决于工作空间和窗口类型</span><br><span class="line">    mDecorCaptionView = createDecorCaptionView(inflater);</span><br><span class="line">    final View root = inflater.inflate(layoutResource, null);//1、用LayoutInflate来加载xml布局文件得到view</span><br><span class="line">    //2、 若不 null 则先添加 mDecorCaptionView, 再向 mDecorCaptionView 中添加 root</span><br><span class="line">    if (mDecorCaptionView != null) &#123;</span><br><span class="line">        if (mDecorCaptionView.getParent() == null) &#123;</span><br><span class="line">            //将 mDecorCaptionView 添加到DecorView</span><br><span class="line">            addView(mDecorCaptionView,</span><br><span class="line">                    new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));</span><br><span class="line">        &#125;</span><br><span class="line">        //获取的到root add到 mDecorCaptionView 中</span><br><span class="line">        mDecorCaptionView.addView(root,</span><br><span class="line">                new ViewGroup.MarginLayoutParams(MATCH_PARENT, MATCH_PARENT));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 3、若mDecorCaptionView为 null, 则直接添加调用addView将 root 加到 DecorView 中</span><br><span class="line">        // Put it below the color views.</span><br><span class="line">        addView(root, 0, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));</span><br><span class="line">    &#125;</span><br><span class="line">    // 4、强转成 ViewGroup, 传递给 mContentRoot</span><br><span class="line">    mContentRoot = (ViewGroup) root;</span><br><span class="line">    initializeElevation();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private DecorCaptionView createDecorCaptionView(LayoutInflater inflater) &#123;</span><br><span class="line">    ...</span><br><span class="line">   //这里将源码稍微变动下，直接调用inflateDecorCaptionView方法</span><br><span class="line">    DecorCaptionView decorCaptionView =  inflateDecorCaptionView(inflater)</span><br><span class="line">    ...</span><br><span class="line">    return decorCaptionView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private DecorCaptionView inflateDecorCaptionView(LayoutInflater inflater) &#123;</span><br><span class="line">    final Context context = getContext();</span><br><span class="line">    inflater = inflater.from(context);</span><br><span class="line">    //这边通过LayoutInflater来获到DecorCaptionView</span><br><span class="line">    final DecorCaptionView view = (DecorCaptionView) inflater.inflate(R.layout.decor_caption,</span><br><span class="line">            null);</span><br><span class="line">    setDecorCaptionShade(context, view);</span><br><span class="line">    return view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>可以看到在onResourcesLoaded这里是我们做了4件事：</p><ul><li>4.1、注释1是根据LayoutInflate加载xml布局文件得到View对象 root</li><li>4.2、注释2判断DecorCaptionView是否为null，不为null，先去添加DecorCaptionView，再去添加root（DecorCaptionView是一个标题view，这个类表示用于控制自由格式上窗口的特殊屏幕元素）</li><li>4.3、注释3如果DecorCaptionView为null，就直接将root添加到DecorView中</li><li>4.4、注释4是将root强转成一个ViewGroup并传递给mContentRoot</li></ul><ul><li>5、在注释10这里根据我们的ID_ANDROID_CONTENT通过findViewById返回一个contentParent，它是我们在步骤3中的DecorView中mContentRoot中的FrameLayout的Id，也就是我们通过setContentView将布局添加进去的地方。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">##Window</span><br><span class="line"> public static final int ID_ANDROID_CONTENT = com.android.internal.R.id.content</span><br></pre></td></tr></table></figure></li></ul><h4 id="2、布局加载器加载xml生成View树"><a href="#2、布局加载器加载xml生成View树" class="headerlink" title="2、布局加载器加载xml生成View树"></a>2、布局加载器加载xml生成View树</h4><p>通过LayoutInflater布局加载器去生成View树<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">##LayoutInflater</span><br><span class="line">public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) &#123;</span><br><span class="line">    final Resources res = getContext().getResources();</span><br><span class="line">    ...</span><br><span class="line">    final XmlResourceParser parser = res.getLayout(resource);//1、根据xml id 得到一个xml解析器资源</span><br><span class="line">    try &#123;</span><br><span class="line">        return inflate(parser, root, attachToRoot);//2、传入xml解析器资源和mContentParent</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        parser.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>1、注释1得到一个xml解析器资源</li><li>2、注释3 调用inflate返回view<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">##LayoutInflater</span><br><span class="line">public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) &#123;</span><br><span class="line">    synchronized (mConstructorArgs) &#123;</span><br><span class="line">        ...</span><br><span class="line">        View result = root;//1、它就是我们最终返回的view对象</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            // Look for the root node.</span><br><span class="line">            int type;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">          </span><br><span class="line">            final String name = parser.getName();//XmlPullParser解析xml，获取里面的标签name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            if (TAG_MERGE.equals(name)) &#123;//这里获取的name如果是merge，则root不能为null，否则会抛出异常</span><br><span class="line">                if (root == null || !attachToRoot) &#123;</span><br><span class="line">                    throw new InflateException(&quot;&lt;merge /&gt; can be used only with a valid &quot;</span><br><span class="line">                            + &quot;ViewGroup root and attachToRoot=true&quot;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                rInflate(parser, root, inflaterContext, attrs, false);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // Temp is the root view that was found in the xml</span><br><span class="line">                //2、这边创建得到一个临时的view对象 temp</span><br><span class="line">                final View temp = createViewFromTag(root, name, inflaterContext, attrs);</span><br><span class="line"></span><br><span class="line">                ViewGroup.LayoutParams params = null;</span><br><span class="line"></span><br><span class="line">                ...</span><br><span class="line">                if (root != null &amp;&amp; attachToRoot) &#123;//3、这边判断如果root不为null，则将临时的view对象temp添加到root中</span><br><span class="line">                    root.addView(temp, params);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (root == null || !attachToRoot) &#123;//4、如果root为null，将temp传递给我们的最终view</span><br><span class="line">                    result = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>这里通过一系列的判断和传递最终会得到一个View对象，它就是我们根据xml去解析加载出来的View树。</p><p>附加一张window和contentView的层次结构图</p><p><img src="https://upload-images.jianshu.io/upload_images/4147272-00b5f60232885fac.jpg" alt="image.png"></p><h3 id="二、AppCompatActivity的xml加载"><a href="#二、AppCompatActivity的xml加载" class="headerlink" title="二、AppCompatActivity的xml加载"></a>二、AppCompatActivity的xml加载</h3><p>跟进AppCompatActivity的setContentView方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">##AppCompatActivity</span><br><span class="line">@Override</span><br><span class="line">public void setContentView(@LayoutRes int layoutResID) &#123;</span><br><span class="line">    getDelegate().setContentView(layoutResID);//调用getDelegate的setContentView</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这边的getDelegate返回的是一个AppCompatDelegate，它是一个抽象类，这边我们跟踪发现最后是在AppCompatDelegateImplV9中调用了setContentView方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">##AppCompatDelegateImplV9</span><br><span class="line">@Override</span><br><span class="line">public void setContentView(int resId) &#123;</span><br><span class="line">    ensureSubDecor();//1、创建DecorView</span><br><span class="line">    ViewGroup contentParent = (ViewGroup) mSubDecor.findViewById(android.R.id.content);//2、这边根据content id去返回一个contentParent</span><br><span class="line">    contentParent.removeAllViews();</span><br><span class="line">    LayoutInflater.from(mContext).inflate(resId, contentParent);//3、通过LayoutInflater布局加载器将xml解析得到View树，添加到contentParent中</span><br><span class="line">    mOriginalWindowCallback.onContentChanged();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="1、注释1创建DecorView"><a href="#1、注释1创建DecorView" class="headerlink" title="1、注释1创建DecorView"></a>1、注释1创建DecorView</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">##AppCompatDelegateImplV9</span><br><span class="line">private void ensureSubDecor() &#123;</span><br><span class="line">    if (!mSubDecorInstalled) &#123;</span><br><span class="line">        mSubDecor = createSubDecor();//调用createSubDecor方法</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private ViewGroup createSubDecor() &#123;</span><br><span class="line">    TypedArray a = mContext.obtainStyledAttributes(R.styleable.AppCompatTheme);</span><br><span class="line"></span><br><span class="line">//获取当前的主题，然后设置相关数据到window上</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    mWindow.getDecorView();//1、调用PhoneWindow的getDecorView方法</span><br><span class="line"></span><br><span class="line">    final LayoutInflater inflater = LayoutInflater.from(mContext);</span><br><span class="line">    ViewGroup subDecor = null;//定义一个viewgroup</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //2、根据window的样式不同去加载不同的layout</span><br><span class="line">    if (!mWindowNoTitle) &#123;</span><br><span class="line">        if (mIsFloating) &#123;</span><br><span class="line">           ...</span><br><span class="line">            subDecor = (ViewGroup) inflater.inflate(</span><br><span class="line">                    R.layout.abc_dialog_title_material, null);</span><br><span class="line">            ...</span><br><span class="line">        &#125; else if (mHasActionBar) &#123;</span><br><span class="line">           ...</span><br><span class="line">            subDecor = (ViewGroup) LayoutInflater.from(themedContext)</span><br><span class="line">                    .inflate(R.layout.abc_screen_toolbar, null);</span><br><span class="line">          ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (mOverlayActionMode) &#123;</span><br><span class="line">            subDecor = (ViewGroup) inflater.inflate(</span><br><span class="line">                    R.layout.abc_screen_simple_overlay_action_mode, null);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            subDecor = (ViewGroup) inflater.inflate(R.layout.abc_screen_simple, null);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">   //3、下面具体分析</span><br><span class="line">    // Make the decor optionally fit system windows, like the window&apos;s decor</span><br><span class="line">    ViewUtils.makeOptionalFitsSystemWindows(subDecor);</span><br><span class="line"></span><br><span class="line">    final ContentFrameLayout contentView = (ContentFrameLayout) subDecor.findViewById(</span><br><span class="line">            R.id.action_bar_activity_content);</span><br><span class="line"></span><br><span class="line">    final ViewGroup windowContentView = (ViewGroup) mWindow.findViewById(android.R.id.content);</span><br><span class="line">    if (windowContentView != null) &#123;</span><br><span class="line">        while (windowContentView.getChildCount() &gt; 0) &#123;</span><br><span class="line">            final View child = windowContentView.getChildAt(0);</span><br><span class="line">            windowContentView.removeViewAt(0);</span><br><span class="line">            contentView.addView(child);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Change our content FrameLayout to use the android.R.id.content id.</span><br><span class="line">        // Useful for fragments.</span><br><span class="line">        windowContentView.setId(View.NO_ID);</span><br><span class="line">        contentView.setId(android.R.id.content);</span><br><span class="line"></span><br><span class="line">        // The decorContent may have a foreground drawable set (windowContentOverlay).</span><br><span class="line">        // Remove this as we handle it ourselves</span><br><span class="line">        if (windowContentView instanceof FrameLayout) &#123;</span><br><span class="line">            ((FrameLayout) windowContentView).setForeground(null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //4、调用PhoneWindow的setContentView方法</span><br><span class="line">    // Now set the Window&apos;s content view with the decor</span><br><span class="line">    mWindow.setContentView(subDecor);</span><br><span class="line">    ...</span><br><span class="line">    return subDecor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ensureSubDecor调用了createSubDecor方法：</p><ul><li><p>1、注释1调用了PhoneWindow的getDecorView方法，我们可以看到这里去调用了installDecor方法，这个方法我们在本篇的Activity的xml加载过程已经分析过了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">##PhoneWindow</span><br><span class="line">@Override</span><br><span class="line">public final View getDecorView() &#123;</span><br><span class="line">    if (mDecor == null || mForceDecorInstall) &#123;</span><br><span class="line">        installDecor();</span><br><span class="line">    &#125;</span><br><span class="line">    return mDecor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>2、注释2根据不同的window主题样式去加载不同的layout，然后通过布局加载器将xml解析成subDecor，每一个layout中都会include一个名为abc_screen_content_include.xml的layout，这个layout包含id为action_bar_activity_content的ContentFrameLayout。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">源码位置：/frameworks/support/v7/appcompat/res/layout/abc_dialog_title_material.xml</span><br><span class="line"></span><br><span class="line">##abc_screen_simple_overlay_action_mode</span><br><span class="line">&lt;android.support.v7.widget.FitWindowsFrameLayout</span><br><span class="line">        xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">        android:id=&quot;@+id/action_bar_root&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;</span><br><span class="line">        android:fitsSystemWindows=&quot;true&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;include layout=&quot;@layout/abc_screen_content_include&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;android.support.v7.widget.ViewStubCompat</span><br><span class="line">            android:id=&quot;@+id/action_mode_bar_stub&quot;</span><br><span class="line">            android:inflatedId=&quot;@+id/action_mode_bar&quot;</span><br><span class="line">            android:layout=&quot;@layout/abc_action_mode_bar&quot;</span><br><span class="line">            android:layout_width=&quot;match_parent&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/android.support.v7.widget.FitWindowsFrameLayout&gt;</span><br><span class="line"></span><br><span class="line">##abc_screen_content_include</span><br><span class="line">&lt;merge xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;android.support.v7.widget.ContentFrameLayout</span><br><span class="line">            android:id=&quot;@id/action_bar_activity_content&quot;</span><br><span class="line">            android:layout_width=&quot;match_parent&quot;</span><br><span class="line">            android:layout_height=&quot;match_parent&quot;</span><br><span class="line">            android:foregroundGravity=&quot;fill_horizontal|top&quot;</span><br><span class="line">            android:foreground=&quot;?android:attr/windowContentOverlay&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/merge&gt;</span><br></pre></td></tr></table></figure></li><li><p>3、在注释3调用调用findViewById找到id为action_bar_activity_content的contentView，然后在通过PhoneWindow找到id为content的windowContentView，然后去循环遍历windowContentView，将它的的子View添加到contentView中去，然后在把windowContentView的id设置为-1，contentView的id设置为原来windowContentView的id content，这个地方可以简单的理解为就是将DecorView(windowContentView)中的view转移到subDecor(contentView)中。</p></li><li><p>4、注释4调用PhoneWindow的setContentView方法，将subDecor传递进去，然后将subDecor存放到mContentParent中，这边我们可以发现它和上一部分(Activity)的区别，在Activity中mContentParent是直接用来存放我们自定义xml布局的，在AppCompatActivity中，mContentParent会先存放一个subDecor，然后在subDecor才是真正存放我们的自定义xml布局。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">##PhoneWindow</span><br><span class="line">@Override</span><br><span class="line">public void setContentView(View view) &#123;</span><br><span class="line">    setContentView(view, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void setContentView(View view, ViewGroup.LayoutParams params) &#123;</span><br><span class="line">    if (mContentParent == null) &#123;</span><br><span class="line">        installDecor();</span><br><span class="line">    &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        mContentParent.removeAllViews();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        view.setLayoutParams(params);</span><br><span class="line">        final Scene newScene = new Scene(mContentParent, view);</span><br><span class="line">        transitionTo(newScene);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mContentParent.addView(view, params);</span><br><span class="line">    &#125;</span><br><span class="line">    mContentParent.requestApplyInsets();</span><br><span class="line">    final Callback cb = getCallback();</span><br><span class="line">    if (cb != null &amp;&amp; !isDestroyed()) &#123;</span><br><span class="line">        cb.onContentChanged();</span><br><span class="line">    &#125;</span><br><span class="line">    mContentParentExplicitlySet = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>一张层次结构图带你理解：</p><p><img src="https://upload-images.jianshu.io/upload_images/19552390-f9a55e06bc240d60.png" alt="image.png"></p><h3 id="三、FragmentActivity的xml加载"><a href="#三、FragmentActivity的xml加载" class="headerlink" title="三、FragmentActivity的xml加载"></a>三、FragmentActivity的xml加载</h3><p>关于FragmentActivity，我们可以发现它自己是没有实现setContentView的，它是直接调用了父类Activity的setContentView方法，所以我们可以看上面的Activity的xml加载过程就可以了。<br>但是为什么会有FragmentActivity以及它的作用呢，这就要从Fragment说起来，在Android3.0以前是没有Fragment的，为了能让3.0以前能使用Fragment我们需要引入了support包，然后去继承FragmentActivity就可以使用Fragment，在3.0以后我们可以选择直接继承Activity，就可以正常使用Fragment了。而且3.0以前获取FragmentManager的方法是getSupportFragmentManager，3.0以后直接用getFragmentManager就可以了。<br>关于Fragment和FragmentManager我们会在另外的文字里进行分析，这里就不多讲。</p><p>ps：关于FragmentActivity的api原文</p><p>FragmentActivity is a special activity provided in the Support Library to handle fragments on system versions older than API level 11. If the lowest system version you support is API level 11 or higher, then you can use a regular Activity.</p><h4 id="沿着别人走过的路，跟上去发现不一样的风景"><a href="#沿着别人走过的路，跟上去发现不一样的风景" class="headerlink" title="沿着别人走过的路，跟上去发现不一样的风景"></a>沿着别人走过的路，跟上去发现不一样的风景</h4><p>参考链接：</p><ul><li>1、<a href="https://www.jianshu.com/p/3872219cc07a" target="_blank" rel="noopener">https://www.jianshu.com/p/3872219cc07a</a></li><li>2、<a href="https://www.jianshu.com/p/fc717b47b322" target="_blank" rel="noopener">https://www.jianshu.com/p/fc717b47b322</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; &lt;em&gt;关于Activity需要知道的更多内容&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;关于Activity的创建以及执行回调onCreate方法我们已经
      
    
    </summary>
    
      <category term="Android" scheme="https:mubai.site/categories/Android/"/>
    
    
      <category term="Android" scheme="https:mubai.site/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Application的创建、Activity的创建</title>
    <link href="https:mubai.site/2019-10-28-Application%E7%9A%84%E5%88%9B%E5%BB%BA%E3%80%81Activity%E7%9A%84%E5%88%9B%E5%BB%BA/"/>
    <id>https:mubai.site/2019-10-28-Application的创建、Activity的创建/</id>
    <published>2019-10-27T16:00:00.000Z</published>
    <updated>2020-05-07T08:27:31.948Z</updated>
    
    <content type="html"><![CDATA[<p> <em>关于Activity需要知道的更多内容</em></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Activity作为作为四大组件中我们最常见的一个组件，经常接触使用，但是往往每次让我们对这个组件进行说明的时候，我们只知道它的几个生命周期，几种启动模式，但是具体的更多的就讲不出来了。<br>ps：我在写这个之前实际上也是一知半解，所以今天我们一起去看看Activity更多的东西，源码版本为 android-26</p><ul><li>1、Application的创建</li><li>2、Activity的创建和生命周期</li></ul><h4 id="一、Application的创建"><a href="#一、Application的创建" class="headerlink" title="一、Application的创建"></a>一、Application的创建</h4><p>我们知道，java程序想运行都是通过调用main方法来启动，我们的Android应用程序也是如此，但是我们每次都是直接点击手机屏幕的应用图标就直接启动了app，这时候难免有疑惑，我们为什么不需要调用main方法就可以直接启动我们的程序呢，虽然我们没有直接的去写main方法，但是实际上还是通过ActivityThread类的main方法来作为我们应用程序的入口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># ActivityThread类</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        ...</span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line">        ActivityThread thread = new ActivityThread();//1、这边new了一个ActivityThread对象</span><br><span class="line">        thread.attach(false);//2、这边去进行连接，连接什么？</span><br><span class="line">        if (sMainThreadHandler == null) &#123;</span><br><span class="line">            sMainThreadHandler = thread.getHandler();</span><br><span class="line">        &#125;</span><br><span class="line">        if (false) &#123;</span><br><span class="line">            Looper.myLooper().setMessageLogging(new</span><br><span class="line">                    LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;));</span><br><span class="line">        &#125;</span><br><span class="line">        Looper.loop();</span><br><span class="line">        throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>在ActivityThread类中，能看到一个main方法，它就是我们程序的入口，在注释1的地方，会去创建一个ActivityThread对象，在注释2的地方，调用thread的attach方法去连接，具体的连接什么我们继续看下面的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#ActivityThread类</span><br><span class="line">private void attach(boolean system) &#123;</span><br><span class="line">      ...</span><br><span class="line">      if (!system) &#123;</span><br><span class="line">          ...</span><br><span class="line">          final IActivityManager mgr = ActivityManager.getService();//1、通过AIDL，获取AMS的代理对象IActivityManager</span><br><span class="line">          try &#123;</span><br><span class="line">              mgr.attachApplication(mAppThread);//2、这边将AMS和我们的应用进程application进行连接</span><br><span class="line">          &#125; catch (RemoteException ex) &#123;</span><br><span class="line">              throw ex.rethrowFromSystemServer();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          ...</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>关于AIDL，这边不进行展开，我们关心的是注释2，这边通过AIDL将AMS和我们应用进程application进行连接，具体的是调用ActivityManagerService的attachApplication方法进行连接。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#ActivityManagerService类</span><br><span class="line">@Override</span><br><span class="line">public final void attachApplication(IApplicationThread thread) &#123;</span><br><span class="line">      synchronized (this) &#123;</span><br><span class="line">          int callingPid = Binder.getCallingPid();//1、获取pid</span><br><span class="line">          final long origId = Binder.clearCallingIdentity();</span><br><span class="line">          attachApplicationLocked(thread, callingPid);//2、传入pid进行连接</span><br><span class="line">          Binder.restoreCallingIdentity(origId);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>这边的注释1通过Binder对象获取应用的pid，注释2处调用attachApplicationLocked的方法传入pid连接application。需要注意的这边加了synchronized关键字，表示我们需要等待这里执行完毕才能下一步，也就是说我们一个应用需要当我们application被连接后才能走下面的流程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">##ActivityManagerService</span><br><span class="line">private final boolean attachApplicationLocked(IApplicationThread thread,</span><br><span class="line">                                                  int pid, int callingUid, long startSeq) &#123;</span><br><span class="line">        ProcessRecord app;  //1、进程记录类，保存相关的信息</span><br><span class="line">        long startTime = SystemClock.uptimeMillis();</span><br><span class="line">        if (pid != MY_PID &amp;&amp; pid &gt;= 0) &#123;</span><br><span class="line">            synchronized (mPidsSelfLocked) &#123;</span><br><span class="line">                app = mPidsSelfLocked.get(pid);  //2、根据id获取相关信息赋值给记录对象</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        ...</span><br><span class="line">        if (app.instr != null) &#123;  //3、判断进程是否正在活跃</span><br><span class="line">           //Application 4、绑定到当前线程</span><br><span class="line">           thread.bindApplication(processName, appInfo, providers, app.instr.mClass,</span><br><span class="line">                    profilerInfo, app.instr.mArguments, app.instr.mWatcher, app.instr.mUiAutomationConnection,</span><br><span class="line">                    testMode, mBinderTransactionTrackingEnabled, enableTrackAllocation,</span><br><span class="line">                    isRestrictedBackupMode || !normalMode, app.persistent, new Configuration(getGlobalConfiguration()),</span><br><span class="line">                    app.compat, getCommonServicesLocked(app.isolated), mCoreSettingsObserver.getCoreSettingsLocked(),</span><br><span class="line">                    buildSerial, isAutofillCompatEnabled);   </span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //Application 4、绑定到当前线程</span><br><span class="line">            thread.bindApplication(processName, appInfo, providers, null, profilerInfo,</span><br><span class="line">                    null, null, null, testMode, mBinderTransactionTrackingEnabled,</span><br><span class="line">                    enableTrackAllocation, isRestrictedBackupMode || !normalMode, app.persistent,</span><br><span class="line">                    new Configuration(getGlobalConfiguration()), app.compat, getCommonServicesLocked(app.isolated),</span><br><span class="line">                    mCoreSettingsObserver.getCoreSettingsLocked(), buildSerial, isAutofillCompatEnabled);  </span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        // See if the top visible activity is waiting to run in this process...</span><br><span class="line">        //查看顶部可见活动是否正在等待在此进程中进行</span><br><span class="line">        if (normalMode) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                //TODO 5、Activity创建的分析</span><br><span class="line">                //检测top的Activity是否在运行中等待</span><br><span class="line">                if (mStackSupervisor.attachApattachApplicationplicationLocked(app)) &#123;</span><br><span class="line">                    didSomething = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                Slog.wtf(TAG, &quot;Exception thrown launching activities in &quot; + app, e);</span><br><span class="line">                badApp = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Find any services that should be running in this process...</span><br><span class="line">        //查看在此进程中进行的服务</span><br><span class="line">        if (!badApp) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                didSomething |= mServices.attachApplicationLocked(app, processName);</span><br><span class="line">                checkTime(startTime, &quot;attachApplicationLocked: after mServices.attachApplicationLocked&quot;);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                Slog.wtf(TAG, &quot;Exception thrown starting services in &quot; + app, e);</span><br><span class="line">                badApp = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Check if a next-broadcast receiver is in this process...</span><br><span class="line">        //查看在此进程中进行的广播接收者</span><br><span class="line">        if (!badApp &amp;&amp; isPendingBroadcastProcessLocked(pid)) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                didSomething |= sendPendingBroadcastsLocked(app);</span><br><span class="line">                checkTime(startTime, &quot;attachApplicationLocked: after sendPendingBroadcastsLocked&quot;);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                // If the app died trying to launch the receiver we declare it &apos;bad&apos;</span><br><span class="line">                Slog.wtf(TAG, &quot;Exception thrown dispatching broadcasts in &quot; + app, e);</span><br><span class="line">                badApp = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Check whether the next backup agent is in this process...</span><br><span class="line">        //检测下一个备份代理是否在此进程中</span><br><span class="line">        if (!badApp &amp;&amp; mBackupTarget != null &amp;&amp; mBackupTarget.app == app) &#123;</span><br><span class="line">            if (DEBUG_BACKUP) Slog.v(TAG_BACKUP,</span><br><span class="line">                    &quot;New app is backup target, launching agent for &quot; + app);</span><br><span class="line">            notifyPackageUse(mBackupTarget.appInfo.packageName,</span><br><span class="line">                    PackageManager.NOTIFY_PACKAGE_USE_BACKUP);</span><br><span class="line">            try &#123;</span><br><span class="line">                thread.scheduleCreateBackupAgent(mBackupTarget.appInfo,</span><br><span class="line">                        compatibilityInfoForPackageLocked(mBackupTarget.appInfo),</span><br><span class="line">                        mBackupTarget.backupMode);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                Slog.wtf(TAG, &quot;Exception thrown creating backup agent in &quot; + app, e);</span><br><span class="line">                badApp = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看具体的attachApplicationLocked方法里面，注释1处创建了一个进程记录对象用来保存进程的相关信息，注释2根据id获取到相关信息赋值给记录对象，注释3先判断进行是否活跃，然后调用bindApplication的方法进行application的绑定，这边的thread是IApplicationThread对象，IApplicationThread它是一个AIDL的接口，是系统进程调用应用进程的接口，它的实现类是ApplicationThread，是一个在ActivityThread的内部类，注释5的地方是关于Activity的创建，我们这边先跳过，等我们将Application进行绑定完成后在来分析。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">##ActivityThread.ApplicationThread</span><br><span class="line">public final void bindApplication(String processName, ApplicationInfo appInfo...，String buildSerial) &#123;</span><br><span class="line"></span><br><span class="line">            if (services != null) &#123;</span><br><span class="line">                // Setup the service cache in the ServiceManager</span><br><span class="line">                ServiceManager.initServiceCache(services);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            setCoreSettings(coreSettings);//1、添加核心设置</span><br><span class="line"></span><br><span class="line">            //2、将bindApplication带进来的信息封装到AppBindData类中，通过handler发送出去</span><br><span class="line">            AppBindData data = new AppBindData();</span><br><span class="line">            data.processName = processName;</span><br><span class="line">            data.appInfo = appInfo;</span><br><span class="line">            data.providers = providers;</span><br><span class="line">            ...</span><br><span class="line">            sendMessage(H.BIND_APPLICATION, data);//3、将data通过handler发送出去，具体的WHAT 是 H.BIND_APPLICATION</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><p>在注释1会去添加一些核心的设置，我们这边就不去关注，我们看注释2的地方，去将带进来的信息封装到data中然后在注释3通过handler发送出去，具体的WHAT 是 H.BIND_APPLICATION。H是一个继承Handler的子类，这边我们去看下消息是如何被分发处理的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">##ActivityThread.H</span><br><span class="line">public void handleMessage(Message msg) &#123;</span><br><span class="line">            ...</span><br><span class="line">        switch (msg.what) &#123;</span><br><span class="line">            ...</span><br><span class="line">           case BIND_APPLICATION:</span><br><span class="line">                    //1、这边进行handler消息的处理 处理创建Application的消息</span><br><span class="line">                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;bindApplication&quot;);</span><br><span class="line">                    AppBindData data = (AppBindData) msg.obj;</span><br><span class="line">                    handleBindApplication(data);</span><br><span class="line">                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                    break;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这边注释1处理创建Application的消息，调用handleBindApplication的方法去绑定application<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">##ActivityThread</span><br><span class="line">private void handleBindApplication(AppBindData data) &#123;</span><br><span class="line"></span><br><span class="line">      final InstrumentationInfo ii;//1、创建InstrumentationInfo对象</span><br><span class="line"></span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line">      final ContextImpl appContext = ContextImpl.createAppContext(this, data.info); 2、 //获取application的context上下文</span><br><span class="line">      </span><br><span class="line">      //  3、加载instrumentation</span><br><span class="line">      if (ii != null) &#123;</span><br><span class="line">          ...</span><br><span class="line">          </span><br><span class="line">          mInstrumentation.init(this, instrContext, appContext, component,</span><br><span class="line">                  data.instrumentationWatcher, data.instrumentationUiAutomationConnection); //4、instrumentation初始化</span><br><span class="line">          ...</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          mInstrumentation = new Instrumentation();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      try &#123;</span><br><span class="line">        </span><br><span class="line">          Application app = data.info.makeApplication(data.restrictedBackupMode, null);//5、通过makeApplication方法创建application</span><br><span class="line"></span><br><span class="line">          ...</span><br><span class="line">          </span><br><span class="line">          // Do this after providers, since instrumentation tests generally start their</span><br><span class="line">          // test thread at this point, and we don&apos;t want that racing.</span><br><span class="line">          try &#123;</span><br><span class="line">              mInstrumentation.onCreate(data.instrumentationArgs);</span><br><span class="line">          &#125; catch (Exception e) &#123;</span><br><span class="line">              throw new RuntimeException(</span><br><span class="line">                      &quot;Exception thrown in onCreate() of &quot;</span><br><span class="line">                              + data.instrumentationName + &quot;: &quot; + e.toString(), e);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          try &#123;</span><br><span class="line">              mInstrumentation.callApplicationOnCreate(app);//6、回调application的onCreate方法</span><br><span class="line">          &#125; catch (Exception e) &#123;</span><br><span class="line">              if (!mInstrumentation.onException(app, e)) &#123;</span><br><span class="line">                  throw new RuntimeException(</span><br><span class="line">                          &quot;Unable to create application &quot; + app.getClass().getName()</span><br><span class="line">                                  + &quot;: &quot; + e.toString(), e);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">          StrictMode.setThreadPolicy(savedPolicy);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>这个方法里面处理了许多事情，注释1创建了一个InstrumentationInfo对象，在注释2获取了application的上下文，注释3和4去加载并初始化了InstrumentationInfo，注释5是我们的关键地方，通过调用makeApplication的方法创建了我们的application，我们看下makeApplication的方法都做了什么操作。然后在注释6调用InstrumentationInfo去回调application的onCreate方法，到这里我们的application就创建并且回到了我们熟悉onCreate方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">##LoadedApk</span><br><span class="line">public Application makeApplication(boolean forceDefaultAppClass,</span><br><span class="line">           Instrumentation instrumentation) &#123;</span><br><span class="line">       if (mApplication != null) &#123;//1、如果mApplication不为null，直接返回mApplication对象</span><br><span class="line">           return mApplication;</span><br><span class="line">       &#125;</span><br><span class="line">     </span><br><span class="line">       Application app = null;</span><br><span class="line">      //如果是有自定义的application，就用这个，如果没有，就用系统的application</span><br><span class="line">       String appClass = mApplicationInfo.className;</span><br><span class="line">       if (forceDefaultAppClass || (appClass == null)) &#123;</span><br><span class="line">           appClass = &quot;android.app.Application&quot;;</span><br><span class="line">       &#125;</span><br><span class="line">       try &#123;</span><br><span class="line">           //2、获得类加载器然后通过反射去new一个Appliction</span><br><span class="line">           java.lang.ClassLoader cl = getClassLoader();</span><br><span class="line">           ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this);</span><br><span class="line">           app = mActivityThread.mInstrumentation.newApplication(</span><br><span class="line">                   cl, appClass, appContext);</span><br><span class="line">           appContext.setOuterContext(app);</span><br><span class="line">       &#125; catch (Exception e) &#123;</span><br><span class="line">           ...</span><br><span class="line">       &#125;</span><br><span class="line">       mActivityThread.mAllApplications.add(app);</span><br><span class="line">       mApplication = app;//3、赋值给mApplication</span><br><span class="line"></span><br><span class="line">       if (instrumentation != null) &#123;//4、这边会为instrumentation是为null的</span><br><span class="line">           try &#123;</span><br><span class="line">               instrumentation.callApplicationOnCreate(app);//5、这边如果instrumentation不为null，才能执行到这里</span><br><span class="line">           &#125; catch (Exception e) &#123;</span><br><span class="line">               if (!instrumentation.onException(app, e)) &#123;</span><br><span class="line">                  ...</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       ...</span><br><span class="line">       return app;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这边我们首先判断mApplication如果不为null，直接返回这个对象，如果为null的话，我们通过类加载然后反射去new出一个application对象并且赋值给mApplication，还有这边因为我们在调用makeApplication方法时传入的Instrumentation是个null对象，所以我们这边不会去执行<br>callApplicationOnCreate回调onCreate方法的。具体的回调onCreate会在上面的源码注释6的地方去执行回调。</p><h4 id="二、Activity的创建"><a href="#二、Activity的创建" class="headerlink" title="二、Activity的创建"></a>二、Activity的创建</h4><p>这边我们首先需要知道Activity的状态和生命周期</p><p>状态：运行、暂停、停止、销毁(运行和暂停是不可见的，停止和销毁是不可见的)<br>生命周期：包括了常见的onCreate、onResume、onStart、onPause、onStop、onDestory等</p><p>上面的分析过程中我们在ActivityManagerService类中留了一个<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">##ActivityManagerService</span><br><span class="line">private final boolean attachApplicationLocked(IApplicationThread thread,</span><br><span class="line">                                                  int pid, int callingUid, long startSeq) &#123;</span><br><span class="line">        ...</span><br><span class="line"> //5、检测最可见的Activity是否在运行进程中等待，如果再则创建Activity</span><br><span class="line">        //TODO 待分析Activity的创建</span><br><span class="line">        if (mStackSupervisor.attachApplicationLocked(app)) &#123;  </span><br><span class="line">            didSomething = true;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>这边我们对它进行深入下看看是如何创建的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">##ActivityStackSupervisor</span><br><span class="line">boolean attachApplicationLocked(ProcessRecord app) throws RemoteException &#123;</span><br><span class="line">       ...</span><br><span class="line">       for (int displayNdx = mActivityDisplays.size() - 1; displayNdx &gt;= 0; --displayNdx) &#123;</span><br><span class="line">           ArrayList&lt;ActivityStack&gt; stacks = mActivityDisplays.valueAt(displayNdx).mStacks;</span><br><span class="line">           for (int stackNdx = stacks.size() - 1; stackNdx &gt;= 0; --stackNdx) &#123;</span><br><span class="line">               final ActivityStack stack = stacks.get(stackNdx);</span><br><span class="line">               if (!isFocusedStack(stack)) &#123;</span><br><span class="line">                   continue;</span><br><span class="line">               &#125;</span><br><span class="line">               //ActivityRecord来维护Activity运行时的状态信息，需要将Activity绑定到AMS，ActivityRecord才能开始Activity的生命周期</span><br><span class="line">               ActivityRecord hr = stack.topRunningActivityLocked();</span><br><span class="line">               if (hr != null) &#123;</span><br><span class="line">                   if (hr.app == null &amp;&amp; app.uid == hr.info.applicationInfo.uid</span><br><span class="line">                           &amp;&amp; processName.equals(hr.processName)) &#123;</span><br><span class="line">                       try &#123;</span><br><span class="line">                           if (realStartActivityLocked(hr, app, true, true)) &#123;//1、真正的创建Activity</span><br><span class="line">                               didSomething = true;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125; catch (RemoteException e) &#123;</span><br><span class="line">                           throw e;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       ...</span><br><span class="line">       return didSomething;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>在realStartActivityLocked我们会创建Activity<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">##ActivityStackSupervisor</span><br><span class="line"> final boolean realStartActivityLocked(ActivityRecord r, ProcessRecord app,</span><br><span class="line">            boolean andResume, boolean checkConfig) throws RemoteException &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        r.startFreezingScreenLocked(app, 0);//1、开始屏幕相关的启动</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        // schedule launch ticks to collect information about slow apps.</span><br><span class="line">        r.startLaunchTickingLocked();//2、启动定时锁定</span><br><span class="line"></span><br><span class="line">        r.app = app;</span><br><span class="line">        app.waitingToKill = null;</span><br><span class="line">        r.launchCount++;//3、每启动一次launchCount的数量自增</span><br><span class="line">        r.lastLaunchTime = SystemClock.uptimeMillis();//4、修改最后一次的启动时间</span><br><span class="line"></span><br><span class="line">        final ActivityStack stack = task.getStack();</span><br><span class="line">        try &#123;</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            //5、根据具体的包名，通知应用</span><br><span class="line"></span><br><span class="line">         mService.notifyPackageUse(r.intent.getComponent().getPackageName(),</span><br><span class="line">                                      PackageManager.NOTIFY_PACKAGE_USE_ACTIVITY);</span><br><span class="line">            </span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            //6、调用ApplicationThread的scheduleLaunchActivity 方法去启动LaunchActivity</span><br><span class="line">            app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken,</span><br><span class="line">                    System.identityHashCode(r), r.info,</span><br><span class="line">                    // TODO: Have this take the merged configuration instead of separate global and</span><br><span class="line">                    // override configs.</span><br><span class="line">                    mergedConfiguration.getGlobalConfiguration(),</span><br><span class="line">                    mergedConfiguration.getOverrideConfiguration(), r.compat,</span><br><span class="line">                    r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle,</span><br><span class="line">                    r.persistentState, results, newIntents, !andResume,</span><br><span class="line">                    mService.isNextTransitionForward(), profilerInfo);</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        if (isFocusedStack(stack)) &#123;</span><br><span class="line">            mService.startSetupActivityLocked();7、开始设置活动锁</span><br><span class="line">        &#125;</span><br><span class="line">        if (r.app != null) &#123;</span><br><span class="line">            mService.mServices.updateServiceConnectionActivitiesLocked(r.app);//8、更新服务连接活动锁</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这边的注释很多，但是我们主要关心的是注释6，这边调用ApplicationThread的scheduleLaunchActivity 方法去启动LaunchActivity，我们回到ApplicationThread</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">##ActivityThread.ApplicationThread</span><br><span class="line">@Override</span><br><span class="line">public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident,</span><br><span class="line">                                       ..., ProfilerInfo profilerInfo) &#123;</span><br><span class="line"></span><br><span class="line">    updateProcessState(procState, false);</span><br><span class="line"></span><br><span class="line">    ActivityClientRecord r = new ActivityClientRecord();</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    sendMessage(H.LAUNCH_ACTIVITY, r);//通过handler发送启动Activity的消息</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这边是不是很眼熟，我们刚刚的application的绑定也是通过handler去发送消息去处理(这边我们能发现handler是有多么重要了吧，哈哈)，我们去ActivityThread的子类H去看下具体的activity创建的消息处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void handleMessage(Message msg) &#123;</span><br><span class="line">        switch (msg.what) &#123;</span><br><span class="line">            case LAUNCH_ACTIVITY: &#123;//1、接收到关于创建Activity的消息，进行处理</span><br><span class="line">                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityStart&quot;);</span><br><span class="line">                final ActivityClientRecord r = (ActivityClientRecord) msg.obj;</span><br><span class="line">                r.packageInfo = getPackageInfoNoCheck(</span><br><span class="line">                        r.activityInfo.applicationInfo, r.compatInfo);</span><br><span class="line">                handleLaunchActivity(r, null, &quot;LAUNCH_ACTIVITY&quot;);//2、去创建LaunchActivity</span><br><span class="line">                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>根据message的what值我们找到了具体的消息处理，这边会通过handleLaunchActivity去处理我们Activity创建<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">##ActivityThread</span><br><span class="line"> private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) &#123;</span><br><span class="line">        ...</span><br><span class="line">        Activity a = performLaunchActivity(r, customIntent);//1、去执行LaunchActivity</span><br><span class="line"></span><br><span class="line">        if (a != null) &#123;</span><br><span class="line">            r.createdConfig = new Configuration(mConfiguration);</span><br><span class="line">            reportSizeConfigurations(r);</span><br><span class="line">            Bundle oldState = r.state;</span><br><span class="line">            handleResumeActivity(r.token, false, r.isForward,</span><br><span class="line">                    !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason);//2、处理可见Activity</span><br><span class="line">            ...</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // If there was an error, for any reason, tell the activity manager to stop us.</span><br><span class="line">            try &#123;</span><br><span class="line">            //3、这边如何activity是个null的对象，直接通过ActivityManagerService调用finishActivity去关闭掉</span><br><span class="line">                ActivityManager.getService()</span><br><span class="line">                        .finishActivity(r.token, Activity.RESULT_CANCELED, null,</span><br><span class="line">                                Activity.DONT_FINISH_TASK_WITH_ACTIVITY);</span><br><span class="line">            &#125; catch (RemoteException ex) &#123;</span><br><span class="line">                throw ex.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这边我们先看注释1的performLaunchActivity方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">##ActivityThread</span><br><span class="line">private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        ActivityInfo aInfo = r.activityInfo;//1、获取Activity的信息</span><br><span class="line">        if (r.packageInfo == null) &#123;</span><br><span class="line">            r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo,</span><br><span class="line">                    Context.CONTEXT_INCLUDE_CODE);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        ContextImpl appContext = createBaseContextForActivity(r);//2、获取Acitivty的上下文</span><br><span class="line">        Activity activity = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            java.lang.ClassLoader cl = appContext.getClassLoader();//3、获取类加载器，使用cl(类加载器）加载出Activity，再使用反射new出Activity</span><br><span class="line">            activity = mInstrumentation.newActivity(</span><br><span class="line">                    cl, component.getClassName(), r.intent);</span><br><span class="line">            StrictMode.incrementExpectedActivityCount(activity.getClass());</span><br><span class="line">            r.intent.setExtrasClassLoader(cl);</span><br><span class="line">            r.intent.prepareToEnterProcess();</span><br><span class="line">            if (r.state != null) &#123;</span><br><span class="line">                r.state.setClassLoader(cl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">           ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            //4、这边又去调用一次makeApplication方法</span><br><span class="line">            Application app = r.packageInfo.makeApplication(false, mInstrumentation);</span><br><span class="line">            if (activity != null) &#123;</span><br><span class="line">                ...</span><br><span class="line">                appContext.setOuterContext(activity);</span><br><span class="line"></span><br><span class="line">                activity.attach(appContext, this, getInstrumentation(), r.token,</span><br><span class="line">                        r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">                        r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">                        r.referrer, r.voiceInteractor, window, r.configCallback);</span><br><span class="line"></span><br><span class="line">                ...</span><br><span class="line">                if (r.isPersistable()) &#123;//5、这边去调用Activity的onCreate方法</span><br><span class="line">                    mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">                &#125;</span><br><span class="line">                ...</span><br><span class="line"></span><br><span class="line">        &#125; catch (SuperNotCalledException e) &#123;</span><br><span class="line">            throw e;</span><br><span class="line"></span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">           ...</span><br><span class="line">        &#125;</span><br><span class="line">        return activity;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在注释3我们会发现这边是获取类加载去然后通过反射去new出一个Activity，然后在注释5去回调Activity的onCreate方法，到这边我们就能去调用我们的setContentView去加载布局了。注释4的地方又调用了一次makeApplication方法，如果Application不为null，直接返回application对象。<br>现在我们回到上一个源码的注释2那里，看看handleResumeActivity都做了什么?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">##ActivityThread</span><br><span class="line"> final void handleResumeActivity(IBinder token,</span><br><span class="line">                                    boolean clearHide, boolean isForward, boolean reallyResume, int seq, String reason) &#123;</span><br><span class="line">        ...</span><br><span class="line">        r = performResumeActivity(token, clearHide, reason);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这个方法里面有很多代码，我们只需要去看performResumeActivity方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">##ActivityThread</span><br><span class="line">public final ActivityClientRecord performResumeActivity(IBinder token, boolean clearHide, String reason) &#123;</span><br><span class="line">    ...</span><br><span class="line">    r.activity.performResume();//主要是这个方法</span><br><span class="line">    ...</span><br><span class="line">    return r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这边是调用Activity的performResume方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">##Activity</span><br><span class="line">final void performResume() &#123;</span><br><span class="line">        performRestart();</span><br><span class="line"></span><br><span class="line">        mFragments.execPendingActions();</span><br><span class="line"></span><br><span class="line">        mLastNonConfigurationInstances = null;</span><br><span class="line"></span><br><span class="line">        mCalled = false;</span><br><span class="line">        // mResumed is set by the instrumentation</span><br><span class="line">        mInstrumentation.callActivityOnResume(this);//回调Activity的onResume方法</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>到这边我们就能发现它跟Activity的onCreate的回调是类似的，都是通过mInstrumentation.callActivityxxx去回调执行。</p><h4 id="沿着别人走过的路，跟上去发现不一样的风景"><a href="#沿着别人走过的路，跟上去发现不一样的风景" class="headerlink" title="沿着别人走过的路，跟上去发现不一样的风景"></a>沿着别人走过的路，跟上去发现不一样的风景</h4><p>参考链接：<a href="https://www.jianshu.com/p/f55467033146" target="_blank" rel="noopener">https://www.jianshu.com/p/f55467033146</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; &lt;em&gt;关于Activity需要知道的更多内容&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;Activity作为作为四大组件中我们最常见的一个组件，经常接触使
      
    
    </summary>
    
      <category term="Android" scheme="https:mubai.site/categories/Android/"/>
    
    
      <category term="Android" scheme="https:mubai.site/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>5.1节日旅游攻略</title>
    <link href="https:mubai.site/2019-3-31-5.1%E6%97%85%E6%B8%B8%E6%94%BB%E7%95%A5/"/>
    <id>https:mubai.site/2019-3-31-5.1旅游攻略/</id>
    <published>2019-03-30T16:00:00.000Z</published>
    <updated>2019-04-03T08:48:06.696Z</updated>
    
    <content type="html"><![CDATA[<p>5.1节日旅游攻略、未完待续</p><a id="more"></a><h3 id="5-1节日旅游攻略"><a href="#5-1节日旅游攻略" class="headerlink" title="5.1节日旅游攻略"></a>5.1节日旅游攻略</h3><h4 id="第一站：乌镇"><a href="#第一站：乌镇" class="headerlink" title="第一站：乌镇"></a>第一站：乌镇</h4><pre><code>出发站：杭州出发时间：5.1 动车：        G7572：9:57    ￥21.5*2    G7316：10:12  ￥21.5*2时间：5.1-5.2酒店：乌镇小宿 ￥468门票：西栅+东栅联票 ￥190*2景点：列举了主要景点    1、西栅：最适合夜游及住宿的区域，夜晚的水上莲花可以look look        1.1、中国邮政：光绪年间的邮局        1.2、草木本色染坊：拍照        1.3、白莲塔：乌镇最高建筑        1.4、三寸金莲馆：中国女性裹足史        1.5、月老庙：许愿        1.6、邵明书院：邵明太子读书处        1.7、囍庆堂：江南婚礼        1.8、西市河：最美夜景地        1.9、天下第一锅：申请吉尼斯纪录        1.10、乌镇大剧院/大戏院：感受当地人文生活        1.11、茅盾纪念堂：纪念馆    2、东栅        2.1、茅盾故居：文学大师茅盾故居        2.2、宏源泰染坊：拍照        2.3、三白酒坊：酿酒过程        2.4、江南百床馆：中国第一家收藏、展出江南古床的博物馆        2.5、逢源双桥：按男左女右走一遍可以左右逢源        2.6、江南民俗馆：江南民俗文化展示        2.7、江南木雕陈列馆：古代木雕展览        2.8、财神湾：发财啊，去去去。        2.9、立志书院：茅盾的手稿、作品、提字        2.10、修真观广场        2.11、余榴梁钱币馆：各个国家的钱币展示    3、南栅和北栅都属于未开发的地段，原生态美食：找找看</code></pre><h4 id="第二站：苏州"><a href="#第二站：苏州" class="headerlink" title="第二站：苏州"></a>第二站：苏州</h4><pre><code>出发站：乌镇出发时间：5.2动车：        G7586：10：04    ￥85.5*2    G7572：10:126 ￥90.5*2时间：5.2-5.4酒店：苏州小院  ￥530*2景点：苏州景点太多    1、观前街        1.1、拙政园：天下园林之母，门票：70*2        1.2、苏州博物馆：苏州园林风格        1.3、平江路：苏州保存最好的古街        1.4、狮子林：叠石最有名，四大名园之一        1.5、苏州古典园林：世界文化遗产        1.6、太平天国忠王符：苏式彩绘    2、十全街        2.1、网师园：苏州四大名园之一        2.2、沧浪亭：苏州最古老园林        2.3、苏州大学：中国十大最美校园之一        2.4、苏州云岩寺塔：中国第一斜塔    3、石路商圈        3.1、虎丘：吴中第一名胜        3.2、七里山塘：姑苏第一名街        3.3、留园：小家碧玉式，四大名园之一        3.4、剑池：虎丘最神秘的名胜        3.5、万景山庄：苏派盆景精品园        3.6、山塘书院：听苏州评弹        3.7、拥翠山庄：苏州唯一无水园林    4、金鸡湖：        4.1、金鸡湖：骑行、夜景        4.2、月光码头：苏州十大最美夜景之首    5、周庄        5.1、周庄古镇：中国第一水乡        5.2、双桥：故乡的回忆蓝本        5.3、沈万三故居：沈万三        5.4、沈厅：沈万三后人的宅子        5.5、南湖秋月园：水中佛国        5.6、周庄博物馆：了解周庄历史        5.7、富安桥：周庄最古老的桥    6、同里        6.1、同里古镇：江南六大古镇之一        6.2、退思园：世界文化遗产        6.3、珍珠塔：同里最大园林        6.4、耕乐堂：同里八景之一    7、阳澄湖        7.1阳澄湖半岛旅游度假区：阳澄湖大闸蟹    8、太湖        8.1、苏州东山景区：太湖山水第一镇        8.2、苏州西山景区：太湖第一大岛美食：找找</code></pre><h4 id="终点站：杭州"><a href="#终点站：杭州" class="headerlink" title="终点站：杭州"></a>终点站：杭州</h4><pre><code>时间：5.4</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;5.1节日旅游攻略、未完待续&lt;/p&gt;
    
    </summary>
    
      <category term="闲文" scheme="https:mubai.site/categories/%E9%97%B2%E6%96%87/"/>
    
    
      <category term="闲文" scheme="https:mubai.site/tags/%E9%97%B2%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>Me</title>
    <link href="https:mubai.site/Me/"/>
    <id>https:mubai.site/Me/</id>
    <published>2019-02-19T16:00:00.000Z</published>
    <updated>2019-04-03T08:48:21.874Z</updated>
    
    <content type="html"><![CDATA[<p>个人简历，更新中</p><a id="more"></a><script src="https://cdn1.lncld.net/static/js/av-mini-0.6.10.js"></script><script src="http://jerry-cdn.b0.upaiyun.com/hit-kounter/hit-kounter-lc-0.2.0.js"></script><p><span data-hk-page="current"> - </span></p><h3 id="个人简历"><a href="#个人简历" class="headerlink" title="个人简历"></a>个人简历</h3><ul><li><strong>姓名：</strong> 林志文</li><li><strong>花名：</strong> 沐白</li><li><strong>Email：</strong> <a href="mailto:quickly520@126.com" target="_blank" rel="noopener">quickly520@126.com</a></li></ul><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><p>…</p><h4 id="工作经历"><a href="#工作经历" class="headerlink" title="工作经历"></a>工作经历</h4><ul><li><strong>杭州筑家易网络科技股份有限公司 2016.8-至今</strong></li></ul><ul><li><strong>杭州一幅画网络科技有限公司 2016.4-2016.7</strong></li></ul><h4 id="项目经历"><a href="#项目经历" class="headerlink" title="项目经历"></a>项目经历</h4><p>…</p><h4 id="自我评价"><a href="#自我评价" class="headerlink" title="自我评价"></a>自我评价</h4><p>…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;个人简历，更新中&lt;/p&gt;
    
    </summary>
    
    
      <category term="简历" scheme="https:mubai.site/tags/%E7%AE%80%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>物联网设备-WiFi/Bluetooth/ZigBee配网方式</title>
    <link href="https:mubai.site/2018-10-9-%E7%89%A9%E8%81%94%E7%BD%91%E9%80%9A%E4%BF%A1-WiFi:BT:ZigBee%E8%8A%AF%E7%89%87%E7%BA%A7%E6%96%B9%E6%A1%88%E8%A7%A3%E6%9E%90/"/>
    <id>https:mubai.site/2018-10-9-物联网通信-WiFi:BT:ZigBee芯片级方案解析/</id>
    <published>2018-10-08T16:00:00.000Z</published>
    <updated>2019-04-03T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、WIFI设备配网"><a href="#一、WIFI设备配网" class="headerlink" title="一、WIFI设备配网"></a>一、WIFI设备配网</h3><p>智能家居的设备智能化，很多家电设备都安装上了WiFi模块, 方便用户通过手机控制和远程查看家里情况，典型的设备如智能插座，智能空调，智能空气净化器。<br>智能设备首次配置，这个过程简单来讲就是把WiFi设备初始化后，连到家里的无线路由器上。第一次配置成功后，基本就一劳永逸了。</p><a id="more"></a><h4 id="1、目前流行的wifi配置模式一般有以下2种"><a href="#1、目前流行的wifi配置模式一般有以下2种" class="headerlink" title="1、目前流行的wifi配置模式一般有以下2种:"></a>1、目前流行的wifi配置模式一般有以下2种:</h4><ul><li><p>AP模式：</p><p>  智能硬件处于AP模式，手机用于station模式,手机连接智能插座的AP后组成局域网,手机发送需要连接路由的SSID及密码至智能插座,智能硬件主动去连接指定路由后,完成连接</p></li></ul><pre><code>AP（兼容） 模式AP 是 (Wireless) Access Point 的缩写，即 (无线) 访问接入点。简单来讲就像是无线路由器一样，设备打开后进入 AP 模式，在手机的网络列表里面，可以搜索到类似 TPLINK_XXX 的名字（SSID）。连接步骤：1、连接路由器（获取路由器名称）2、请求配网token，用户输入 WiFi 名字和密码后3、初始化硬件设备，使设备进入 AP 模式，Wifi 灯慢闪4、手机切回 WiFi：接入上述 设备出现的 WiFi 名字（SSID）的网络 （类似 TPLINK_XXX）。连上设备后，通过 UDP 发送 经过 AES 加密过的 ssid/password/token5、设备通过 UDP 包获取配置信息，切换网络模式，连接上家里 WiFi，配置完成。断开设备热点。发送token，注册到服务端，登录MQTT服务器6、手机切回到家里面的 WiFi ，根据token，去服务端查找设备。7、服务器返回智能设备的信息</code></pre><ul><li><p>一键配置(smartconfig)模式:</p><p>  智能硬件处于混杂模式下,监听网络中的所有报文;手机APP将SSID和密码编码到UDP报文中,通过广播包或组播报发送,智能硬件接收到UDP报文后解码,得到正确的SSID和密码,然后主动连接指定SSID的路由,完成连接</p><p>  EZ（快捷）Easy-Connect 模式</p><p>  这种快速连接方式，相对于 AP 模式连接简化操作，省了很多步骤，首次配置速度更快。</p><p>  1、手机连上 WiFi，开启 APP 软件，点击”添加新设备”，进入配置界面，输入手机所在 WiFi 密码，请求配网token</p><p>  2、智能硬件开启混杂模式监听所有网络数据包，Wifi 灯快闪</p><p>  3、手机通过广播、组播循环发送 ssid/password/token</p><p>  4、硬件设备通过 UDP 包（长度）获取配置信息捕捉到ssid/password/token，Wifi灯熄灭，连接路由器，连接成功后Wifi灯常亮。发送token，注册到服务端，注册成功后登录MQTT服务器。（广播根据 UDP 包长度，组播根据 IP 地址信息）</p><p>  5、手机根据token，去服务端查找设备，返回设备信息</p></li></ul><h4 id="2、当前主流IOT的wifi方案有"><a href="#2、当前主流IOT的wifi方案有" class="headerlink" title="2、当前主流IOT的wifi方案有:"></a>2、当前主流IOT的wifi方案有:</h4><p>这个功能最早是TI提出并应用于CC3200上;不过从原理上讲,只要芯片驱动支持开启混杂模式(WiFi Promiscuous),就可以支持一键配网功能,只是各个厂家叫法及实现编码方式不同而已;</p><p>手机编码发送采用有UDP组播或广播,不同的发送方式和编码,对应的解码过程也不一样.,当前测试发现,微信是通过UDP广播包实现的;TI是通过往一固定IP地址发送udp包;其他芯片厂家提供的一般为UDP组播方式;</p><p>由于无线数据传播必定是广播的,所以必然可以被监听到;如果AP没有加密的话,UDP直接可以把相关的信息发送出来.但是路由器AP一般都是加密的,而且加密方式不固定.wifi模块在无法直接解析出数据包</p><p>1、广播：发送方可通过改变其所需要发送数据包的长度进行控制<br>所以只要指定出一套利用长度编码的通讯协议,就可利用数据包的Lenght字段进行数据传递</p><p>2、 组播：组播地址是保留的D类地址从224.0.0.0-239.255.255.255<br>IP地址与MAC地址映射关系为:将MAC地址的前25位设定为01.00.5e,而MAC地址的后23位对应IP地址的位;故发送端可以将数据编码在组播ip的后23bit中,通过组播包发送,接收端进行解码即可</p><h3 id="二、Bluetooth配网"><a href="#二、Bluetooth配网" class="headerlink" title="二、Bluetooth配网"></a>二、Bluetooth配网</h3><h3 id="三、Zjgbee"><a href="#三、Zjgbee" class="headerlink" title="三、Zjgbee"></a>三、Zjgbee</h3><hr><p>参考资料：</p><p>Wifi:</p><blockquote><p>WLAN(Wireless Local Area Network)无线局域网络，是一个概念，网络技术术语，IEEE802.11标准是无线局域网最通用的标准<br>Wifi(Wireless Fidelity)是设备商成立的一个联盟，负责测试认证，是使用802.11技术实现的</p></blockquote><p>ZjgBee:</p><blockquote><p>目前在国内采用ZigBee协议智能家居的有3家公司的芯片，恩智浦（NXP）公司（小米智能家居采用的就是该公司的ZigBee芯片），TI公司（德州仪器）CC2530芯片（国内95%以上的公司采用该ZigBee芯片），芯科（Silicon Labs）公司（国内只有极少数公司采用该公司芯片，如聪明屋智能家居采用的是该公司的EM357芯片），该芯片属于ZigBee芯片领域的工业级高性能级别，应用到智能家居居有绝对的优势，规避了传统ZigBee芯片智能家居组网规模小、易丢包不稳定的顽疾。事实证明芯科芯片的智能网关，在保证智能家居系统稳定运行的前提下可以携带120个以上的节点，TI和恩智浦的只能带30个以内的节点。<br>另外芯科（Silicon Labs）公司又发布EFR32MG系列ZigBee芯片，其中部分芯片能同时支持4种无线协议：ZigBee、Thread、BLE（蓝牙）、Proprietary（sub GHZ，小无线），说通俗一点就是用芯科（Silicon Labs）ZigBee芯片开发的ZigBee智能家居可以兼容Thread、BLE（蓝牙）、Proprietary（sub GHZ，小无线）这3种通讯协议的产品，能和这3种通信协议的设备互联互通，技术创新遥遥领先，所以说要做好ZigBee技术智能家居，芯片选择至关重要。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、WIFI设备配网&quot;&gt;&lt;a href=&quot;#一、WIFI设备配网&quot; class=&quot;headerlink&quot; title=&quot;一、WIFI设备配网&quot;&gt;&lt;/a&gt;一、WIFI设备配网&lt;/h3&gt;&lt;p&gt;智能家居的设备智能化，很多家电设备都安装上了WiFi模块, 方便用户通过手机控制和远程查看家里情况，典型的设备如智能插座，智能空调，智能空气净化器。&lt;br&gt;智能设备首次配置，这个过程简单来讲就是把WiFi设备初始化后，连到家里的无线路由器上。第一次配置成功后，基本就一劳永逸了。&lt;/p&gt;
    
    </summary>
    
      <category term="物联网" scheme="https:mubai.site/categories/%E7%89%A9%E8%81%94%E7%BD%91/"/>
    
    
      <category term="物联网" scheme="https:mubai.site/tags/%E7%89%A9%E8%81%94%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>Nexus+Maven搭建私有库</title>
    <link href="https:mubai.site/2018-7-12-Nexus+Maven%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E5%BA%93/"/>
    <id>https:mubai.site/2018-7-12-Nexus+Maven搭建私有库/</id>
    <published>2018-07-11T16:00:00.000Z</published>
    <updated>2019-04-03T08:47:42.234Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Maven：项目管理和自动构建的工具,maven包集中存放的地方就是maven仓库。这些仓库可以放在本地，也可以放在某个远程服务器上，可以是私有的，也可以是共有的。</p></blockquote><blockquote><p>Nexus：强大的maven仓库管理器，简化了本地仓库的维护和外部仓库的访问</p></blockquote><a id="more"></a><h5 id="1-下载安装Nexus3-0"><a href="#1-下载安装Nexus3-0" class="headerlink" title="1.下载安装Nexus3.0"></a>1.下载安装Nexus3.0</h5><p>nexus的下载地址：<strong><a href="https://blog.sonatype.com/" target="_blank" rel="noopener">https://blog.sonatype.com/</a></strong></p><h5 id="2-启动Nexus"><a href="#2-启动Nexus" class="headerlink" title="2.启动Nexus"></a>2.启动Nexus</h5><p>将下载后的zip解压到某个路径下执行</p><blockquote><p>/Users/***/nexus-3.12.1-01-mac/nexus-3.12.1-01/bin/nexus start</p></blockquote><p>执行成功后</p><blockquote><p>Starting nexus</p></blockquote><h5 id="3-浏览器打开Nexus"><a href="#3-浏览器打开Nexus" class="headerlink" title="3.浏览器打开Nexus"></a>3.浏览器打开Nexus</h5><p><strong><a href="http://127.0.0.1:8081/nexus/" target="_blank" rel="noopener">http://127.0.0.1:8081/nexus/</a></strong></p><blockquote><p>注：启动服务需要等待一会</p></blockquote><h5 id="4-用户登录"><a href="#4-用户登录" class="headerlink" title="4.用户登录"></a>4.用户登录</h5><p>默认的是游客身份，可以查看，但是不能配置<br>需要配置的时候使用管理员身份登录：</p><blockquote><p><strong>admin/admin123</strong></p></blockquote><h5 id="5-Blob-Stroes"><a href="#5-Blob-Stroes" class="headerlink" title="5.Blob Stroes"></a>5.Blob Stroes</h5><p>依赖index存储目录，默认存储在default下：</p><p>\sonatype-work\nexus3\blobs\default</p><p>也可以自己新建一个目录专门存在某个仓库的索引，在创建repository可以选择</p><h5 id="6-reponsitory"><a href="#6-reponsitory" class="headerlink" title="6.reponsitory"></a>6.reponsitory</h5><p>Nexus默认创建了几个仓库<br>group:是一个仓库组，包含了hosted和proxy两种库，下载时按配置顺序从中依次查找<br>hosted:一般是部署我们项目打包的jar，供内部人员下载<br>proxy：代理远程仓库，maven-central是默认maven中央仓库代理，通过代理从远程仓库中下载的依赖都会被缓存到nexus的proxy库中</p><h5 id="7-创建自己的reponsitory"><a href="#7-创建自己的reponsitory" class="headerlink" title="7.创建自己的reponsitory"></a>7.创建自己的reponsitory</h5><p>一般情况下我们会选择创建一个hosted仓库</p><p>步骤为<em>repositories –&gt; Add –&gt; hosted repository</em>，在页面的下半部分输入框中填入repository id和repository name即可，另外把deployment policy设置为Allow Redeploy，点击save就创建完成了</p><p>这边我们可以看到我们创建成功的reponsitory，这里有个仓库的地址<br><strong><a href="http://127.0.0.1:8081/repository/test-comment-release/" target="_blank" rel="noopener">http://127.0.0.1:8081/repository/test-comment-release/</a></strong><br>可以复制出来</p><h5 id="8-创建完成后我们在androidStudio创建一个项目，项目中创建一个model"><a href="#8-创建完成后我们在androidStudio创建一个项目，项目中创建一个model" class="headerlink" title="8.创建完成后我们在androidStudio创建一个项目，项目中创建一个model"></a>8.创建完成后我们在androidStudio创建一个项目，项目中创建一个model</h5><p>在根目录的build.gradle的repositories中添加：</p><p><strong>maven{ url ‘<a href="http://127.0.0.1:8081/repository/test-comment-release/&#39;}" target="_blank" rel="noopener">http://127.0.0.1:8081/repository/test-comment-release/&#39;}</a></strong></p><p>然后在model的build.gradle中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">uploadArchives &#123;</span><br><span class="line">    configuration = configurations.archives</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenDeployer &#123;</span><br><span class="line">            snapshotRepository(url: MAVEN_REPO_SNAPSHOT_URL) &#123;</span><br><span class="line">                authentication(userName: NEXUS_USERNAME, password: NEXUS_PASSWORD)</span><br><span class="line">            &#125;</span><br><span class="line">            repository(url: MAVEN_REPO_RELEASE_URL) &#123;</span><br><span class="line">                authentication(userName: NEXUS_USERNAME, password: NEXUS_PASSWORD)</span><br><span class="line">            &#125;</span><br><span class="line">            pom.project &#123;</span><br><span class="line">                version &apos;1.0.0&apos;//版本号可以直接指定</span><br><span class="line">                artifactId &apos;comment-sdk&apos;//这边的id我们可以指定</span><br><span class="line">                groupId GROUP_ID</span><br><span class="line">                packaging TYPE</span><br><span class="line">                description DESCRIPTION</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">artifacts &#123;</span><br><span class="line">    archives file(&apos;model名称.aar&apos;)//我们的model名.aar</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意的是需要在model的build.gradle中添加(使得这个model可以作为maven)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &apos;maven&apos;</span><br></pre></td></tr></table></figure><h5 id="9-在gradle-properties中添加："><a href="#9-在gradle-properties中添加：" class="headerlink" title="9.在gradle.properties中添加："></a>9.在gradle.properties中添加：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Maven仓库的URL</span><br><span class="line">MAVEN_REPO_RELEASE_URL=http://127.0.0.1:8081/repository/mubai-comment-release/  这边是正式的仓库的地址</span><br><span class="line">MAVEN_REPO_SNAPSHOT_URL=http://127.0.0.1:8081/repository/mubai-comment-snapshot/  这边是snapshot的仓库的地址</span><br><span class="line"></span><br><span class="line"># 对应maven的GroupId的值</span><br><span class="line">GROUP = com.comment.sdk  这边我们可以自己指定</span><br><span class="line">##### 登录nexus ossde的用户名</span><br><span class="line"></span><br><span class="line">NEXUS_USERNAME=admin</span><br><span class="line"># 登录nexus oss的密码</span><br><span class="line"></span><br><span class="line">NEXUS_PASSWORD=admin123</span><br><span class="line"></span><br><span class="line"># groupid</span><br><span class="line">GROUP_ID = com.comment.sdk  这边我们可以自己指定</span><br><span class="line"></span><br><span class="line"># type</span><br><span class="line">TYPE = aar</span><br><span class="line"></span><br><span class="line"># description</span><br><span class="line">DESCRIPTION = This is comment sdk 描述</span><br></pre></td></tr></table></figure><p>然后点击右侧的Gradle找到我们需要上传的model，然后里面的upload中的<strong>uploadArchives</strong>双击，然后等待上传aar成功</p><h5 id="10-上传成功后我们可以在nexus上看到我们的上传的aar"><a href="#10-上传成功后我们可以在nexus上看到我们的上传的aar" class="headerlink" title="10.上传成功后我们可以在nexus上看到我们的上传的aar"></a>10.上传成功后我们可以在nexus上看到我们的上传的aar</h5><h5 id="11-然后我们在需要用到的项目中，先去根目录build的地方添加："><a href="#11-然后我们在需要用到的项目中，先去根目录build的地方添加：" class="headerlink" title="11.然后我们在需要用到的项目中，先去根目录build的地方添加："></a>11.然后我们在需要用到的项目中，先去根目录build的地方添加：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">maven&#123; url &apos;http://可以换成服务器的ip地址:8081/repository/mubai-comment-release/&apos;&#125;</span><br></pre></td></tr></table></figure><p>然后在具体的app的build中添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#前面是我们GROUP_ID:ArtifactId:版本号(这些id我们都可以自己在配置的时候去指定)</span><br><span class="line">compile &apos;com.comment.sdk:comment-sdk-debug:1.1.0&apos;</span><br></pre></td></tr></table></figure><p>然后我们就可以引用我们aar包里面的东西</p><p><strong>实际上使用nexus只是作为一个管理aar包的托管服务器，我们在利用gradle将aar包上传到nexus上面</strong></p><hr><p>补充说明：</p><p>maven仓库地址和ID的命名规则</p><p>正式仓库地址：<br><strong>MAVEN_REPO_RELEASE_URL=<a href="http://192.168.1.20:8081/nexus/content/groups/app-public/" target="_blank" rel="noopener">http://192.168.1.20:8081/nexus/content/groups/app-public/</a></strong></p><p>快照仓库地址：<br><strong>MAVEN_REPO_SNAPSHOT_URL=<a href="http://192.168.1.20:8081/nexus/content/repositories/snapshots/" target="_blank" rel="noopener">http://192.168.1.20:8081/nexus/content/repositories/snapshots/</a></strong></p><p><strong>GroupId:  com.zjy.iot.app</strong></p><p><strong>artifactId ‘iot-app-xxx-sdk’</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Maven：项目管理和自动构建的工具,maven包集中存放的地方就是maven仓库。这些仓库可以放在本地，也可以放在某个远程服务器上，可以是私有的，也可以是共有的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Nexus：强大的maven仓库管理器，简化了本地仓库的维护和外部仓库的访问&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Android" scheme="https:mubai.site/categories/Android/"/>
    
    
      <category term="Maven" scheme="https:mubai.site/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>Android Gradle</title>
    <link href="https:mubai.site/2018-2-26-Android%20Gradle%20%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https:mubai.site/2018-2-26-Android Gradle 中遇到的问题/</id>
    <published>2018-02-25T16:00:00.000Z</published>
    <updated>2019-04-03T08:47:32.682Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Failed to resolve: xxx.xxx.xxx:xxx:x.x.x Show in File Show in Project Structure dialog</span><br></pre></td></tr></table></figure><p>有时候在我们创建项目引入一个新的依赖或者打开一个从网上clone下来的项目的时候会遇到这样的问题</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Failed to resolve: xxx.xxx.xxx:xxx:x.x.x Show in File Show in Project Structure dialog&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;有时候在我们创建项目引入一个新的依赖或者打开一个从网上clone下来的项目的时候会遇到这样的问题&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https:mubai.site/categories/Android/"/>
    
    
      <category term="Android" scheme="https:mubai.site/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android9.0曝光新特性</title>
    <link href="https:mubai.site/2018-2-5-Android9.0%E6%9B%9D%E5%85%89%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>https:mubai.site/2018-2-5-Android9.0曝光新特性/</id>
    <published>2018-02-04T16:00:00.000Z</published>
    <updated>2019-04-03T08:47:21.589Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>安卓9.0将加入电话录音功能：提高通话安全性</p><p>通话录音是目前许多手机都有的功能，但安卓原生系统并没有自带这项功能。</p></blockquote><a id="more"></a><p>据外媒<strong>Android Headlines</strong>消息称，发现Google在下个安卓开放源代码（AOSP）中发现新的代码，(此代码可能指向记录录音功能)说明下个安卓版本将会具有记录录音功能。</p><p>据悉，原声<strong>Android9.0</strong>的版本可以提供通话录音，而且通过提示用户进行操作，并且双方在通话的过程中，手机系统每15秒钟会发出一次蜂鸣声(手机将会把频率为1400Hz、每15秒钟重复一次的提示音添加到通话中，该声音将会被通话双方都听到，让对方确认你正在录音)，这种声音是提示呼叫者他们的对话正在被录音。</p><p>为了保证安全性，这段录音文件极有可能会存在Google云服务器中(话说国内如何访问呢…)</p><p>另外，据说<strong>Android9.0</strong>会提高系统的封闭性，让一些高度自由化的操作断绝掉(比如高权限插件、自动签到、个性化UI定制等)，整体的系统机制向iOS靠拢，对于用户来说只能说是喜忧参半，采用封闭机制，APP自启动、高敏感权限申请，等不再会出现，安全性、流畅度、稳定性都将大幅提升，但是却要牺牲原本的可玩性，只能说鱼与熊掌不能兼得吧！</p><p>当然对于开发者来说，提高系统的封闭性后，缺点在于我们对于一些需要的权限、操作需要更多的实现代码，同时原本的一些功能需要通过不同的方式方法实现，好处在于我们可以开发出安全性、稳定性更高的App！</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;安卓9.0将加入电话录音功能：提高通话安全性&lt;/p&gt;
&lt;p&gt;通话录音是目前许多手机都有的功能，但安卓原生系统并没有自带这项功能。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Android" scheme="https:mubai.site/categories/Android/"/>
    
    
      <category term="Android" scheme="https:mubai.site/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android各大应用商店应用图标、截图尺寸</title>
    <link href="https:mubai.site/2018-2-5-Android%E5%90%84%E5%A4%A7%E5%95%86%E5%BA%97%E5%BA%94%E7%94%A8%E5%9B%BE%E6%A0%87%E3%80%81%E6%88%AA%E5%9B%BE%E5%B0%BA%E5%AF%B8/"/>
    <id>https:mubai.site/2018-2-5-Android各大商店应用图标、截图尺寸/</id>
    <published>2018-02-04T16:00:00.000Z</published>
    <updated>2019-04-03T08:47:27.494Z</updated>
    
    <content type="html"><![CDATA[<h3 id="360"><a href="#360" class="headerlink" title="360"></a>360</h3><ul><li>应用图标：512 * 512png</li><li>应用截图：480 * 800 5张 png</li></ul><a id="more"></a><h3 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h3><ul><li>应用图标：512*512 png</li><li>应用截图：480 * 800 5张 </li></ul><h3 id="腾讯"><a href="#腾讯" class="headerlink" title="腾讯"></a>腾讯</h3><ul><li>应用图标：16 <em> 16一张，512 </em> 512一张 png</li><li>应用截图：480 * 800 5张 png</li></ul><h3 id="华为"><a href="#华为" class="headerlink" title="华为"></a>华为</h3><ul><li>应用图标：16 <em> 16一张，512 </em> 512一张 png</li><li>应用截图：480 * 800 5张 png</li></ul><h3 id="魅族"><a href="#魅族" class="headerlink" title="魅族"></a>魅族</h3><ul><li>应用图标：16 <em> 16一张，512 </em> 512一张 png</li><li>应用截图：480 * 800 5张 png</li></ul><h3 id="Oppo"><a href="#Oppo" class="headerlink" title="Oppo"></a>Oppo</h3><ul><li>应用图标：16 <em> 16一张，512 </em> 512一张 png</li><li>应用截图：480 * 800 5张 png</li></ul><h3 id="Vivo"><a href="#Vivo" class="headerlink" title="Vivo"></a>Vivo</h3><ul><li>应用图标：16 <em> 16一张，512 </em> 512一张 png</li><li>应用截图：480 * 800 5张 png</li></ul><h3 id="锤子"><a href="#锤子" class="headerlink" title="锤子"></a>锤子</h3><ul><li>应用图标：16 <em> 16一张，512 </em> 512一张 png</li><li>应用截图：480 * 800 5张 png</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;360&quot;&gt;&lt;a href=&quot;#360&quot; class=&quot;headerlink&quot; title=&quot;360&quot;&gt;&lt;/a&gt;360&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;应用图标：512 * 512png&lt;/li&gt;
&lt;li&gt;应用截图：480 * 800 5张 png&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Android" scheme="https:mubai.site/categories/Android/"/>
    
    
      <category term="Android" scheme="https:mubai.site/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>TensorFlow入门</title>
    <link href="https:mubai.site/2018-2-3-TensorFlow%E5%85%A5%E9%97%A8/"/>
    <id>https:mubai.site/2018-2-3-TensorFlow入门/</id>
    <published>2018-02-02T16:00:00.000Z</published>
    <updated>2019-04-03T08:47:14.943Z</updated>
    
    <content type="html"><![CDATA[<h4 id="MNIST机器学习入门"><a href="#MNIST机器学习入门" class="headerlink" title="MNIST机器学习入门"></a><a href="http://wiki.jikexueyuan.com/project/tensorflow-zh/tutorials/mnist_beginners.html" target="_blank" rel="noopener">MNIST机器学习入门</a></h4><p>MNIST:机器学习的入门，是一个入门级的计算机视觉数据集，包含了2部分：</p><ul><li>手写的数字图片</li><li>数字图片对应的标签</li></ul><a id="more"></a><p>MNIST数据集：官网地址是<a href="http://yann.lecun.com/exdb/mnist/" target="_blank" rel="noopener">Yann LeCun’s website</a><br>下载下来的数据集被分成了2部分：60000行的训练数据集(mnist.train)和10000行的测试数据集(mnist.test)</p><blockquote><p>这么切分的好处在于：在机器学习模式设计时必须有一个单独的测试数据集不用与训练而是用来评估这个模型的性能，从而更加容易把设计的模型推广到其他数据集上(泛化)</p></blockquote><hr><p>参考链接</p><p><a href="http://tensorflow.org/" target="_blank" rel="noopener">英文官方网站</a></p><p><a href="http://wiki.jikexueyuan.com/project/tensorflow-zh/" target="_blank" rel="noopener">TensorFlow 官方文档中文版</a></p><p><a href="https://github.com/tensorflow/tensorflow" target="_blank" rel="noopener">英文版GithHub仓库</a></p><p><a href="https://github.com/jikexueyuanwiki/tensorflow-zh" target="_blank" rel="noopener">中文版GithHub仓库</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;MNIST机器学习入门&quot;&gt;&lt;a href=&quot;#MNIST机器学习入门&quot; class=&quot;headerlink&quot; title=&quot;MNIST机器学习入门&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://wiki.jikexueyuan.com/project/tensorflow-zh/tutorials/mnist_beginners.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MNIST机器学习入门&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;MNIST:机器学习的入门，是一个入门级的计算机视觉数据集，包含了2部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;手写的数字图片&lt;/li&gt;
&lt;li&gt;数字图片对应的标签&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="机器学习" scheme="https:mubai.site/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="https:mubai.site/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Android仓库托管平台</title>
    <link href="https:mubai.site/2018-2-1-Android%E4%BB%93%E5%BA%93%E6%89%98%E7%AE%A1%E5%B9%B3%E5%8F%B0/"/>
    <id>https:mubai.site/2018-2-1-Android仓库托管平台/</id>
    <published>2018-01-31T16:00:00.000Z</published>
    <updated>2019-04-03T08:46:57.904Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Android-Library的托管平台介绍"><a href="#Android-Library的托管平台介绍" class="headerlink" title="Android Library的托管平台介绍"></a>Android Library的托管平台介绍</h4><blockquote><p>Android Studio是从build.gradle里面定义的Maven仓库服务器上下载library</p></blockquote><a id="more"></a><p>在build.gradle中会看到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()//使用Jcenter作为Maven</span><br><span class="line">        mavenCentral()//使用mavenCentral作为Maven</span><br><span class="line">        maven &#123;//自定义maven</span><br><span class="line">            url &apos;https://maven.google.com/&apos;</span><br><span class="line">            name &apos;Google&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过</p><ul><li><p>Jcenter</p><blockquote><p>Jcenter是一个由bintray.com维护的Maven仓库</p></blockquote></li><li><p>mavenCentral</p><blockquote><p>MavenCentral是由sonatype.org维护的Maven仓库</p></blockquote></li><li><p>maven { url ‘自己的仓库服务器地址’ }</p><blockquote><p>有时候会将library放在自己的服务器上，这时候就需要我们添加maven地址</p></blockquote></li></ul><p>但是一般来说我们只会使用<strong>Jcenter</strong>和<strong>mavenCentral</strong>，毕竟自己维护一个服务器地址成本较高，而且对于使用者来说他们只需要添加代码的依赖地址</p><blockquote><p>实际上除了Maven仓库外还有另外一种仓库：<a href="http://ant.apache.org/ivy/" target="_blank" rel="noopener">Ivy仓库</a></p></blockquote><h4 id="Jcenter和mavenCentral比较"><a href="#Jcenter和mavenCentral比较" class="headerlink" title="Jcenter和mavenCentral比较"></a>Jcenter和mavenCentral比较</h4><p>两个仓库都具有相同的使命：提供Java或者Android的Library服务</p><p>最开始的时候，AndroidStudio选择<strong>MavenCentral</strong>作为默认仓库，后来由于<strong>MavenCentral</strong>的不友好，对于开发者上传Library很难，同时由于其他的种种原因，AndroidStudio决定把<strong>MavenCentral</strong>换成<strong>Jcenter</strong></p><pre><code>* jcenter通过CDN发送library，开发者可以享受到更快的下载体验。* jcenter是全世界最大的Java仓库，因此在Maven Central 上有的 在jcenter上也极有可能有。换句话说jcenter是Maven Central的超集。* 上传library到仓库很简单，不需要像在 Maven Central上做很多复杂的事情* 友好的用户界面</code></pre><hr><blockquote><p>其他相关问题</p></blockquote><ul><li>如果要了解如何发布自己的library到Jcenter，可以查看<a href="http://mubai.site/%E9%A1%B9%E7%9B%AE%E5%8F%91%E5%B8%83%E5%88%B0%E5%85%AC%E5%85%B1%E7%9A%84jcenter%E4%BB%93%E5%BA%93/" target="_blank" rel="noopener">发布Library到Jcenter</a></li><li>有时候我们通过Jcenter依赖Library的时候加载很慢，可以查看<a href="http://blog.csdn.net/xiongbatianxia30146/article/details/63686359" target="_blank" rel="noopener">解决JCenter下载太慢的问题</a>来解决</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Android-Library的托管平台介绍&quot;&gt;&lt;a href=&quot;#Android-Library的托管平台介绍&quot; class=&quot;headerlink&quot; title=&quot;Android Library的托管平台介绍&quot;&gt;&lt;/a&gt;Android Library的托管平台介绍&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;Android Studio是从build.gradle里面定义的Maven仓库服务器上下载library&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Android" scheme="https:mubai.site/categories/Android/"/>
    
    
      <category term="Android" scheme="https:mubai.site/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>项目发布到jcenter仓库</title>
    <link href="https:mubai.site/2018-1-25-Jcenter%20/"/>
    <id>https:mubai.site/2018-1-25-Jcenter /</id>
    <published>2018-01-24T16:00:00.000Z</published>
    <updated>2019-04-03T08:46:50.286Z</updated>
    
    <content type="html"><![CDATA[<h3 id="项目所需的步骤"><a href="#项目所需的步骤" class="headerlink" title="项目所需的步骤"></a>项目所需的步骤</h3><h4 id="一、添加插件"><a href="#一、添加插件" class="headerlink" title="一、添加插件"></a>一、添加插件</h4><h5 id="在项目目录的build-gradle-中的-dependencies-添加："><a href="#在项目目录的build-gradle-中的-dependencies-添加：" class="headerlink" title="在项目目录的build.gradle 中的 dependencies 添加："></a>在项目目录的build.gradle 中的 dependencies 添加：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">classpath &quot;com.jfrog.bintray.gradle:gradle-bintray-plugin:1.5&quot; </span><br><span class="line">classpath &apos;com.github.dcendents:android-maven-gradle-plugin:1.4.1&apos;</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="二、配置gradle"><a href="#二、配置gradle" class="headerlink" title="二、配置gradle"></a>二、配置gradle</h4><h5 id="同时在需要添加到jcenter的libary的build-gradle根目录添加："><a href="#同时在需要添加到jcenter的libary的build-gradle根目录添加：" class="headerlink" title="同时在需要添加到jcenter的libary的build.gradle根目录添加："></a>同时在需要添加到jcenter的libary的build.gradle根目录添加：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &apos;com.github.dcendents.android-maven&apos; </span><br><span class="line">apply plugin: &apos;com.jfrog.bintray&apos;</span><br><span class="line">version = &quot;1.0.1&quot; //这里的version是可以更新的版本号*</span><br></pre></td></tr></table></figure><h5 id="1-在local-properties添加用户名和key"><a href="#1-在local-properties添加用户名和key" class="headerlink" title="(1)在local.properties添加用户名和key"></a>(1)在local.properties添加用户名和key</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bintray.user=openproject </span><br><span class="line">// your bintrayuser name </span><br><span class="line">bintray.apikey=****** </span><br><span class="line">// your bintray api key`</span><br></pre></td></tr></table></figure><h5 id="2-继续在根目录添加："><a href="#2-继续在根目录添加：" class="headerlink" title="(2)继续在根目录添加："></a>(2)继续在根目录添加：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def siteUrl = &apos;https://github.com/MoMuBai/Test&apos; </span><br><span class="line">// #修改# // 项目的主页地址，我这里是我的PickerView项目在github的链接地址 </span><br><span class="line">def gitUrl = &apos;https://github.com/MoMuBai/Test.git&apos; </span><br><span class="line">// #修改# // 项目 git 地址，我这里同样是用Github上的git地址 </span><br><span class="line">group = &quot;com.mubai&quot; </span><br><span class="line">// #修改# // 组名称</span><br></pre></td></tr></table></figure><h5 id="3-打包javadocjar和sourcejar"><a href="#3-打包javadocjar和sourcejar" class="headerlink" title="(3)打包javadocjar和sourcejar"></a>(3)打包javadocjar和sourcejar</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">install &#123; </span><br><span class="line">    repositories.mavenInstaller &#123;</span><br><span class="line">        // This generates POM.xml with proper parameters</span><br><span class="line">        pom &#123;</span><br><span class="line">            project &#123;</span><br><span class="line">                packaging &apos;aar&apos;</span><br><span class="line">                name &apos;Less Code For Android&apos;</span><br><span class="line">                url siteUrl</span><br><span class="line">                licenses &#123;</span><br><span class="line">                    license &#123;</span><br><span class="line">                        name &apos;The Apache Software License, Version 2.0&apos;</span><br><span class="line">                        url &apos;http://www.apache.org/licenses/LICENSE-2.0.txt&apos;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                developers &#123;</span><br><span class="line">                    developer &#123;</span><br><span class="line">                        id &apos;mubai&apos;</span><br><span class="line">                        name &apos;mubai.lzw&apos;</span><br><span class="line">                        email &apos;quickly520@126.com&apos;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                scm &#123;</span><br><span class="line">                    connection gitUrl</span><br><span class="line">                    developerConnection gitUrl</span><br><span class="line">                    url siteUrl</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-打包javadocjar和sourcejar"><a href="#4-打包javadocjar和sourcejar" class="headerlink" title="(4)打包javadocjar和sourcejar"></a>(4)打包javadocjar和sourcejar</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">task sourcesJar(type: Jar) &#123;</span><br><span class="line">    from android.sourceSets.main.java.srcDirs</span><br><span class="line">    classifier = &apos;sources&apos;</span><br><span class="line">&#125;</span><br><span class="line">task javadoc(type: Javadoc) &#123;</span><br><span class="line">    source = android.sourceSets.main.java.srcDirs</span><br><span class="line">    classpath += project.files(android.getBootClasspath().join(File.pathSeparator))</span><br><span class="line">&#125;</span><br><span class="line">task javadocJar(type: Jar, dependsOn: javadoc) &#123;</span><br><span class="line">    classifier = &apos;javadoc&apos;</span><br><span class="line">    from javadoc.destinationDir</span><br><span class="line">&#125;</span><br><span class="line">artifacts &#123;</span><br><span class="line">    archives javadocJar</span><br><span class="line">    archives sourcesJar</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-上传到Jcenter仓库-需要去从local-properties中读取"><a href="#5-上传到Jcenter仓库-需要去从local-properties中读取" class="headerlink" title="(5)上传到Jcenter仓库 需要去从local.properties中读取"></a>(5)上传到Jcenter仓库 需要去从local.properties中读取</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Properties properties = new Properties()</span><br><span class="line">properties.load(project.rootProject.file(&apos;local.properties&apos;).newDataInputStream())</span><br><span class="line">bintray &#123;</span><br><span class="line">    user = properties.getProperty(&quot;bintray.user&quot;)</span><br><span class="line">    key = properties.getProperty(&quot;bintray.apikey&quot;)</span><br><span class="line">    configurations = [&apos;archives&apos;]</span><br><span class="line">    pkg &#123;</span><br><span class="line">        repo = &quot;maven&quot;</span><br><span class="line">        name = &quot;test-library&quot;                // project name in jcenter</span><br><span class="line">        websiteUrl = siteUrl</span><br><span class="line">        vcsUrl = gitUrl</span><br><span class="line">        licenses = [&quot;Apache-2.0&quot;]</span><br><span class="line">        publish = true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三、执行命令"><a href="#三、执行命令" class="headerlink" title="三、执行命令"></a>三、执行命令</h4><h5 id="通过命令进入项目目录执行命令"><a href="#通过命令进入项目目录执行命令" class="headerlink" title="通过命令进入项目目录执行命令"></a>通过命令进入项目目录执行命令</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./gradlew javadocJar</span><br><span class="line">./gradlew sourcesJar</span><br><span class="line">./gradlew install</span><br><span class="line">./gradlew bintrayUpload</span><br></pre></td></tr></table></figure><h3 id="Bintray所需的步骤"><a href="#Bintray所需的步骤" class="headerlink" title="Bintray所需的步骤"></a><a href="https://bintray.com/" target="_blank" rel="noopener">Bintray</a>所需的步骤</h3><h4 id="一、注册账号也可以通过Git直接登录"><a href="#一、注册账号也可以通过Git直接登录" class="headerlink" title="一、注册账号也可以通过Git直接登录"></a>一、注册账号也可以通过Git直接登录</h4><h4 id="二、添加一个新的Repository-名字跟在gradle配置的一样"><a href="#二、添加一个新的Repository-名字跟在gradle配置的一样" class="headerlink" title="二、添加一个新的Repository(名字跟在gradle配置的一样)"></a>二、添加一个新的Repository(名字跟在gradle配置的一样)</h4><h4 id="三、在gradle命令执行完成后可以到Bintray进行提交审核-一般几个小时"><a href="#三、在gradle命令执行完成后可以到Bintray进行提交审核-一般几个小时" class="headerlink" title="三、在gradle命令执行完成后可以到Bintray进行提交审核(一般几个小时)"></a>三、在gradle命令执行完成后可以到Bintray进行提交审核(一般几个小时)</h4><h4 id="四、审核通过之后就可以进行依赖的添加使用了"><a href="#四、审核通过之后就可以进行依赖的添加使用了" class="headerlink" title="四、审核通过之后就可以进行依赖的添加使用了"></a>四、审核通过之后就可以进行依赖的添加使用了</h4><p><code>compile &#39;com.mubai:library:1.0.1&#39;</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;项目所需的步骤&quot;&gt;&lt;a href=&quot;#项目所需的步骤&quot; class=&quot;headerlink&quot; title=&quot;项目所需的步骤&quot;&gt;&lt;/a&gt;项目所需的步骤&lt;/h3&gt;&lt;h4 id=&quot;一、添加插件&quot;&gt;&lt;a href=&quot;#一、添加插件&quot; class=&quot;headerlink&quot; title=&quot;一、添加插件&quot;&gt;&lt;/a&gt;一、添加插件&lt;/h4&gt;&lt;h5 id=&quot;在项目目录的build-gradle-中的-dependencies-添加：&quot;&gt;&lt;a href=&quot;#在项目目录的build-gradle-中的-dependencies-添加：&quot; class=&quot;headerlink&quot; title=&quot;在项目目录的build.gradle 中的 dependencies 添加：&quot;&gt;&lt;/a&gt;在项目目录的build.gradle 中的 dependencies 添加：&lt;/h5&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;classpath &amp;quot;com.jfrog.bintray.gradle:gradle-bintray-plugin:1.5&amp;quot; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;classpath &amp;apos;com.github.dcendents:android-maven-gradle-plugin:1.4.1&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android" scheme="https:mubai.site/categories/Android/"/>
    
    
      <category term="Android" scheme="https:mubai.site/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android反编译</title>
    <link href="https:mubai.site/2018-1-18-%E5%8F%8D%E7%BC%96%E8%AF%91/"/>
    <id>https:mubai.site/2018-1-18-反编译/</id>
    <published>2018-01-17T16:00:00.000Z</published>
    <updated>2019-04-02T08:44:43.757Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Android" scheme="https:mubai.site/categories/Android/"/>
    
    
      <category term="Android" scheme="https:mubai.site/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android屏幕适配</title>
    <link href="https:mubai.site/2018-1-11-Android%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D/"/>
    <id>https:mubai.site/2018-1-11-Android屏幕适配/</id>
    <published>2018-01-10T16:00:00.000Z</published>
    <updated>2019-04-03T08:46:39.534Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>实际上很早就想写关于Android屏幕适配的总结了，但是由于各种各样的理由推迟了</p></blockquote><a id="more"></a><h4 id="什么是屏幕适配"><a href="#什么是屏幕适配" class="headerlink" title="什么是屏幕适配"></a>什么是屏幕适配</h4><p>屏幕适配即在不同分辨率、尺寸、比例的设备上显示达到一样的效果</p><h4 id="为什么要屏幕适配"><a href="#为什么要屏幕适配" class="headerlink" title="为什么要屏幕适配"></a>为什么要屏幕适配</h4><p>由于Android系统的开放性，任何用户、开发者、OEM厂商、运营商都可以对Android进行定制，修改成他们想要的样子，这种情况下导致了Android系统的碎片化严重</p><blockquote><p>碎片化：系统碎片化(小米MIUI、华为EMUI、魅族flyme)、屏幕大小碎片化(5.0、5.5、6.0)、屏幕分辨率碎片化(320x480、480x800、720x1280、1080x1920)</p><p>这里有Android碎片化的数据：<a href="https://opensignal.com/reports/2014/android-fragmentation/" target="_blank" rel="noopener">戳这里</a></p></blockquote><h4 id="如何进行屏幕适配"><a href="#如何进行屏幕适配" class="headerlink" title="如何进行屏幕适配"></a>如何进行屏幕适配</h4><h5 id="在屏幕适配开始前，我们需要对Android的一些屏幕相关单位有所了解"><a href="#在屏幕适配开始前，我们需要对Android的一些屏幕相关单位有所了解" class="headerlink" title="在屏幕适配开始前，我们需要对Android的一些屏幕相关单位有所了解"></a>在屏幕适配开始前，我们需要对Android的一些屏幕相关单位有所了解</h5><ul><li>像素：单位px，屏幕上的点，我们看到的图像都是由一个个小点构成的</li><li>屏幕尺寸：屏幕上对角线的长度，单位是英寸，一英寸为2.54厘米，现在市场上常见的有4.7、5.0、5.5、6.0等尺寸的手机</li><li>屏幕分辨率：横纵方向上的像素点数，如1920*1080，即纵向上有1920个像素点，横向上有1080个像素点</li><li>屏幕每英寸点数：单位dpi，为屏幕分辨率/屏幕尺寸所得的值，如一个1920*1080的手机，它的纵向尺寸为3英寸，横向尺寸为5.3英寸，那么它的像素密度为1080/3=360dpi，屏幕分辨率越高，尺寸越小，那么它的像素密度就越高</li><li>屏幕像素密度：density = dpi/160</li><li>屏幕像素无关密度：单位dp或者是dip，与物流像素点无关，是Android特有的单位，是为了保证在不同屏幕像素密度的设备上显示相同的效果</li><li>屏幕独立比例像素：单位sp，类似dp，一般是用来设置文字大小</li></ul><p>这里用张表格来各个单位之间的关系</p><table><thead><tr><th>密度类型</th><th style="text-align:center">代表的分辨率（px）</th><th style="text-align:right">屏幕每英寸点数（dpi）</th><th style="text-align:right">屏幕密度（density）</th><th style="text-align:right">换算（px/dp）</th><th style="text-align:right">比例</th></tr></thead><tbody><tr><td>低密度（ldpi）</td><td style="text-align:center">240x320</td><td style="text-align:right">120</td><td style="text-align:right">0.75</td><td style="text-align:right">1dp = 0.75px</td><td style="text-align:right">3</td></tr><tr><td>中密度（mdpi）</td><td style="text-align:center">320x480</td><td style="text-align:right">160</td><td style="text-align:right">1</td><td style="text-align:right">1dp = 1px</td><td style="text-align:right">4</td></tr><tr><td>高密度（hdpi）</td><td style="text-align:center">480x800</td><td style="text-align:right">240</td><td style="text-align:right">1.5</td><td style="text-align:right">1px = 1.5dp</td><td style="text-align:right">6</td></tr><tr><td>超高密度（xhdpi）</td><td style="text-align:center">720x1280</td><td style="text-align:right">320</td><td style="text-align:right">2</td><td style="text-align:right">1dp = 2px</td><td style="text-align:right">8</td></tr><tr><td>超超高密度（xxhdpi）</td><td style="text-align:center">1080x1920</td><td style="text-align:right">480</td><td style="text-align:right">3</td><td style="text-align:right">1dp = 3px</td><td style="text-align:right">12</td></tr></tbody></table><h5 id="如何适配"><a href="#如何适配" class="headerlink" title="如何适配"></a>如何适配</h5><hr><p>参考链接</p><p><a href="https://www.jianshu.com/p/ec5a1a30694b" target="_blank" rel="noopener">Android 屏幕适配：最全面的解决方案</a></p><p><a href="http://blog.csdn.net/zhaokaiqiang1992/article/details/45419023#%E5%B1%8F%E5%B9%95%E5%B0%BA%E5%AF%B8" target="_blank" rel="noopener">Android屏幕适配全攻略(最权威的官方适配指导)</a></p><p><a href="http://stormzhang.com/android/2014/05/16/android-screen-adaptation/" target="_blank" rel="noopener">Android 屏幕适配</a></p><p><a href="http://blog.csdn.net/guolin_blog/article/details/8830286" target="_blank" rel="noopener">Android官方提供的支持不同屏幕大小的全部方法</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;实际上很早就想写关于Android屏幕适配的总结了，但是由于各种各样的理由推迟了&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Android" scheme="https:mubai.site/categories/Android/"/>
    
    
      <category term="Android" scheme="https:mubai.site/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>阿里云大使</title>
    <link href="https:mubai.site/2018-1-10-%E9%98%BF%E9%87%8C%E4%BA%91%E5%A4%A7%E4%BD%BF%E8%A1%8C%E8%B5%B0%E4%B8%AD/"/>
    <id>https:mubai.site/2018-1-10-阿里云大使行走中/</id>
    <published>2018-01-09T16:00:00.000Z</published>
    <updated>2019-04-03T08:46:32.468Z</updated>
    
    <content type="html"><![CDATA[<p>💰💰💰💰💰💰💰💰💰💰💰💰💰💰💰💰💰💰💰💰💰💰💰</p><p><strong>满满的$$$镇楼</strong></p><blockquote><p>在使用阿里云提供的域名服务中偶然发现云大使这个组织，然后发现这是个让其他的人通过使用你的幸运券去购买阿里云产品，你就可以获得对应的返佣比例，最高可达30%(如被推荐的人新购买或者是升级了自己的域名服务。支付了10000元，则云大使就可以获得3000元的返佣)</p></blockquote><p>说的简单点，云大使就是<strong>分享幸运券-&gt;坐等返佣</strong>的过程，通俗点就是个<strong>赚钱，钱，钱</strong>的过程，重要的话要说三遍</p><a id="more"></a><blockquote><p>当然是要有人使用了你分享的幸运券的前提下</p></blockquote><p>我们现在就来说说如何用云大使实现我们的目标：<strong>月入百万、荣登CEO、迎娶白富美</strong>我的<strong><a href="https://promotion.aliyun.com/ntms/act/ambassador/sharetouser.html?userCode=2j1udai5&amp;utm_source=2j1udai5" target="_blank" rel="noopener">幸运券</a></strong></p><h5 id="1-加入云大使"><a href="#1-加入云大使" class="headerlink" title="1.加入云大使"></a>1.加入云大使</h5><p>首先需要你有<a href="https://www.aliyun.com/?utm_medium=text&amp;utm_source=bdbrand&amp;utm_campaign=bdbrand&amp;utm_content=se_32492" target="_blank" rel="noopener">阿里云</a>的账号，然后你就可以通过<a href="https://promotion.aliyun.com/ntms/yunparter/zhaomu.html?spm=5176.bbsr569878.0.0.ZUuEom" target="_blank" rel="noopener">云大使报名入口</a>加入云大使</p><h5 id="2-分享使用幸运券及好处"><a href="#2-分享使用幸运券及好处" class="headerlink" title="2.分享使用幸运券及好处"></a>2.分享使用幸运券及好处</h5><ul><li><p>网页端：加入云大使后会对应的<strong><a href="https://expense.console.aliyun.com/#/ambassador/ticket/product" target="_blank" rel="noopener">生成你的幸运券</a></strong>，然后你可以通过复制<strong><a href="https://promotion.aliyun.com/ntms/act/ambassador/sharetouser.html?userCode=2j1udai5&amp;utm_source=2j1udai5" target="_blank" rel="noopener">你的幸运券</a></strong>分享出去</p></li><li><p>App端：<strong>阿里云App-&gt;我的-&gt;推开奖励-&gt;分享全部产品幸运券</strong>然后就可以通过其他方式分享到支付宝、钉钉、微信、QQ等</p></li></ul><h5 id="3-使用幸运券"><a href="#3-使用幸运券" class="headerlink" title="3.使用幸运券"></a>3.使用幸运券</h5><ul><li><p>如何使用幸运券：其他人在选择<strong>阿里云产品-&gt;购买-&gt;确认订单的环节-&gt;使用云大使的幸运券-&gt;提交订单-&gt;完成支付</strong>，整个流程后即可认为幸运券被使用</p></li><li><p>使用幸运券的好处：</p><ul><li>幸运券实际上是有优惠的，只是它的优惠金额是随机的</li><li>订单支付大于0元可参与抽奖</li><li>首购ecs大于1000元可参与抽奖</li></ul></li></ul><blockquote><p>当前阿里云可以使用幸运券的产品共29款</p></blockquote><h5 id="4-坐等返佣"><a href="#4-坐等返佣" class="headerlink" title="4.坐等返佣"></a>4.坐等返佣</h5><p>18年1月返利新规<strong>【返佣率高达30%无封顶返利】</strong></p><p><img src="http://p0sgkjh7x.bkt.clouddn.com/47499416-AC74-4B5C-A057-CFB5E0D3F738.png" alt="1月份新规图"></p><ul><li><p>返利时间：一般情况下当月的奖励将会在下下月的20号左右返利，如1月月份推荐的返利将在18年3月20日左右发放，（一般情况下只会提前不会延后）返利将会发放到绑定的支付宝账号中</p></li><li><p>需要注意:要完成<strong>1实名认证-&gt;2.绑定支付宝-&gt;3.现金购云产品&gt;=100元(第3条在校学生通过学生认证除外)</strong>才能够完成返利提现</p></li></ul><hr><blockquote><p>附上阿里云可以使用幸运券产品图(18年1月份新图)，总有一款适合你，</p></blockquote><p><img src="http://p0sgkjh7x.bkt.clouddn.com/8406A892-DDBD-4345-83C8-24A9AE3D26A7.png" alt="图1"><br><img src="http://p0sgkjh7x.bkt.clouddn.com/32693FE6-4454-4440-B48B-BAEB2A81FCA4.png" alt="图2"><br><img src="http://p0sgkjh7x.bkt.clouddn.com/D7D61595-2640-4918-B4AC-1FB3A86C485C.png" alt="图3"></p><p>可以根据自己的需要选择云产品，使用我的<strong><a href="https://promotion.aliyun.com/ntms/act/ambassador/sharetouser.html?userCode=2j1udai5&amp;utm_source=2j1udai5" target="_blank" rel="noopener">幸运券</a></strong>来实现你的幸运产品</p><p>参考链接</p><p><a href="https://bbs.aliyun.com/read/325184.html?spm=5176.2020520127.100133.6.niQOZ8" target="_blank" rel="noopener">大神引路–新手云大使入门导引</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;💰💰💰💰💰💰💰💰💰💰💰💰💰💰💰💰💰💰💰💰💰💰💰&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;满满的$$$镇楼&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在使用阿里云提供的域名服务中偶然发现云大使这个组织，然后发现这是个让其他的人通过使用你的幸运券去购买阿里云产品，你就可以获得对应的返佣比例，最高可达30%(如被推荐的人新购买或者是升级了自己的域名服务。支付了10000元，则云大使就可以获得3000元的返佣)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;说的简单点，云大使就是&lt;strong&gt;分享幸运券-&amp;gt;坐等返佣&lt;/strong&gt;的过程，通俗点就是个&lt;strong&gt;赚钱，钱，钱&lt;/strong&gt;的过程，重要的话要说三遍&lt;/p&gt;
    
    </summary>
    
      <category term="闲文" scheme="https:mubai.site/categories/%E9%97%B2%E6%96%87/"/>
    
    
      <category term="闲文" scheme="https:mubai.site/tags/%E9%97%B2%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>谈谈Android中的JNI和NDK</title>
    <link href="https:mubai.site/2018-1-9-Android%20JNI%E5%92%8CNDK/"/>
    <id>https:mubai.site/2018-1-9-Android JNI和NDK/</id>
    <published>2018-01-08T16:00:00.000Z</published>
    <updated>2019-04-03T08:46:25.253Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近发现光看源码的过程是在太枯燥了，准备开始以博客的形式来解读源码，一方面是为了能让自己更好的巩固知识点，一方面是为了能展(zhuang)现(bi)下自己</p></blockquote><p>今天要来说说<strong>JNI</strong>和<strong>NDK</strong>，最近发现使用<strong>NDK</strong>开发的需求正在不断增加啊，不管是为了能<strong>与本地的代码交互</strong>或者是为了<strong>更好的体验(使用C、C++的so)</strong>都在不断的促使我们使用<strong>NDK</strong>。</p><a id="more"></a><h4 id="什么是JNI"><a href="#什么是JNI" class="headerlink" title="什么是JNI"></a>什么是JNI</h4><ul><li>定义：<strong>JNI(Java Native Interface)</strong> Java本地接口</li><li>作用：我们可以通过<strong>JNI</strong>来使<strong>Java</strong>能与<strong>本地的其他语言(C、C++)</strong>进行<strong>交互</strong></li><li>优势：实际开发中，有时候会遇到一些性能要求的功能，而<strong>Java</strong>代码在处理性能方面远远不如<strong>C、C++</strong>，所以我们可以通过<strong>C、C++</strong>开发功能，然后通过<strong>JNI</strong>来使得<strong>Java</strong>代码与<strong>C、C++代码</strong>的交互(很多人都会举例一大堆JNI的应用场景，实际上不管是什么使用场景都是基于<strong>Java</strong>代码和<strong>其他语言</strong>的交互)，所以说JNI可以扩展JVM的能力，可以进行驱动开发，复用已有的一些开源库，而且一些产品的核心技术一般也是采用JNI开发，不易被破解</li><li>劣势：尽管<strong>JNI</strong>带来了很多的使用场景，提高了与本地语言交互的能力，但是它也带来了一些不足，我们都知道Java火爆的原因之一就是它的<strong>跨平台</strong>，但是现在<strong>JNI</strong>与本地的语言的交互导致我们需要为不同的系统的本地语言来实现不同的代码，削弱了Java的<strong>跨平台性</strong>，而且有一点就是通过JNI调用还是会比C、C++编写的原生应用要慢一点</li></ul><h4 id="什么是NDK"><a href="#什么是NDK" class="headerlink" title="什么是NDK"></a>什么是NDK</h4><ul><li>定义：NDK(Native Development Kit)，Google对其定义为一套允许您使用原生代码语言(例如C和C++)实现部分应用的工具集</li><li>作用：能让我们快速的开发C、C++的so动态库，并且将so和应用一起打包成APK</li></ul><h4 id="JNI和NDK的关系"><a href="#JNI和NDK的关系" class="headerlink" title="JNI和NDK的关系"></a>JNI和NDK的关系</h4><p>NDK为我们生成了C、C++的so动态库，JNI又提供了Java代码和其他语言(C、C++)交互的能力，这两者之间可以实现互补，可以说JNI是目的，而NDK是实现JNI的手段，通过NDK来实现JNI的功能，最后达到“Java+C”的开发方式</p><h4 id="NDK的使用"><a href="#NDK的使用" class="headerlink" title="NDK的使用"></a>NDK的使用</h4><blockquote><p>开发环境：Mac OS 10.13.2 + Android Studio 3.0</p></blockquote><h5 id="NDK的添加配置"><a href="#NDK的添加配置" class="headerlink" title="NDK的添加配置"></a>NDK的添加配置</h5><p>打开<strong>Preferences-&gt;Appearance&amp;Behavior-&gt;SystemSettings-&gt;AndroidSDK-&gt;SDKTools</strong>勾选<strong>NDK</strong>下载</p><p><img src="http://p0sgkjh7x.bkt.clouddn.com/58B7EDC0-46FF-493F-BE65-937F00D93CEF.png" alt="NDK配置添加"></p><p>等待安装完毕</p><p>我这边已经安装完毕可以在<strong>local.properties</strong>中看到</p><blockquote><p>这些是Android Studio自动生成的</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ndk.dir=/Users/lzw/Library/Android/sdk/ndk-bundle</span><br><span class="line">sdk.dir=/Users/lzw/Library/Android/sdk</span><br></pre></td></tr></table></figure><h5 id="项目中添加JNI支持"><a href="#项目中添加JNI支持" class="headerlink" title="项目中添加JNI支持"></a>项目中添加JNI支持</h5><blockquote><p>我不添加好像也可以…</p></blockquote><p>在<strong>gradle.properties</strong>中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android.useDeprecatedNdk=true</span><br></pre></td></tr></table></figure><p>然后在app的<strong>build.gradle</strong>中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &apos;com.android.application&apos;</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion 23</span><br><span class="line">    buildToolsVersion &quot;26.0.2&quot;</span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        minSdkVersion 15</span><br><span class="line">        targetSdkVersion 23</span><br><span class="line">        versionCode 1</span><br><span class="line">        versionName &quot;1.0&quot;</span><br><span class="line"></span><br><span class="line">        testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot;</span><br><span class="line"></span><br><span class="line">        ndk &#123;</span><br><span class="line">        //要支持的CPU都有哪些，可以自己选择添加</span><br><span class="line">            abiFilters &quot;armeabi-v7a&quot;,&quot;armeabi&quot;,&quot;arm64-v8a&quot;,&quot;mips&quot;,&quot;mips64&quot;</span><br><span class="line">            //生成的so名称</span><br><span class="line">            moduleName &quot;MuBaiYs7&quot;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled false</span><br><span class="line">            proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])</span><br><span class="line">    compile &apos;com.android.support:appcompat-v7:23.1.0&apos;</span><br><span class="line">    testCompile &apos;junit:junit:4.12&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点在于添加了注释的那2句话：</p><h5 id="项目中添加Java访问C的接口类"><a href="#项目中添加Java访问C的接口类" class="headerlink" title="项目中添加Java访问C的接口类"></a>项目中添加Java访问C的接口类</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class AndroidJni &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 要与C层交互的方法</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static native String getString();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 加载so，要跟build.gradle中自己定义so名称保持一致</span><br><span class="line">     */</span><br><span class="line">    static &#123;</span><br><span class="line">        System.loadLibrary(&quot;MuBaiYs7&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们会根据方法<figure class="highlight plain"><figcaption><span>function Java_com_lzw_ys7_jni_AndroidJni_getString```创建方法，然后Studio会为我们在根目录中生成一个cpp的文件夹，里面有一个.c文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![C层中的方法](http://p0sgkjh7x.bkt.clouddn.com/D618011D-DB8B-4A1A-92F5-2702CEC7FB76.png)</span><br><span class="line"></span><br><span class="line">这个文件的名称是可以自己修改的，我们查看这个文件可以发现，它就提供了一个方法，返回一个字符串，这边我们让它返回&quot;MuBaiYs7Jni&quot;</span><br></pre></td></tr></table></figure></p><p>#include &lt;jni.h&gt;</p><p>JNIEXPORT jstring JNICALL<br>Java_com_lzw_ys7_jni_AndroidJni_getString(JNIEnv *env, jobject instance) {</p><pre><code>return (*env)-&gt;NewStringUTF(env, &quot;MuBaiYs7Jni&quot;);</code></pre><p>}</p><p><code>`</code></p><h5 id="调用Java代码"><a href="#调用Java代码" class="headerlink" title="调用Java代码"></a>调用Java代码</h5><ul><li>调用Jni的方法</li></ul><p><img src="http://p0sgkjh7x.bkt.clouddn.com/A66025A1-356E-414D-9CEE-E9FC8592584E.png" alt="具体调用"></p><ul><li>运行成功后我们可以看到，说明我们调用成功</li></ul><p><img src="http://p0sgkjh7x.bkt.clouddn.com/84E09BA1-1855-4685-8439-CCD1146227B6.png" alt="运行结果"></p><h5 id="得到so文件"><a href="#得到so文件" class="headerlink" title="得到so文件"></a>得到so文件</h5><blockquote><p>这边我们是自己使用项目中的C方法，但是实际项目中很多时候都是把方法封装成so文件进行开发，类似于jar包和arr包</p></blockquote><p>我们这边直接切换项目的展示形式：<strong>Android-&gt;Project</strong><br>然后查看build-&gt;intermediates-&gt;ndk-&gt;debug-&gt;lib</p><p><img src="http://p0sgkjh7x.bkt.clouddn.com/4421444A-9F7A-427E-AF44-B12D012804AF.png" alt="ndk"></p><p>这边的<strong>libMuBaiYs7.so</strong>就是我们根据项目中的<code>jnitest.c</code>文件封装出来的<strong>so</strong>文件</p><p>我们可以把这里的<strong>so</strong>文件复制到其他项目中的<strong>lib</strong>或者是<strong>jniLibs</strong>文件中进行使用</p><blockquote><p>需要注意的是不能单独复制<strong>so</strong>文件，要将各个CPU对应的<strong>so</strong>文件分别复制出来到文件中</p></blockquote><p>这边只是NDK和Jni的入门使用，关于Jni常用的类型和方法会在其他的时间进行学习介绍</p><p>未完待续</p><hr><p>参考链接：</p><p><a href="https://developer.android.google.cn/ndk/index.html" target="_blank" rel="noopener">Android NDK</a></p><p><a href="https://www.jianshu.com/p/aba734d5b5cd" target="_blank" rel="noopener">Android JNI编程—JNI基础</a></p><p><a href="https://www.jianshu.com/p/ac00d59993aa" target="_blank" rel="noopener">Android NDK开发：JNI基础篇</a></p><p><a href="http://www.jcodecraeer.com/a/anzhuokaifa/2017/0401/7769.html" target="_blank" rel="noopener">Android Studio jni开发入门——看我就够了！</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近发现光看源码的过程是在太枯燥了，准备开始以博客的形式来解读源码，一方面是为了能让自己更好的巩固知识点，一方面是为了能展(zhuang)现(bi)下自己&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天要来说说&lt;strong&gt;JNI&lt;/strong&gt;和&lt;strong&gt;NDK&lt;/strong&gt;，最近发现使用&lt;strong&gt;NDK&lt;/strong&gt;开发的需求正在不断增加啊，不管是为了能&lt;strong&gt;与本地的代码交互&lt;/strong&gt;或者是为了&lt;strong&gt;更好的体验(使用C、C++的so)&lt;/strong&gt;都在不断的促使我们使用&lt;strong&gt;NDK&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https:mubai.site/categories/Android/"/>
    
    
      <category term="Android" scheme="https:mubai.site/tags/Android/"/>
    
  </entry>
  
</feed>

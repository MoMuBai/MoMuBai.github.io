<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>沐白白白</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https:mubai.site/"/>
  <updated>2020-03-21T08:41:44.069Z</updated>
  <id>https:mubai.site/</id>
  
  <author>
    <name>沐白</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>GiftForGirl</title>
    <link href="https:mubai.site/2020-3-21-%E7%A4%BC%E7%89%A9%E4%B8%93%E7%BA%BF/"/>
    <id>https:mubai.site/2020-3-21-礼物专线/</id>
    <published>2020-03-20T16:00:00.000Z</published>
    <updated>2020-03-21T08:41:44.069Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GiftForGirl"><a href="#GiftForGirl" class="headerlink" title="GiftForGirl"></a>GiftForGirl</h2><p><strong><em>专为男士为女士送礼用，包括香水、口红、包包、手链、镯子、耳环、项链、丝巾、帽子、护肤品、化妆品、指甲油、睡衣、内衣等等，仅供参考</em></strong></p><p><em>顺序不分先后，随便排的，开心就好，目前只是大概写写抄抄，内容待补充，未完待续</em></p><hr><ul><li><a href="#1-香水">香水</a></li><li><a href="#2-口红">口红</a></li><li><a href="#3-包包">包包</a></li><li><a href="#4-手链">手链</a></li><li><a href="#5-镯子">镯子</a></li><li><a href="#6-耳环">耳环</a></li><li><a href="#7-项链">项链</a></li><li><a href="#8-丝巾">丝巾</a></li><li><a href="#9-帽子">帽子</a></li><li><a href="#10-护肤品">护肤品</a></li><li><a href="#11-化妆品">化妆品</a></li><li><a href="#12-指甲油">指甲油</a></li><li><a href="#13-太阳眼镜">太阳眼镜</a></li><li><a href="#14-手表">手表</a></li><li><a href="#15-钱包">钱包</a></li><li><a href="#16-内衣">内衣</a></li><li><a href="#17-睡衣">睡衣</a></li></ul><h3 id="1-香水"><a href="#1-香水" class="headerlink" title="1 香水"></a>1 香水</h3><ul><li>Dior</li><li>CHANEL</li><li>菲拉格慕</li><li>范思哲</li><li>伊丽莎白雅顿</li><li>巴宝莉</li><li>阿玛尼</li><li>祖马龙</li><li>兰蔻</li><li>圣罗兰</li><li>橘滋</li></ul><h3 id="2-口红"><a href="#2-口红" class="headerlink" title="2 口红"></a>2 口红</h3><ul><li>圣罗兰YSL</li><li>魅可MAC</li><li>迪奥Dior</li><li>纪梵希Givenchy</li><li>资生堂SHISEIDO</li><li>美宝莲</li><li>阿玛尼Armaani</li><li>兰蔻LANCOME</li><li>香奈儿CHANEL</li><li>欧莱雅</li><li>汤姆福特Tom Ford</li><li>美丽小屋</li></ul><h3 id="3-包包"><a href="#3-包包" class="headerlink" title="3 包包"></a>3 包包</h3><ul><li>路易威登LV</li><li>香奈儿CHANEL</li><li>爱马仕Hermes</li><li>普拉达Prada</li><li>古驰Gucci</li><li>圣大保罗Polo</li><li>登喜路Dunhill</li><li>沙驰SATCHI</li><li>鳄鱼Lacoste</li><li>梦特娇Montagut</li></ul><h3 id="4-手链"><a href="#4-手链" class="headerlink" title="4 手链"></a>4 手链</h3><ul><li>潘多拉</li><li>路易威登LV</li><li>迪奥Dior</li><li>卡地亚</li><li>蒂芙尼</li><li>佐卡伊</li><li>芬迪</li><li>梵克雅宝</li><li>宝格丽</li><li>施华洛世奇</li></ul><h3 id="5-镯子"><a href="#5-镯子" class="headerlink" title="5 镯子"></a>5 镯子</h3><ul><li>施华洛世奇</li><li>潘多拉</li><li>蒂芙尼</li><li>卡地亚</li><li>爱马仕</li></ul><h3 id="6-耳环"><a href="#6-耳环" class="headerlink" title="6 耳环"></a>6 耳环</h3><ul><li>宝格丽</li><li>伯爵</li><li>梵克雅宝</li><li>Qeelin麒麟</li><li>施华洛世奇</li><li>橘滋</li><li>菲尼莎</li><li>依慧达</li><li>御木本</li><li>波米雷特</li><li>Oxette</li><li>尚晨珠宝</li><li>吉盟</li><li>梵蒂诺</li></ul><h3 id="7-项链"><a href="#7-项链" class="headerlink" title="7 项链"></a>7 项链</h3><ul><li>蒂芙尼</li><li>施华洛世奇</li><li>海盗船</li><li>Julie</li><li>卡地亚</li><li>宝格丽</li><li>蒙奇奇</li><li>梵克雅宝</li><li>爱马仕</li><li>迪奥</li><li>周大福</li><li>周生生</li><li>谢瑞麟TSL</li><li>潮宏基CHJ</li><li>周大生</li><li>老凤祥</li><li>六福</li></ul><h3 id="8-丝巾"><a href="#8-丝巾" class="headerlink" title="8 丝巾"></a>8 丝巾</h3><ul><li>爱马仕</li><li>玛利亚·古琦</li><li>万事利</li><li>博柏利</li><li>Zara飒拉</li><li>路易威登LV</li><li>鹿王</li><li>以纯</li><li>维信</li><li>宝石蝶</li><li>龙翔纺织</li><li>丝界</li><li>丝绸故事</li><li>喜得宝</li><li>上海故事</li><li>妩WOO</li><li>绝代佳人</li></ul><h3 id="9-帽子"><a href="#9-帽子" class="headerlink" title="9 帽子"></a>9 帽子</h3><ul><li>彩蓝EB</li><li>来可派</li><li>丽华LH</li><li>爱马仕</li><li>博柏利</li><li>快乐狐狸</li><li>拜丽德</li><li>GAP盖璞</li><li>红日</li><li>盛锡福</li></ul><h3 id="10-护肤品"><a href="#10-护肤品" class="headerlink" title="10 护肤品"></a>10 护肤品</h3><ul><li>法国lancome(兰蔻)-睫毛膏、兰蔻粉水</li><li>美国estee lauder(雅诗兰黛)-adbanced night repair(简称anr)系列、海蓝之谜</li><li>日本shiseido(资生堂)</li><li>法国dior(迪奥)-蓝金唇膏、5色眼影</li><li>法国chanel(香奈尔)</li><li>美国clinique(倩碧)-护肤三步曲</li><li>日本sk-ii-护肤精华露(又称神仙水)</li><li>法国biotherm(碧欧泉)-活泉水分露</li><li>hr(赫莲娜)-极至之美胶原系列、维他命c精华系列</li><li>美国伊丽沙白.雅顿-8小时润泽霜</li><li>雅斯兰黛的眼霜</li><li>sk2的各种护肤品、面膜</li><li>前男友面膜</li><li>luna洗脸仪</li><li>面部按摩仪   </li><li>Dreamtimes 梦幻时光爽肤水</li><li>FANCL芳柯</li><li>Ipsa流金水</li><li>Ipsa自律循环乳液</li><li>CPB水磨精华</li><li>珂润浸润保湿水+保湿面霜</li><li>碧欧泉新活泉爽肤组合</li><li>倩碧(润肤露)黄油</li><li>资生堂红色蜜露</li><li>DHC橄榄滋养套装</li><li>高丝雪肌精乳液</li><li>兰蔻精华肌底液(小黑瓶)</li><li>丝塔芙洁面乳</li><li>AVENE雅漾舒护活泉水</li></ul><h3 id="11-化妆品"><a href="#11-化妆品" class="headerlink" title="11 化妆品"></a>11 化妆品</h3><ul><li><p>欧莱雅：</p><ul><li>顶级品牌：HR(赫莲娜)是旗舰产品</li><li>二线产品：Lancome(兰蔻)，Biotherm(碧欧泉)</li><li>三线或三线以下产品：LOrealParis(欧莱雅)，kiehls(契尔氏)，美爵士、Garnier(卡尼尔)，羽西，小护士，INNEOV</li><li>彩妆品牌：CCBPARIS、shuuemura(植村秀)、Maybelline(美宝莲)</li><li>药妆品牌：Vichy(薇姿)，LAROCHE-POSAY(理肤泉)、SkinCeuticals(杜克)</li><li>香水品牌：GiorgioArmaniParfums(阿玛尼)，RalphLaurenParfums(拉尔夫*劳伦、POLO),caelParfums(卡夏尔)，VIKTOR&amp;ROLF</li><li>发用品牌：KERASTASE卡诗、MATRIX、MIZANI、REDKEN、SOFTSHEENCARSO</li></ul></li><li><p>宝洁公司</p><ul><li>顶级品牌：SK-II(Maxfactor)—就是蜜丝佛陀</li><li>二线品牌：Olay(玉兰油)、Illume(伊奈美)、Always、Zest</li><li>彩妆品牌：Covergirl(封面女郎)</li><li>亚洲区第一彩妆品牌：ANNASUI(安娜苏)</li><li>香水品牌：Hugoboss、Locaste、ANNASUI(安娜苏)、Escada(艾斯卡达)、Dunhill(登喜路)、Valention、Lanvin(朗万)、PaulSmith(保罗史密斯)</li><li>洗护品牌：飘柔、海飞丝、激爽(刚淘汰)、潘婷、润妍、沙宣、伊卡璐(Clairol)、舒肤佳、Wella(威娜)</li></ul></li><li><p>雅诗兰黛</p><ul><li>顶级品牌：LaMer(海蓝之谜)—–港台翻译为海洋之蓝</li><li>一线品牌：雅诗兰黛</li><li>二线品牌：Clinique(倩碧)</li><li>三线品牌：Stila、Origins(品木宣言)、Prescriptives、、Aveda(肯梦)和JoMalone</li><li>顶级限量彩妆品牌：TomFord(汤姆福特)</li><li>彩妆品牌：BobbiBrown(芭比波朗)、M.A.C(魅可).</li><li>香水品牌：TommyHilfiger(唐美希绯格)、DKNY(唐可娜儿)、Aramis(雅男士)</li><li>开架品牌：BeautyBank(目前仅在Kohls百货售卖，总共推出了Flirt、AmericanBeauty、GoodSkin及以Grassroots4个系</li></ul></li><li><p>资生堂</p><ul><li>顶级品牌：CledePeau(CDP)、IPSA(茵芙莎)</li><li>二线品牌：Ettusais(爱杜莎)、CARITA 凯伊黛、Decleor 思妍丽</li><li>底线品牌：ShiseidoFitit、Asplir(爱泊丽)、DeLuxe、ff 、SELFIT(珊妃)、Whitia(白媞雅)、FT Shiseido、泊美</li><li>彩妆品牌：Maquillage</li><li>中国专售：AUPRES欧珀莱、Za姬芮</li><li>香水品牌：JeanPaulGaultier、三宅一生</li><li>洗护品牌：ShiseidoProfessional</li></ul></li><li><p>LVMH</p><ul><li>护肤品牌：Guerlain(娇兰)、ChristianDior(迪奥)、纪梵希(Givenchy)、DomPerignon(唐-裴利农)、Bliss、CLARINS(娇韵诗)</li><li>彩妆品牌：Makeupforever(浮生若梦)、BENEFIT、Cosmetics、AcquadiParma、Fresh、SEPHORA(丝芙兰)</li><li>香水品牌：KENZO(高田贤三)，fendi(芬迪)，Celine(赛琳)、LOEWE、DOLCE&amp;GABBANA(杜嘉班纳)、CHAUMET(舒维)、CalvinKlein(CK)、ChristianLacroi</li></ul></li><li><p>Chanel(香奈儿)</p></li><li>LG<ul><li>顶级护肤品牌：OHUI</li><li>二线护肤品牌：IsaKnox爱之浓思、海皙蓝、LaeVert(莲婷)</li><li>底线品牌：曼丽妃丝、缇兰</li></ul></li></ul><h4 id="12-指甲油"><a href="#12-指甲油" class="headerlink" title="12 指甲油"></a>12 指甲油</h4><ul><li>芭比波朗</li><li>RGB</li><li>NARS</li><li>CND</li><li>莎莉汉森</li><li>巴黎欧莱雅</li><li>ESSIE</li><li>露华浓</li><li>China Glaze</li><li>OPI</li><li>美宝莲Maybelline</li><li>Missha谜尚</li><li>歌诗美COSMAY</li><li>香奈儿</li><li>Za姬芮</li><li>丝芙兰</li><li>安娜苏AnnaSui</li><li>Innisfree悦丝风吟</li><li>TheFaceShop菲斯小铺</li><li>露华浓Revlon</li><li>迪奥Dior</li></ul><h3 id="13-太阳眼镜"><a href="#13-太阳眼镜" class="headerlink" title="13 太阳眼镜"></a>13 太阳眼镜</h3><ul><li>雷德蒙女士太阳镜</li><li>爱靓眼镜女士太阳镜</li><li>阿玛尼女士太阳镜</li><li>暴龙女士太阳镜</li><li>海伦凯勒女士太阳镜</li><li>宝丽来女士太阳镜</li><li>kalikali女士太阳镜</li><li>GUCCI女士太阳镜</li><li>香奈儿女士太阳镜</li><li>雷朋女士太阳镜</li><li>古驰女士太阳镜</li><li>帕莎女士太阳镜</li><li>阿玛尼女士太阳镜</li><li>卡地亚女士太阳镜</li><li>帕莎女士太阳镜</li><li>欣菲特女士太阳镜</li><li>海豚女士太阳镜</li><li>派丽蒙女士太阳镜</li><li>万宝龙女士太阳镜</li><li>保圣女士太阳镜</li><li>宝姿女士太阳镜</li></ul><h3 id="14-手表"><a href="#14-手表" class="headerlink" title="14 手表"></a>14 手表</h3><ul><li>dw手表 尼龙表带简约休闲女士手表、女士简约金属钢带手表、玫瑰金女士手表</li><li>雷达</li><li>浪琴 PRIMALUNA心月 系列L8.111.4.87.6腕表、圆舞曲系列-玫瑰金镶钻腕表</li><li>天梭 T028.210.11.057.01</li><li>名士 灵霓系列MOA10036腕表</li><li>美度 DONNA Caliber 80超长动力储存女士腕表</li><li>艾米龙 净雅系列06.2188.L.6.6.28.6腕表</li><li>万宝龙 明星经典系列U0110304腕表</li><li>艾美 典雅系列LC6016-SS002-130腕表</li><li>欧米茄 星座系列</li><li>卡地亚 蓝气球系列、桑托斯系列、伦敦SOLO系列、「坦克」女款、山度士</li><li>劳力士 日志</li><li>香奈儿BOY FRIEND 系列</li><li>爱彼皇家 橡树满天星</li><li>法穆兰</li></ul><h3 id="15-钱包"><a href="#15-钱包" class="headerlink" title="15 钱包"></a>15 钱包</h3><ul><li>路易威登LV</li><li>古琦欧·古琦Gucci</li><li>香奈儿CHANEL</li><li>普拉达Prada</li><li>圣大保罗Polo</li><li>迪奥Dior</li><li>爱马仕Hermes</li><li>寇兹/寇驰COACH</li><li>登喜路Dunhill</li><li>芬迪Fendi</li></ul><h3 id="16-内衣"><a href="#16-内衣" class="headerlink" title="16 内衣"></a>16 内衣</h3><ul><li>古今</li><li>婷美</li><li>法曼儿</li><li>华歌尔</li><li>仙黛尔</li><li>LA PERLA</li><li>都市丽人</li><li>欧迪芬</li><li>嘉莉诗</li><li>歌瑞尔</li><li>梦芭莎</li><li>猫人</li><li>安莉芳</li><li>维多利亚的秘密</li><li>雅芳</li><li>爱慕</li><li>黛安芬</li><li>曼妮芬</li></ul><h3 id="17-睡衣"><a href="#17-睡衣" class="headerlink" title="17 睡衣"></a>17 睡衣</h3><ul><li>芬腾</li><li>安之伴</li><li>美标Meibiao</li><li>爱慕Aimer</li><li>秋鹿</li><li>歌瑞尔</li><li>康妮雅</li><li>维多利亚的秘密</li><li>美梦</li><li>沃莱卡</li><li>安莉芳</li><li>雪俐</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;GiftForGirl&quot;&gt;&lt;a href=&quot;#GiftForGirl&quot; class=&quot;headerlink&quot; title=&quot;GiftForGirl&quot;&gt;&lt;/a&gt;GiftForGirl&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;专为男士为女士送礼用，包括香水、口红、包包、
      
    
    </summary>
    
      <category term="闲文" scheme="https:mubai.site/categories/%E9%97%B2%E6%96%87/"/>
    
    
      <category term="礼物专线" scheme="https:mubai.site/tags/%E7%A4%BC%E7%89%A9%E4%B8%93%E7%BA%BF/"/>
    
  </entry>
  
  <entry>
    <title>Application的创建、Activity的创建</title>
    <link href="https:mubai.site/2019-10-28-Application%E7%9A%84%E5%88%9B%E5%BB%BA%E3%80%81Activity%E7%9A%84%E5%88%9B%E5%BB%BA/"/>
    <id>https:mubai.site/2019-10-28-Application的创建、Activity的创建/</id>
    <published>2019-10-27T16:00:00.000Z</published>
    <updated>2020-05-07T08:22:09.255Z</updated>
    
    <content type="html"><![CDATA[<p> <em>关于Activity需要知道的更多内容</em></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Activity作为作为四大组件中我们最常见的一个组件，经常接触使用，但是往往每次让我们对这个组件进行说明的时候，我们只知道它的几个生命周期，几种启动模式，但是具体的更多的就讲不出来了。<br>ps：我在写这个之前实际上也是一知半解，所以今天我们一起去看看Activity更多的东西，源码版本为 android-26</p><ul><li>1、Application的创建</li><li>2、Activity的创建和生命周期</li></ul><h4 id="一、Application的创建"><a href="#一、Application的创建" class="headerlink" title="一、Application的创建"></a>一、Application的创建</h4><p>我们知道，java程序想运行都是通过调用main方法来启动，我们的Android应用程序也是如此，但是我们每次都是直接点击手机屏幕的应用图标就直接启动了app，这时候难免有疑惑，我们为什么不需要调用main方法就可以直接启动我们的程序呢，虽然我们没有直接的去写main方法，但是实际上还是通过ActivityThread类的main方法来作为我们应用程序的入口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># ActivityThread类</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        ...</span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line">        ActivityThread thread = new ActivityThread();//1、这边new了一个ActivityThread对象</span><br><span class="line">        thread.attach(false);//2、这边去进行连接，连接什么？</span><br><span class="line">        if (sMainThreadHandler == null) &#123;</span><br><span class="line">            sMainThreadHandler = thread.getHandler();</span><br><span class="line">        &#125;</span><br><span class="line">        if (false) &#123;</span><br><span class="line">            Looper.myLooper().setMessageLogging(new</span><br><span class="line">                    LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;));</span><br><span class="line">        &#125;</span><br><span class="line">        Looper.loop();</span><br><span class="line">        throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>在ActivityThread类中，能看到一个main方法，它就是我们程序的入口，在注释1的地方，会去创建一个ActivityThread对象，在注释2的地方，调用thread的attach方法去连接，具体的连接什么我们继续看下面的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#ActivityThread类</span><br><span class="line">private void attach(boolean system) &#123;</span><br><span class="line">      ...</span><br><span class="line">      if (!system) &#123;</span><br><span class="line">          ...</span><br><span class="line">          final IActivityManager mgr = ActivityManager.getService();//1、通过AIDL，获取AMS的代理对象IActivityManager</span><br><span class="line">          try &#123;</span><br><span class="line">              mgr.attachApplication(mAppThread);//2、这边将AMS和我们的应用进程application进行连接</span><br><span class="line">          &#125; catch (RemoteException ex) &#123;</span><br><span class="line">              throw ex.rethrowFromSystemServer();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          ...</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>关于AIDL，这边不进行展开，我们关心的是注释2，这边通过AIDL将AMS和我们应用进程application进行连接，具体的是调用ActivityManagerService的attachApplication方法进行连接。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#ActivityManagerService类</span><br><span class="line">@Override</span><br><span class="line">public final void attachApplication(IApplicationThread thread) &#123;</span><br><span class="line">      synchronized (this) &#123;</span><br><span class="line">          int callingPid = Binder.getCallingPid();//1、获取pid</span><br><span class="line">          final long origId = Binder.clearCallingIdentity();</span><br><span class="line">          attachApplicationLocked(thread, callingPid);//2、传入pid进行连接</span><br><span class="line">          Binder.restoreCallingIdentity(origId);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>这边的注释1通过Binder对象获取应用的pid，注释2处调用attachApplicationLocked的方法传入pid连接application。需要注意的这边加了synchronized关键字，表示我们需要等待这里执行完毕才能下一步，也就是说我们一个应用需要当我们application被连接后才能走下面的流程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">##ActivityManagerService</span><br><span class="line">private final boolean attachApplicationLocked(IApplicationThread thread,</span><br><span class="line">                                                  int pid, int callingUid, long startSeq) &#123;</span><br><span class="line">        ProcessRecord app;  //1、进程记录类，保存相关的信息</span><br><span class="line">        long startTime = SystemClock.uptimeMillis();</span><br><span class="line">        if (pid != MY_PID &amp;&amp; pid &gt;= 0) &#123;</span><br><span class="line">            synchronized (mPidsSelfLocked) &#123;</span><br><span class="line">                app = mPidsSelfLocked.get(pid);  //2、根据id获取相关信息赋值给记录对象</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        ...</span><br><span class="line">        if (app.instr != null) &#123;  //3、判断进程是否正在活跃</span><br><span class="line">           //Application 4、绑定到当前线程</span><br><span class="line">           thread.bindApplication(processName, appInfo, providers, app.instr.mClass,</span><br><span class="line">                    profilerInfo, app.instr.mArguments, app.instr.mWatcher, app.instr.mUiAutomationConnection,</span><br><span class="line">                    testMode, mBinderTransactionTrackingEnabled, enableTrackAllocation,</span><br><span class="line">                    isRestrictedBackupMode || !normalMode, app.persistent, new Configuration(getGlobalConfiguration()),</span><br><span class="line">                    app.compat, getCommonServicesLocked(app.isolated), mCoreSettingsObserver.getCoreSettingsLocked(),</span><br><span class="line">                    buildSerial, isAutofillCompatEnabled);   </span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //Application 4、绑定到当前线程</span><br><span class="line">            thread.bindApplication(processName, appInfo, providers, null, profilerInfo,</span><br><span class="line">                    null, null, null, testMode, mBinderTransactionTrackingEnabled,</span><br><span class="line">                    enableTrackAllocation, isRestrictedBackupMode || !normalMode, app.persistent,</span><br><span class="line">                    new Configuration(getGlobalConfiguration()), app.compat, getCommonServicesLocked(app.isolated),</span><br><span class="line">                    mCoreSettingsObserver.getCoreSettingsLocked(), buildSerial, isAutofillCompatEnabled);  </span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        // See if the top visible activity is waiting to run in this process...</span><br><span class="line">        //查看顶部可见活动是否正在等待在此进程中进行</span><br><span class="line">        if (normalMode) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                //TODO 5、Activity创建的分析</span><br><span class="line">                //检测top的Activity是否在运行中等待</span><br><span class="line">                if (mStackSupervisor.attachApattachApplicationplicationLocked(app)) &#123;</span><br><span class="line">                    didSomething = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                Slog.wtf(TAG, &quot;Exception thrown launching activities in &quot; + app, e);</span><br><span class="line">                badApp = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Find any services that should be running in this process...</span><br><span class="line">        //查看在此进程中进行的服务</span><br><span class="line">        if (!badApp) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                didSomething |= mServices.attachApplicationLocked(app, processName);</span><br><span class="line">                checkTime(startTime, &quot;attachApplicationLocked: after mServices.attachApplicationLocked&quot;);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                Slog.wtf(TAG, &quot;Exception thrown starting services in &quot; + app, e);</span><br><span class="line">                badApp = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Check if a next-broadcast receiver is in this process...</span><br><span class="line">        //查看在此进程中进行的广播接收者</span><br><span class="line">        if (!badApp &amp;&amp; isPendingBroadcastProcessLocked(pid)) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                didSomething |= sendPendingBroadcastsLocked(app);</span><br><span class="line">                checkTime(startTime, &quot;attachApplicationLocked: after sendPendingBroadcastsLocked&quot;);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                // If the app died trying to launch the receiver we declare it &apos;bad&apos;</span><br><span class="line">                Slog.wtf(TAG, &quot;Exception thrown dispatching broadcasts in &quot; + app, e);</span><br><span class="line">                badApp = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Check whether the next backup agent is in this process...</span><br><span class="line">        //检测下一个备份代理是否在此进程中</span><br><span class="line">        if (!badApp &amp;&amp; mBackupTarget != null &amp;&amp; mBackupTarget.app == app) &#123;</span><br><span class="line">            if (DEBUG_BACKUP) Slog.v(TAG_BACKUP,</span><br><span class="line">                    &quot;New app is backup target, launching agent for &quot; + app);</span><br><span class="line">            notifyPackageUse(mBackupTarget.appInfo.packageName,</span><br><span class="line">                    PackageManager.NOTIFY_PACKAGE_USE_BACKUP);</span><br><span class="line">            try &#123;</span><br><span class="line">                thread.scheduleCreateBackupAgent(mBackupTarget.appInfo,</span><br><span class="line">                        compatibilityInfoForPackageLocked(mBackupTarget.appInfo),</span><br><span class="line">                        mBackupTarget.backupMode);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                Slog.wtf(TAG, &quot;Exception thrown creating backup agent in &quot; + app, e);</span><br><span class="line">                badApp = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看具体的attachApplicationLocked方法里面，注释1处创建了一个进程记录对象用来保存进程的相关信息，注释2根据id获取到相关信息赋值给记录对象，注释3先判断进行是否活跃，然后调用bindApplication的方法进行application的绑定，这边的thread是IApplicationThread对象，IApplicationThread它是一个AIDL的接口，是系统进程调用应用进程的接口，它的实现类是ApplicationThread，是一个在ActivityThread的内部类，注释5的地方是关于Activity的创建，我们这边先跳过，等我们将Application进行绑定完成后在来分析。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">##ActivityThread.ApplicationThread</span><br><span class="line">public final void bindApplication(String processName, ApplicationInfo appInfo...，String buildSerial) &#123;</span><br><span class="line"></span><br><span class="line">            if (services != null) &#123;</span><br><span class="line">                // Setup the service cache in the ServiceManager</span><br><span class="line">                ServiceManager.initServiceCache(services);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            setCoreSettings(coreSettings);//1、添加核心设置</span><br><span class="line"></span><br><span class="line">            //2、将bindApplication带进来的信息封装到AppBindData类中，通过handler发送出去</span><br><span class="line">            AppBindData data = new AppBindData();</span><br><span class="line">            data.processName = processName;</span><br><span class="line">            data.appInfo = appInfo;</span><br><span class="line">            data.providers = providers;</span><br><span class="line">            ...</span><br><span class="line">            sendMessage(H.BIND_APPLICATION, data);//3、将data通过handler发送出去，具体的WHAT 是 H.BIND_APPLICATION</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><p>在注释1会去添加一些核心的设置，我们这边就不去关注，我们看注释2的地方，去将带进来的信息封装到data中然后在注释3通过handler发送出去，具体的WHAT 是 H.BIND_APPLICATION。H是一个继承Handler的子类，这边我们去看下消息是如何被分发处理的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">##ActivityThread.H</span><br><span class="line">public void handleMessage(Message msg) &#123;</span><br><span class="line">            ...</span><br><span class="line">        switch (msg.what) &#123;</span><br><span class="line">            ...</span><br><span class="line">           case BIND_APPLICATION:</span><br><span class="line">                    //1、这边进行handler消息的处理 处理创建Application的消息</span><br><span class="line">                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;bindApplication&quot;);</span><br><span class="line">                    AppBindData data = (AppBindData) msg.obj;</span><br><span class="line">                    handleBindApplication(data);</span><br><span class="line">                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                    break;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这边注释1处理创建Application的消息，调用handleBindApplication的方法去绑定application<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">##ActivityThread</span><br><span class="line">private void handleBindApplication(AppBindData data) &#123;</span><br><span class="line"></span><br><span class="line">      final InstrumentationInfo ii;//1、创建InstrumentationInfo对象</span><br><span class="line"></span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line">      final ContextImpl appContext = ContextImpl.createAppContext(this, data.info); 2、 //获取application的context上下文</span><br><span class="line">      </span><br><span class="line">      //  3、加载instrumentation</span><br><span class="line">      if (ii != null) &#123;</span><br><span class="line">          ...</span><br><span class="line">          </span><br><span class="line">          mInstrumentation.init(this, instrContext, appContext, component,</span><br><span class="line">                  data.instrumentationWatcher, data.instrumentationUiAutomationConnection); //4、instrumentation初始化</span><br><span class="line">          ...</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          mInstrumentation = new Instrumentation();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      try &#123;</span><br><span class="line">        </span><br><span class="line">          Application app = data.info.makeApplication(data.restrictedBackupMode, null);//5、通过makeApplication方法创建application</span><br><span class="line"></span><br><span class="line">          ...</span><br><span class="line">          </span><br><span class="line">          // Do this after providers, since instrumentation tests generally start their</span><br><span class="line">          // test thread at this point, and we don&apos;t want that racing.</span><br><span class="line">          try &#123;</span><br><span class="line">              mInstrumentation.onCreate(data.instrumentationArgs);</span><br><span class="line">          &#125; catch (Exception e) &#123;</span><br><span class="line">              throw new RuntimeException(</span><br><span class="line">                      &quot;Exception thrown in onCreate() of &quot;</span><br><span class="line">                              + data.instrumentationName + &quot;: &quot; + e.toString(), e);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          try &#123;</span><br><span class="line">              mInstrumentation.callApplicationOnCreate(app);//6、回调application的onCreate方法</span><br><span class="line">          &#125; catch (Exception e) &#123;</span><br><span class="line">              if (!mInstrumentation.onException(app, e)) &#123;</span><br><span class="line">                  throw new RuntimeException(</span><br><span class="line">                          &quot;Unable to create application &quot; + app.getClass().getName()</span><br><span class="line">                                  + &quot;: &quot; + e.toString(), e);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">          StrictMode.setThreadPolicy(savedPolicy);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>这个方法里面处理了许多事情，注释1创建了一个InstrumentationInfo对象，在注释2获取了application的上下文，注释3和4去加载并初始化了InstrumentationInfo，注释5是我们的关键地方，通过调用makeApplication的方法创建了我们的application，我们看下makeApplication的方法都做了什么操作。然后在注释6调用InstrumentationInfo去回调application的onCreate方法，到这里我们的application就创建并且回到了我们熟悉onCreate方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">##LoadedApk</span><br><span class="line">public Application makeApplication(boolean forceDefaultAppClass,</span><br><span class="line">           Instrumentation instrumentation) &#123;</span><br><span class="line">       if (mApplication != null) &#123;//1、如果mApplication不为null，直接返回mApplication对象</span><br><span class="line">           return mApplication;</span><br><span class="line">       &#125;</span><br><span class="line">     </span><br><span class="line">       Application app = null;</span><br><span class="line">      //如果是有自定义的application，就用这个，如果没有，就用系统的application</span><br><span class="line">       String appClass = mApplicationInfo.className;</span><br><span class="line">       if (forceDefaultAppClass || (appClass == null)) &#123;</span><br><span class="line">           appClass = &quot;android.app.Application&quot;;</span><br><span class="line">       &#125;</span><br><span class="line">       try &#123;</span><br><span class="line">           //2、获得类加载器然后通过反射去new一个Appliction</span><br><span class="line">           java.lang.ClassLoader cl = getClassLoader();</span><br><span class="line">           ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this);</span><br><span class="line">           app = mActivityThread.mInstrumentation.newApplication(</span><br><span class="line">                   cl, appClass, appContext);</span><br><span class="line">           appContext.setOuterContext(app);</span><br><span class="line">       &#125; catch (Exception e) &#123;</span><br><span class="line">           ...</span><br><span class="line">       &#125;</span><br><span class="line">       mActivityThread.mAllApplications.add(app);</span><br><span class="line">       mApplication = app;//3、赋值给mApplication</span><br><span class="line"></span><br><span class="line">       if (instrumentation != null) &#123;//4、这边会为instrumentation是为null的</span><br><span class="line">           try &#123;</span><br><span class="line">               instrumentation.callApplicationOnCreate(app);//5、这边如果instrumentation不为null，才能执行到这里</span><br><span class="line">           &#125; catch (Exception e) &#123;</span><br><span class="line">               if (!instrumentation.onException(app, e)) &#123;</span><br><span class="line">                  ...</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       ...</span><br><span class="line">       return app;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这边我们首先判断mApplication如果不为null，直接返回这个对象，如果为null的话，我们通过类加载然后反射去new出一个application对象并且赋值给mApplication，还有这边因为我们在调用makeApplication方法时传入的Instrumentation是个null对象，所以我们这边不会去执行<br>callApplicationOnCreate回调onCreate方法的。具体的回调onCreate会在上面的源码注释6的地方去执行回调。</p><h4 id="二、Activity的创建"><a href="#二、Activity的创建" class="headerlink" title="二、Activity的创建"></a>二、Activity的创建</h4><p>这边我们首先需要知道Activity的状态和生命周期</p><p>状态：运行、暂停、停止、销毁(运行和暂停是不可见的，停止和销毁是不可见的)<br>生命周期：包括了常见的onCreate、onResume、onStart、onPause、onStop、onDestory等</p><p>上面的分析过程中我们在ActivityManagerService类中留了一个<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">##ActivityManagerService</span><br><span class="line">private final boolean attachApplicationLocked(IApplicationThread thread,</span><br><span class="line">                                                  int pid, int callingUid, long startSeq) &#123;</span><br><span class="line">        ...</span><br><span class="line"> //5、检测最可见的Activity是否在运行进程中等待，如果再则创建Activity</span><br><span class="line">        //TODO 待分析Activity的创建</span><br><span class="line">        if (mStackSupervisor.attachApplicationLocked(app)) &#123;  </span><br><span class="line">            didSomething = true;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>这边我们对它进行深入下看看是如何创建的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">##ActivityStackSupervisor</span><br><span class="line">boolean attachApplicationLocked(ProcessRecord app) throws RemoteException &#123;</span><br><span class="line">       ...</span><br><span class="line">       for (int displayNdx = mActivityDisplays.size() - 1; displayNdx &gt;= 0; --displayNdx) &#123;</span><br><span class="line">           ArrayList&lt;ActivityStack&gt; stacks = mActivityDisplays.valueAt(displayNdx).mStacks;</span><br><span class="line">           for (int stackNdx = stacks.size() - 1; stackNdx &gt;= 0; --stackNdx) &#123;</span><br><span class="line">               final ActivityStack stack = stacks.get(stackNdx);</span><br><span class="line">               if (!isFocusedStack(stack)) &#123;</span><br><span class="line">                   continue;</span><br><span class="line">               &#125;</span><br><span class="line">               //ActivityRecord来维护Activity运行时的状态信息，需要将Activity绑定到AMS，ActivityRecord才能开始Activity的生命周期</span><br><span class="line">               ActivityRecord hr = stack.topRunningActivityLocked();</span><br><span class="line">               if (hr != null) &#123;</span><br><span class="line">                   if (hr.app == null &amp;&amp; app.uid == hr.info.applicationInfo.uid</span><br><span class="line">                           &amp;&amp; processName.equals(hr.processName)) &#123;</span><br><span class="line">                       try &#123;</span><br><span class="line">                           if (realStartActivityLocked(hr, app, true, true)) &#123;//1、真正的创建Activity</span><br><span class="line">                               didSomething = true;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125; catch (RemoteException e) &#123;</span><br><span class="line">                           throw e;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       ...</span><br><span class="line">       return didSomething;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>在realStartActivityLocked我们会创建Activity<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">##ActivityStackSupervisor</span><br><span class="line"> final boolean realStartActivityLocked(ActivityRecord r, ProcessRecord app,</span><br><span class="line">            boolean andResume, boolean checkConfig) throws RemoteException &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        r.startFreezingScreenLocked(app, 0);//1、开始屏幕相关的启动</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        // schedule launch ticks to collect information about slow apps.</span><br><span class="line">        r.startLaunchTickingLocked();//2、启动定时锁定</span><br><span class="line"></span><br><span class="line">        r.app = app;</span><br><span class="line">        app.waitingToKill = null;</span><br><span class="line">        r.launchCount++;//3、每启动一次launchCount的数量自增</span><br><span class="line">        r.lastLaunchTime = SystemClock.uptimeMillis();//4、修改最后一次的启动时间</span><br><span class="line"></span><br><span class="line">        final ActivityStack stack = task.getStack();</span><br><span class="line">        try &#123;</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            //5、根据具体的包名，通知应用</span><br><span class="line"></span><br><span class="line">         mService.notifyPackageUse(r.intent.getComponent().getPackageName(),</span><br><span class="line">                                      PackageManager.NOTIFY_PACKAGE_USE_ACTIVITY);</span><br><span class="line">            </span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            //6、调用ApplicationThread的scheduleLaunchActivity 方法去启动LaunchActivity</span><br><span class="line">            app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken,</span><br><span class="line">                    System.identityHashCode(r), r.info,</span><br><span class="line">                    // TODO: Have this take the merged configuration instead of separate global and</span><br><span class="line">                    // override configs.</span><br><span class="line">                    mergedConfiguration.getGlobalConfiguration(),</span><br><span class="line">                    mergedConfiguration.getOverrideConfiguration(), r.compat,</span><br><span class="line">                    r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle,</span><br><span class="line">                    r.persistentState, results, newIntents, !andResume,</span><br><span class="line">                    mService.isNextTransitionForward(), profilerInfo);</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        if (isFocusedStack(stack)) &#123;</span><br><span class="line">            mService.startSetupActivityLocked();7、开始设置活动锁</span><br><span class="line">        &#125;</span><br><span class="line">        if (r.app != null) &#123;</span><br><span class="line">            mService.mServices.updateServiceConnectionActivitiesLocked(r.app);//8、更新服务连接活动锁</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这边的注释很多，但是我们主要关心的是注释6，这边调用ApplicationThread的scheduleLaunchActivity 方法去启动LaunchActivity，我们回到ApplicationThread</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">##ActivityThread.ApplicationThread</span><br><span class="line">@Override</span><br><span class="line">public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident,</span><br><span class="line">                                       ..., ProfilerInfo profilerInfo) &#123;</span><br><span class="line"></span><br><span class="line">    updateProcessState(procState, false);</span><br><span class="line"></span><br><span class="line">    ActivityClientRecord r = new ActivityClientRecord();</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    sendMessage(H.LAUNCH_ACTIVITY, r);//通过handler发送启动Activity的消息</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这边是不是很眼熟，我们刚刚的application的绑定也是通过handler去发送消息去处理(这边我们能发现handler是有多么重要了吧，哈哈)，我们去ActivityThread的子类H去看下具体的activity创建的消息处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void handleMessage(Message msg) &#123;</span><br><span class="line">        switch (msg.what) &#123;</span><br><span class="line">            case LAUNCH_ACTIVITY: &#123;//1、接收到关于创建Activity的消息，进行处理</span><br><span class="line">                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityStart&quot;);</span><br><span class="line">                final ActivityClientRecord r = (ActivityClientRecord) msg.obj;</span><br><span class="line">                r.packageInfo = getPackageInfoNoCheck(</span><br><span class="line">                        r.activityInfo.applicationInfo, r.compatInfo);</span><br><span class="line">                handleLaunchActivity(r, null, &quot;LAUNCH_ACTIVITY&quot;);//2、去创建LaunchActivity</span><br><span class="line">                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>根据message的what值我们找到了具体的消息处理，这边会通过handleLaunchActivity去处理我们Activity创建<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">##ActivityThread</span><br><span class="line"> private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) &#123;</span><br><span class="line">        ...</span><br><span class="line">        Activity a = performLaunchActivity(r, customIntent);//1、去执行LaunchActivity</span><br><span class="line"></span><br><span class="line">        if (a != null) &#123;</span><br><span class="line">            r.createdConfig = new Configuration(mConfiguration);</span><br><span class="line">            reportSizeConfigurations(r);</span><br><span class="line">            Bundle oldState = r.state;</span><br><span class="line">            handleResumeActivity(r.token, false, r.isForward,</span><br><span class="line">                    !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason);//2、处理可见Activity</span><br><span class="line">            ...</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // If there was an error, for any reason, tell the activity manager to stop us.</span><br><span class="line">            try &#123;</span><br><span class="line">            //3、这边如何activity是个null的对象，直接通过ActivityManagerService调用finishActivity去关闭掉</span><br><span class="line">                ActivityManager.getService()</span><br><span class="line">                        .finishActivity(r.token, Activity.RESULT_CANCELED, null,</span><br><span class="line">                                Activity.DONT_FINISH_TASK_WITH_ACTIVITY);</span><br><span class="line">            &#125; catch (RemoteException ex) &#123;</span><br><span class="line">                throw ex.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这边我们先看注释1的performLaunchActivity方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">##ActivityThread</span><br><span class="line">private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        ActivityInfo aInfo = r.activityInfo;//1、获取Activity的信息</span><br><span class="line">        if (r.packageInfo == null) &#123;</span><br><span class="line">            r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo,</span><br><span class="line">                    Context.CONTEXT_INCLUDE_CODE);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        ContextImpl appContext = createBaseContextForActivity(r);//2、获取Acitivty的上下文</span><br><span class="line">        Activity activity = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            java.lang.ClassLoader cl = appContext.getClassLoader();//3、获取类加载器，使用cl(类加载器）加载出Activity，再使用反射new出Activity</span><br><span class="line">            activity = mInstrumentation.newActivity(</span><br><span class="line">                    cl, component.getClassName(), r.intent);</span><br><span class="line">            StrictMode.incrementExpectedActivityCount(activity.getClass());</span><br><span class="line">            r.intent.setExtrasClassLoader(cl);</span><br><span class="line">            r.intent.prepareToEnterProcess();</span><br><span class="line">            if (r.state != null) &#123;</span><br><span class="line">                r.state.setClassLoader(cl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">           ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            //4、这边又去调用一次makeApplication方法</span><br><span class="line">            Application app = r.packageInfo.makeApplication(false, mInstrumentation);</span><br><span class="line">            if (activity != null) &#123;</span><br><span class="line">                ...</span><br><span class="line">                appContext.setOuterContext(activity);</span><br><span class="line"></span><br><span class="line">                activity.attach(appContext, this, getInstrumentation(), r.token,</span><br><span class="line">                        r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">                        r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">                        r.referrer, r.voiceInteractor, window, r.configCallback);</span><br><span class="line"></span><br><span class="line">                ...</span><br><span class="line">                if (r.isPersistable()) &#123;//5、这边去调用Activity的onCreate方法</span><br><span class="line">                    mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">                &#125;</span><br><span class="line">                ...</span><br><span class="line"></span><br><span class="line">        &#125; catch (SuperNotCalledException e) &#123;</span><br><span class="line">            throw e;</span><br><span class="line"></span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">           ...</span><br><span class="line">        &#125;</span><br><span class="line">        return activity;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在注释3我们会发现这边是获取类加载去然后通过反射去new出一个Activity，然后在注释5去回调Activity的onCreate方法，到这边我们就能去调用我们的setContentView去加载布局了。注释4的地方又调用了一次makeApplication方法，如果Application不为null，直接返回application对象。<br>现在我们回到上一个源码的注释2那里，看看handleResumeActivity都做了什么?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">##ActivityThread</span><br><span class="line"> final void handleResumeActivity(IBinder token,</span><br><span class="line">                                    boolean clearHide, boolean isForward, boolean reallyResume, int seq, String reason) &#123;</span><br><span class="line">        ...</span><br><span class="line">        r = performResumeActivity(token, clearHide, reason);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这个方法里面有很多代码，我们只需要去看performResumeActivity方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">##ActivityThread</span><br><span class="line">public final ActivityClientRecord performResumeActivity(IBinder token, boolean clearHide, String reason) &#123;</span><br><span class="line">    ...</span><br><span class="line">    r.activity.performResume();//主要是这个方法</span><br><span class="line">    ...</span><br><span class="line">    return r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这边是调用Activity的performResume方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">##Activity</span><br><span class="line">final void performResume() &#123;</span><br><span class="line">        performRestart();</span><br><span class="line"></span><br><span class="line">        mFragments.execPendingActions();</span><br><span class="line"></span><br><span class="line">        mLastNonConfigurationInstances = null;</span><br><span class="line"></span><br><span class="line">        mCalled = false;</span><br><span class="line">        // mResumed is set by the instrumentation</span><br><span class="line">        mInstrumentation.callActivityOnResume(this);//回调Activity的onResume方法</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>到这边我们就能发现它跟Activity的onCreate的回调是类似的，都是通过mInstrumentation.callActivityxxx去回调执行。</p><h4 id="沿着别人走过的路，跟上去发现不一样的风景"><a href="#沿着别人走过的路，跟上去发现不一样的风景" class="headerlink" title="沿着别人走过的路，跟上去发现不一样的风景"></a>沿着别人走过的路，跟上去发现不一样的风景</h4><p>参考链接：<a href="https://www.jianshu.com/p/f55467033146" target="_blank" rel="noopener">https://www.jianshu.com/p/f55467033146</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; &lt;em&gt;关于Activity需要知道的更多内容&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;Activity作为作为四大组件中我们最常见的一个组件，经常接触使
      
    
    </summary>
    
      <category term="Android" scheme="https:mubai.site/categories/Android/"/>
    
    
      <category term="Android" scheme="https:mubai.site/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>5.1节日旅游攻略</title>
    <link href="https:mubai.site/2019-3-31-5.1%E6%97%85%E6%B8%B8%E6%94%BB%E7%95%A5/"/>
    <id>https:mubai.site/2019-3-31-5.1旅游攻略/</id>
    <published>2019-03-30T16:00:00.000Z</published>
    <updated>2019-04-03T08:48:06.696Z</updated>
    
    <content type="html"><![CDATA[<p>5.1节日旅游攻略、未完待续</p><a id="more"></a><h3 id="5-1节日旅游攻略"><a href="#5-1节日旅游攻略" class="headerlink" title="5.1节日旅游攻略"></a>5.1节日旅游攻略</h3><h4 id="第一站：乌镇"><a href="#第一站：乌镇" class="headerlink" title="第一站：乌镇"></a>第一站：乌镇</h4><pre><code>出发站：杭州出发时间：5.1 动车：        G7572：9:57    ￥21.5*2    G7316：10:12  ￥21.5*2时间：5.1-5.2酒店：乌镇小宿 ￥468门票：西栅+东栅联票 ￥190*2景点：列举了主要景点    1、西栅：最适合夜游及住宿的区域，夜晚的水上莲花可以look look        1.1、中国邮政：光绪年间的邮局        1.2、草木本色染坊：拍照        1.3、白莲塔：乌镇最高建筑        1.4、三寸金莲馆：中国女性裹足史        1.5、月老庙：许愿        1.6、邵明书院：邵明太子读书处        1.7、囍庆堂：江南婚礼        1.8、西市河：最美夜景地        1.9、天下第一锅：申请吉尼斯纪录        1.10、乌镇大剧院/大戏院：感受当地人文生活        1.11、茅盾纪念堂：纪念馆    2、东栅        2.1、茅盾故居：文学大师茅盾故居        2.2、宏源泰染坊：拍照        2.3、三白酒坊：酿酒过程        2.4、江南百床馆：中国第一家收藏、展出江南古床的博物馆        2.5、逢源双桥：按男左女右走一遍可以左右逢源        2.6、江南民俗馆：江南民俗文化展示        2.7、江南木雕陈列馆：古代木雕展览        2.8、财神湾：发财啊，去去去。        2.9、立志书院：茅盾的手稿、作品、提字        2.10、修真观广场        2.11、余榴梁钱币馆：各个国家的钱币展示    3、南栅和北栅都属于未开发的地段，原生态美食：找找看</code></pre><h4 id="第二站：苏州"><a href="#第二站：苏州" class="headerlink" title="第二站：苏州"></a>第二站：苏州</h4><pre><code>出发站：乌镇出发时间：5.2动车：        G7586：10：04    ￥85.5*2    G7572：10:126 ￥90.5*2时间：5.2-5.4酒店：苏州小院  ￥530*2景点：苏州景点太多    1、观前街        1.1、拙政园：天下园林之母，门票：70*2        1.2、苏州博物馆：苏州园林风格        1.3、平江路：苏州保存最好的古街        1.4、狮子林：叠石最有名，四大名园之一        1.5、苏州古典园林：世界文化遗产        1.6、太平天国忠王符：苏式彩绘    2、十全街        2.1、网师园：苏州四大名园之一        2.2、沧浪亭：苏州最古老园林        2.3、苏州大学：中国十大最美校园之一        2.4、苏州云岩寺塔：中国第一斜塔    3、石路商圈        3.1、虎丘：吴中第一名胜        3.2、七里山塘：姑苏第一名街        3.3、留园：小家碧玉式，四大名园之一        3.4、剑池：虎丘最神秘的名胜        3.5、万景山庄：苏派盆景精品园        3.6、山塘书院：听苏州评弹        3.7、拥翠山庄：苏州唯一无水园林    4、金鸡湖：        4.1、金鸡湖：骑行、夜景        4.2、月光码头：苏州十大最美夜景之首    5、周庄        5.1、周庄古镇：中国第一水乡        5.2、双桥：故乡的回忆蓝本        5.3、沈万三故居：沈万三        5.4、沈厅：沈万三后人的宅子        5.5、南湖秋月园：水中佛国        5.6、周庄博物馆：了解周庄历史        5.7、富安桥：周庄最古老的桥    6、同里        6.1、同里古镇：江南六大古镇之一        6.2、退思园：世界文化遗产        6.3、珍珠塔：同里最大园林        6.4、耕乐堂：同里八景之一    7、阳澄湖        7.1阳澄湖半岛旅游度假区：阳澄湖大闸蟹    8、太湖        8.1、苏州东山景区：太湖山水第一镇        8.2、苏州西山景区：太湖第一大岛美食：找找</code></pre><h4 id="终点站：杭州"><a href="#终点站：杭州" class="headerlink" title="终点站：杭州"></a>终点站：杭州</h4><pre><code>时间：5.4</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;5.1节日旅游攻略、未完待续&lt;/p&gt;
    
    </summary>
    
      <category term="闲文" scheme="https:mubai.site/categories/%E9%97%B2%E6%96%87/"/>
    
    
      <category term="闲文" scheme="https:mubai.site/tags/%E9%97%B2%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>Me</title>
    <link href="https:mubai.site/Me/"/>
    <id>https:mubai.site/Me/</id>
    <published>2019-02-19T16:00:00.000Z</published>
    <updated>2019-04-03T08:48:21.874Z</updated>
    
    <content type="html"><![CDATA[<p>个人简历，更新中</p><a id="more"></a><script src="https://cdn1.lncld.net/static/js/av-mini-0.6.10.js"></script><script src="http://jerry-cdn.b0.upaiyun.com/hit-kounter/hit-kounter-lc-0.2.0.js"></script><p><span data-hk-page="current"> - </span></p><h3 id="个人简历"><a href="#个人简历" class="headerlink" title="个人简历"></a>个人简历</h3><ul><li><strong>姓名：</strong> 林志文</li><li><strong>花名：</strong> 沐白</li><li><strong>Email：</strong> <a href="mailto:quickly520@126.com" target="_blank" rel="noopener">quickly520@126.com</a></li></ul><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><p>…</p><h4 id="工作经历"><a href="#工作经历" class="headerlink" title="工作经历"></a>工作经历</h4><ul><li><strong>杭州筑家易网络科技股份有限公司 2016.8-至今</strong></li></ul><ul><li><strong>杭州一幅画网络科技有限公司 2016.4-2016.7</strong></li></ul><h4 id="项目经历"><a href="#项目经历" class="headerlink" title="项目经历"></a>项目经历</h4><p>…</p><h4 id="自我评价"><a href="#自我评价" class="headerlink" title="自我评价"></a>自我评价</h4><p>…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;个人简历，更新中&lt;/p&gt;
    
    </summary>
    
    
      <category term="简历" scheme="https:mubai.site/tags/%E7%AE%80%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>物联网设备-WiFi/Bluetooth/ZigBee配网方式</title>
    <link href="https:mubai.site/2018-10-9-%E7%89%A9%E8%81%94%E7%BD%91%E9%80%9A%E4%BF%A1-WiFi:BT:ZigBee%E8%8A%AF%E7%89%87%E7%BA%A7%E6%96%B9%E6%A1%88%E8%A7%A3%E6%9E%90/"/>
    <id>https:mubai.site/2018-10-9-物联网通信-WiFi:BT:ZigBee芯片级方案解析/</id>
    <published>2018-10-08T16:00:00.000Z</published>
    <updated>2019-04-03T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、WIFI设备配网"><a href="#一、WIFI设备配网" class="headerlink" title="一、WIFI设备配网"></a>一、WIFI设备配网</h3><p>智能家居的设备智能化，很多家电设备都安装上了WiFi模块, 方便用户通过手机控制和远程查看家里情况，典型的设备如智能插座，智能空调，智能空气净化器。<br>智能设备首次配置，这个过程简单来讲就是把WiFi设备初始化后，连到家里的无线路由器上。第一次配置成功后，基本就一劳永逸了。</p><a id="more"></a><h4 id="1、目前流行的wifi配置模式一般有以下2种"><a href="#1、目前流行的wifi配置模式一般有以下2种" class="headerlink" title="1、目前流行的wifi配置模式一般有以下2种:"></a>1、目前流行的wifi配置模式一般有以下2种:</h4><ul><li><p>AP模式：</p><p>  智能硬件处于AP模式，手机用于station模式,手机连接智能插座的AP后组成局域网,手机发送需要连接路由的SSID及密码至智能插座,智能硬件主动去连接指定路由后,完成连接</p></li></ul><pre><code>AP（兼容） 模式AP 是 (Wireless) Access Point 的缩写，即 (无线) 访问接入点。简单来讲就像是无线路由器一样，设备打开后进入 AP 模式，在手机的网络列表里面，可以搜索到类似 TPLINK_XXX 的名字（SSID）。连接步骤：1、连接路由器（获取路由器名称）2、请求配网token，用户输入 WiFi 名字和密码后3、初始化硬件设备，使设备进入 AP 模式，Wifi 灯慢闪4、手机切回 WiFi：接入上述 设备出现的 WiFi 名字（SSID）的网络 （类似 TPLINK_XXX）。连上设备后，通过 UDP 发送 经过 AES 加密过的 ssid/password/token5、设备通过 UDP 包获取配置信息，切换网络模式，连接上家里 WiFi，配置完成。断开设备热点。发送token，注册到服务端，登录MQTT服务器6、手机切回到家里面的 WiFi ，根据token，去服务端查找设备。7、服务器返回智能设备的信息</code></pre><ul><li><p>一键配置(smartconfig)模式:</p><p>  智能硬件处于混杂模式下,监听网络中的所有报文;手机APP将SSID和密码编码到UDP报文中,通过广播包或组播报发送,智能硬件接收到UDP报文后解码,得到正确的SSID和密码,然后主动连接指定SSID的路由,完成连接</p><p>  EZ（快捷）Easy-Connect 模式</p><p>  这种快速连接方式，相对于 AP 模式连接简化操作，省了很多步骤，首次配置速度更快。</p><p>  1、手机连上 WiFi，开启 APP 软件，点击”添加新设备”，进入配置界面，输入手机所在 WiFi 密码，请求配网token</p><p>  2、智能硬件开启混杂模式监听所有网络数据包，Wifi 灯快闪</p><p>  3、手机通过广播、组播循环发送 ssid/password/token</p><p>  4、硬件设备通过 UDP 包（长度）获取配置信息捕捉到ssid/password/token，Wifi灯熄灭，连接路由器，连接成功后Wifi灯常亮。发送token，注册到服务端，注册成功后登录MQTT服务器。（广播根据 UDP 包长度，组播根据 IP 地址信息）</p><p>  5、手机根据token，去服务端查找设备，返回设备信息</p></li></ul><h4 id="2、当前主流IOT的wifi方案有"><a href="#2、当前主流IOT的wifi方案有" class="headerlink" title="2、当前主流IOT的wifi方案有:"></a>2、当前主流IOT的wifi方案有:</h4><p>这个功能最早是TI提出并应用于CC3200上;不过从原理上讲,只要芯片驱动支持开启混杂模式(WiFi Promiscuous),就可以支持一键配网功能,只是各个厂家叫法及实现编码方式不同而已;</p><p>手机编码发送采用有UDP组播或广播,不同的发送方式和编码,对应的解码过程也不一样.,当前测试发现,微信是通过UDP广播包实现的;TI是通过往一固定IP地址发送udp包;其他芯片厂家提供的一般为UDP组播方式;</p><p>由于无线数据传播必定是广播的,所以必然可以被监听到;如果AP没有加密的话,UDP直接可以把相关的信息发送出来.但是路由器AP一般都是加密的,而且加密方式不固定.wifi模块在无法直接解析出数据包</p><p>1、广播：发送方可通过改变其所需要发送数据包的长度进行控制<br>所以只要指定出一套利用长度编码的通讯协议,就可利用数据包的Lenght字段进行数据传递</p><p>2、 组播：组播地址是保留的D类地址从224.0.0.0-239.255.255.255<br>IP地址与MAC地址映射关系为:将MAC地址的前25位设定为01.00.5e,而MAC地址的后23位对应IP地址的位;故发送端可以将数据编码在组播ip的后23bit中,通过组播包发送,接收端进行解码即可</p><h3 id="二、Bluetooth配网"><a href="#二、Bluetooth配网" class="headerlink" title="二、Bluetooth配网"></a>二、Bluetooth配网</h3><h3 id="三、Zjgbee"><a href="#三、Zjgbee" class="headerlink" title="三、Zjgbee"></a>三、Zjgbee</h3><hr><p>参考资料：</p><p>Wifi:</p><blockquote><p>WLAN(Wireless Local Area Network)无线局域网络，是一个概念，网络技术术语，IEEE802.11标准是无线局域网最通用的标准<br>Wifi(Wireless Fidelity)是设备商成立的一个联盟，负责测试认证，是使用802.11技术实现的</p></blockquote><p>ZjgBee:</p><blockquote><p>目前在国内采用ZigBee协议智能家居的有3家公司的芯片，恩智浦（NXP）公司（小米智能家居采用的就是该公司的ZigBee芯片），TI公司（德州仪器）CC2530芯片（国内95%以上的公司采用该ZigBee芯片），芯科（Silicon Labs）公司（国内只有极少数公司采用该公司芯片，如聪明屋智能家居采用的是该公司的EM357芯片），该芯片属于ZigBee芯片领域的工业级高性能级别，应用到智能家居居有绝对的优势，规避了传统ZigBee芯片智能家居组网规模小、易丢包不稳定的顽疾。事实证明芯科芯片的智能网关，在保证智能家居系统稳定运行的前提下可以携带120个以上的节点，TI和恩智浦的只能带30个以内的节点。<br>另外芯科（Silicon Labs）公司又发布EFR32MG系列ZigBee芯片，其中部分芯片能同时支持4种无线协议：ZigBee、Thread、BLE（蓝牙）、Proprietary（sub GHZ，小无线），说通俗一点就是用芯科（Silicon Labs）ZigBee芯片开发的ZigBee智能家居可以兼容Thread、BLE（蓝牙）、Proprietary（sub GHZ，小无线）这3种通讯协议的产品，能和这3种通信协议的设备互联互通，技术创新遥遥领先，所以说要做好ZigBee技术智能家居，芯片选择至关重要。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、WIFI设备配网&quot;&gt;&lt;a href=&quot;#一、WIFI设备配网&quot; class=&quot;headerlink&quot; title=&quot;一、WIFI设备配网&quot;&gt;&lt;/a&gt;一、WIFI设备配网&lt;/h3&gt;&lt;p&gt;智能家居的设备智能化，很多家电设备都安装上了WiFi模块, 方便用户通过手机控制和远程查看家里情况，典型的设备如智能插座，智能空调，智能空气净化器。&lt;br&gt;智能设备首次配置，这个过程简单来讲就是把WiFi设备初始化后，连到家里的无线路由器上。第一次配置成功后，基本就一劳永逸了。&lt;/p&gt;
    
    </summary>
    
      <category term="物联网" scheme="https:mubai.site/categories/%E7%89%A9%E8%81%94%E7%BD%91/"/>
    
    
      <category term="物联网" scheme="https:mubai.site/tags/%E7%89%A9%E8%81%94%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>Nexus+Maven搭建私有库</title>
    <link href="https:mubai.site/2018-7-12-Nexus+Maven%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E5%BA%93/"/>
    <id>https:mubai.site/2018-7-12-Nexus+Maven搭建私有库/</id>
    <published>2018-07-11T16:00:00.000Z</published>
    <updated>2019-04-03T08:47:42.234Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Maven：项目管理和自动构建的工具,maven包集中存放的地方就是maven仓库。这些仓库可以放在本地，也可以放在某个远程服务器上，可以是私有的，也可以是共有的。</p></blockquote><blockquote><p>Nexus：强大的maven仓库管理器，简化了本地仓库的维护和外部仓库的访问</p></blockquote><a id="more"></a><h5 id="1-下载安装Nexus3-0"><a href="#1-下载安装Nexus3-0" class="headerlink" title="1.下载安装Nexus3.0"></a>1.下载安装Nexus3.0</h5><p>nexus的下载地址：<strong><a href="https://blog.sonatype.com/" target="_blank" rel="noopener">https://blog.sonatype.com/</a></strong></p><h5 id="2-启动Nexus"><a href="#2-启动Nexus" class="headerlink" title="2.启动Nexus"></a>2.启动Nexus</h5><p>将下载后的zip解压到某个路径下执行</p><blockquote><p>/Users/***/nexus-3.12.1-01-mac/nexus-3.12.1-01/bin/nexus start</p></blockquote><p>执行成功后</p><blockquote><p>Starting nexus</p></blockquote><h5 id="3-浏览器打开Nexus"><a href="#3-浏览器打开Nexus" class="headerlink" title="3.浏览器打开Nexus"></a>3.浏览器打开Nexus</h5><p><strong><a href="http://127.0.0.1:8081/nexus/" target="_blank" rel="noopener">http://127.0.0.1:8081/nexus/</a></strong></p><blockquote><p>注：启动服务需要等待一会</p></blockquote><h5 id="4-用户登录"><a href="#4-用户登录" class="headerlink" title="4.用户登录"></a>4.用户登录</h5><p>默认的是游客身份，可以查看，但是不能配置<br>需要配置的时候使用管理员身份登录：</p><blockquote><p><strong>admin/admin123</strong></p></blockquote><h5 id="5-Blob-Stroes"><a href="#5-Blob-Stroes" class="headerlink" title="5.Blob Stroes"></a>5.Blob Stroes</h5><p>依赖index存储目录，默认存储在default下：</p><p>\sonatype-work\nexus3\blobs\default</p><p>也可以自己新建一个目录专门存在某个仓库的索引，在创建repository可以选择</p><h5 id="6-reponsitory"><a href="#6-reponsitory" class="headerlink" title="6.reponsitory"></a>6.reponsitory</h5><p>Nexus默认创建了几个仓库<br>group:是一个仓库组，包含了hosted和proxy两种库，下载时按配置顺序从中依次查找<br>hosted:一般是部署我们项目打包的jar，供内部人员下载<br>proxy：代理远程仓库，maven-central是默认maven中央仓库代理，通过代理从远程仓库中下载的依赖都会被缓存到nexus的proxy库中</p><h5 id="7-创建自己的reponsitory"><a href="#7-创建自己的reponsitory" class="headerlink" title="7.创建自己的reponsitory"></a>7.创建自己的reponsitory</h5><p>一般情况下我们会选择创建一个hosted仓库</p><p>步骤为<em>repositories –&gt; Add –&gt; hosted repository</em>，在页面的下半部分输入框中填入repository id和repository name即可，另外把deployment policy设置为Allow Redeploy，点击save就创建完成了</p><p>这边我们可以看到我们创建成功的reponsitory，这里有个仓库的地址<br><strong><a href="http://127.0.0.1:8081/repository/test-comment-release/" target="_blank" rel="noopener">http://127.0.0.1:8081/repository/test-comment-release/</a></strong><br>可以复制出来</p><h5 id="8-创建完成后我们在androidStudio创建一个项目，项目中创建一个model"><a href="#8-创建完成后我们在androidStudio创建一个项目，项目中创建一个model" class="headerlink" title="8.创建完成后我们在androidStudio创建一个项目，项目中创建一个model"></a>8.创建完成后我们在androidStudio创建一个项目，项目中创建一个model</h5><p>在根目录的build.gradle的repositories中添加：</p><p><strong>maven{ url ‘<a href="http://127.0.0.1:8081/repository/test-comment-release/&#39;}" target="_blank" rel="noopener">http://127.0.0.1:8081/repository/test-comment-release/&#39;}</a></strong></p><p>然后在model的build.gradle中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">uploadArchives &#123;</span><br><span class="line">    configuration = configurations.archives</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenDeployer &#123;</span><br><span class="line">            snapshotRepository(url: MAVEN_REPO_SNAPSHOT_URL) &#123;</span><br><span class="line">                authentication(userName: NEXUS_USERNAME, password: NEXUS_PASSWORD)</span><br><span class="line">            &#125;</span><br><span class="line">            repository(url: MAVEN_REPO_RELEASE_URL) &#123;</span><br><span class="line">                authentication(userName: NEXUS_USERNAME, password: NEXUS_PASSWORD)</span><br><span class="line">            &#125;</span><br><span class="line">            pom.project &#123;</span><br><span class="line">                version &apos;1.0.0&apos;//版本号可以直接指定</span><br><span class="line">                artifactId &apos;comment-sdk&apos;//这边的id我们可以指定</span><br><span class="line">                groupId GROUP_ID</span><br><span class="line">                packaging TYPE</span><br><span class="line">                description DESCRIPTION</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">artifacts &#123;</span><br><span class="line">    archives file(&apos;model名称.aar&apos;)//我们的model名.aar</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意的是需要在model的build.gradle中添加(使得这个model可以作为maven)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &apos;maven&apos;</span><br></pre></td></tr></table></figure><h5 id="9-在gradle-properties中添加："><a href="#9-在gradle-properties中添加：" class="headerlink" title="9.在gradle.properties中添加："></a>9.在gradle.properties中添加：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Maven仓库的URL</span><br><span class="line">MAVEN_REPO_RELEASE_URL=http://127.0.0.1:8081/repository/mubai-comment-release/  这边是正式的仓库的地址</span><br><span class="line">MAVEN_REPO_SNAPSHOT_URL=http://127.0.0.1:8081/repository/mubai-comment-snapshot/  这边是snapshot的仓库的地址</span><br><span class="line"></span><br><span class="line"># 对应maven的GroupId的值</span><br><span class="line">GROUP = com.comment.sdk  这边我们可以自己指定</span><br><span class="line">##### 登录nexus ossde的用户名</span><br><span class="line"></span><br><span class="line">NEXUS_USERNAME=admin</span><br><span class="line"># 登录nexus oss的密码</span><br><span class="line"></span><br><span class="line">NEXUS_PASSWORD=admin123</span><br><span class="line"></span><br><span class="line"># groupid</span><br><span class="line">GROUP_ID = com.comment.sdk  这边我们可以自己指定</span><br><span class="line"></span><br><span class="line"># type</span><br><span class="line">TYPE = aar</span><br><span class="line"></span><br><span class="line"># description</span><br><span class="line">DESCRIPTION = This is comment sdk 描述</span><br></pre></td></tr></table></figure><p>然后点击右侧的Gradle找到我们需要上传的model，然后里面的upload中的<strong>uploadArchives</strong>双击，然后等待上传aar成功</p><h5 id="10-上传成功后我们可以在nexus上看到我们的上传的aar"><a href="#10-上传成功后我们可以在nexus上看到我们的上传的aar" class="headerlink" title="10.上传成功后我们可以在nexus上看到我们的上传的aar"></a>10.上传成功后我们可以在nexus上看到我们的上传的aar</h5><h5 id="11-然后我们在需要用到的项目中，先去根目录build的地方添加："><a href="#11-然后我们在需要用到的项目中，先去根目录build的地方添加：" class="headerlink" title="11.然后我们在需要用到的项目中，先去根目录build的地方添加："></a>11.然后我们在需要用到的项目中，先去根目录build的地方添加：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">maven&#123; url &apos;http://可以换成服务器的ip地址:8081/repository/mubai-comment-release/&apos;&#125;</span><br></pre></td></tr></table></figure><p>然后在具体的app的build中添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#前面是我们GROUP_ID:ArtifactId:版本号(这些id我们都可以自己在配置的时候去指定)</span><br><span class="line">compile &apos;com.comment.sdk:comment-sdk-debug:1.1.0&apos;</span><br></pre></td></tr></table></figure><p>然后我们就可以引用我们aar包里面的东西</p><p><strong>实际上使用nexus只是作为一个管理aar包的托管服务器，我们在利用gradle将aar包上传到nexus上面</strong></p><hr><p>补充说明：</p><p>maven仓库地址和ID的命名规则</p><p>正式仓库地址：<br><strong>MAVEN_REPO_RELEASE_URL=<a href="http://192.168.1.20:8081/nexus/content/groups/app-public/" target="_blank" rel="noopener">http://192.168.1.20:8081/nexus/content/groups/app-public/</a></strong></p><p>快照仓库地址：<br><strong>MAVEN_REPO_SNAPSHOT_URL=<a href="http://192.168.1.20:8081/nexus/content/repositories/snapshots/" target="_blank" rel="noopener">http://192.168.1.20:8081/nexus/content/repositories/snapshots/</a></strong></p><p><strong>GroupId:  com.zjy.iot.app</strong></p><p><strong>artifactId ‘iot-app-xxx-sdk’</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Maven：项目管理和自动构建的工具,maven包集中存放的地方就是maven仓库。这些仓库可以放在本地，也可以放在某个远程服务器上，可以是私有的，也可以是共有的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Nexus：强大的maven仓库管理器，简化了本地仓库的维护和外部仓库的访问&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Android" scheme="https:mubai.site/categories/Android/"/>
    
    
      <category term="Maven" scheme="https:mubai.site/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>Android Gradle</title>
    <link href="https:mubai.site/2018-2-26-Android%20Gradle%20%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https:mubai.site/2018-2-26-Android Gradle 中遇到的问题/</id>
    <published>2018-02-25T16:00:00.000Z</published>
    <updated>2019-04-03T08:47:32.682Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Failed to resolve: xxx.xxx.xxx:xxx:x.x.x Show in File Show in Project Structure dialog</span><br></pre></td></tr></table></figure><p>有时候在我们创建项目引入一个新的依赖或者打开一个从网上clone下来的项目的时候会遇到这样的问题</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Failed to resolve: xxx.xxx.xxx:xxx:x.x.x Show in File Show in Project Structure dialog&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;有时候在我们创建项目引入一个新的依赖或者打开一个从网上clone下来的项目的时候会遇到这样的问题&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https:mubai.site/categories/Android/"/>
    
    
      <category term="Android" scheme="https:mubai.site/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android9.0曝光新特性</title>
    <link href="https:mubai.site/2018-2-5-Android9.0%E6%9B%9D%E5%85%89%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>https:mubai.site/2018-2-5-Android9.0曝光新特性/</id>
    <published>2018-02-04T16:00:00.000Z</published>
    <updated>2019-04-03T08:47:21.589Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>安卓9.0将加入电话录音功能：提高通话安全性</p><p>通话录音是目前许多手机都有的功能，但安卓原生系统并没有自带这项功能。</p></blockquote><a id="more"></a><p>据外媒<strong>Android Headlines</strong>消息称，发现Google在下个安卓开放源代码（AOSP）中发现新的代码，(此代码可能指向记录录音功能)说明下个安卓版本将会具有记录录音功能。</p><p>据悉，原声<strong>Android9.0</strong>的版本可以提供通话录音，而且通过提示用户进行操作，并且双方在通话的过程中，手机系统每15秒钟会发出一次蜂鸣声(手机将会把频率为1400Hz、每15秒钟重复一次的提示音添加到通话中，该声音将会被通话双方都听到，让对方确认你正在录音)，这种声音是提示呼叫者他们的对话正在被录音。</p><p>为了保证安全性，这段录音文件极有可能会存在Google云服务器中(话说国内如何访问呢…)</p><p>另外，据说<strong>Android9.0</strong>会提高系统的封闭性，让一些高度自由化的操作断绝掉(比如高权限插件、自动签到、个性化UI定制等)，整体的系统机制向iOS靠拢，对于用户来说只能说是喜忧参半，采用封闭机制，APP自启动、高敏感权限申请，等不再会出现，安全性、流畅度、稳定性都将大幅提升，但是却要牺牲原本的可玩性，只能说鱼与熊掌不能兼得吧！</p><p>当然对于开发者来说，提高系统的封闭性后，缺点在于我们对于一些需要的权限、操作需要更多的实现代码，同时原本的一些功能需要通过不同的方式方法实现，好处在于我们可以开发出安全性、稳定性更高的App！</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;安卓9.0将加入电话录音功能：提高通话安全性&lt;/p&gt;
&lt;p&gt;通话录音是目前许多手机都有的功能，但安卓原生系统并没有自带这项功能。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Android" scheme="https:mubai.site/categories/Android/"/>
    
    
      <category term="Android" scheme="https:mubai.site/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android各大应用商店应用图标、截图尺寸</title>
    <link href="https:mubai.site/2018-2-5-Android%E5%90%84%E5%A4%A7%E5%95%86%E5%BA%97%E5%BA%94%E7%94%A8%E5%9B%BE%E6%A0%87%E3%80%81%E6%88%AA%E5%9B%BE%E5%B0%BA%E5%AF%B8/"/>
    <id>https:mubai.site/2018-2-5-Android各大商店应用图标、截图尺寸/</id>
    <published>2018-02-04T16:00:00.000Z</published>
    <updated>2019-04-03T08:47:27.494Z</updated>
    
    <content type="html"><![CDATA[<h3 id="360"><a href="#360" class="headerlink" title="360"></a>360</h3><ul><li>应用图标：512 * 512png</li><li>应用截图：480 * 800 5张 png</li></ul><a id="more"></a><h3 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h3><ul><li>应用图标：512*512 png</li><li>应用截图：480 * 800 5张 </li></ul><h3 id="腾讯"><a href="#腾讯" class="headerlink" title="腾讯"></a>腾讯</h3><ul><li>应用图标：16 <em> 16一张，512 </em> 512一张 png</li><li>应用截图：480 * 800 5张 png</li></ul><h3 id="华为"><a href="#华为" class="headerlink" title="华为"></a>华为</h3><ul><li>应用图标：16 <em> 16一张，512 </em> 512一张 png</li><li>应用截图：480 * 800 5张 png</li></ul><h3 id="魅族"><a href="#魅族" class="headerlink" title="魅族"></a>魅族</h3><ul><li>应用图标：16 <em> 16一张，512 </em> 512一张 png</li><li>应用截图：480 * 800 5张 png</li></ul><h3 id="Oppo"><a href="#Oppo" class="headerlink" title="Oppo"></a>Oppo</h3><ul><li>应用图标：16 <em> 16一张，512 </em> 512一张 png</li><li>应用截图：480 * 800 5张 png</li></ul><h3 id="Vivo"><a href="#Vivo" class="headerlink" title="Vivo"></a>Vivo</h3><ul><li>应用图标：16 <em> 16一张，512 </em> 512一张 png</li><li>应用截图：480 * 800 5张 png</li></ul><h3 id="锤子"><a href="#锤子" class="headerlink" title="锤子"></a>锤子</h3><ul><li>应用图标：16 <em> 16一张，512 </em> 512一张 png</li><li>应用截图：480 * 800 5张 png</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;360&quot;&gt;&lt;a href=&quot;#360&quot; class=&quot;headerlink&quot; title=&quot;360&quot;&gt;&lt;/a&gt;360&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;应用图标：512 * 512png&lt;/li&gt;
&lt;li&gt;应用截图：480 * 800 5张 png&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Android" scheme="https:mubai.site/categories/Android/"/>
    
    
      <category term="Android" scheme="https:mubai.site/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>TensorFlow入门</title>
    <link href="https:mubai.site/2018-2-3-TensorFlow%E5%85%A5%E9%97%A8/"/>
    <id>https:mubai.site/2018-2-3-TensorFlow入门/</id>
    <published>2018-02-02T16:00:00.000Z</published>
    <updated>2019-04-03T08:47:14.943Z</updated>
    
    <content type="html"><![CDATA[<h4 id="MNIST机器学习入门"><a href="#MNIST机器学习入门" class="headerlink" title="MNIST机器学习入门"></a><a href="http://wiki.jikexueyuan.com/project/tensorflow-zh/tutorials/mnist_beginners.html" target="_blank" rel="noopener">MNIST机器学习入门</a></h4><p>MNIST:机器学习的入门，是一个入门级的计算机视觉数据集，包含了2部分：</p><ul><li>手写的数字图片</li><li>数字图片对应的标签</li></ul><a id="more"></a><p>MNIST数据集：官网地址是<a href="http://yann.lecun.com/exdb/mnist/" target="_blank" rel="noopener">Yann LeCun’s website</a><br>下载下来的数据集被分成了2部分：60000行的训练数据集(mnist.train)和10000行的测试数据集(mnist.test)</p><blockquote><p>这么切分的好处在于：在机器学习模式设计时必须有一个单独的测试数据集不用与训练而是用来评估这个模型的性能，从而更加容易把设计的模型推广到其他数据集上(泛化)</p></blockquote><hr><p>参考链接</p><p><a href="http://tensorflow.org/" target="_blank" rel="noopener">英文官方网站</a></p><p><a href="http://wiki.jikexueyuan.com/project/tensorflow-zh/" target="_blank" rel="noopener">TensorFlow 官方文档中文版</a></p><p><a href="https://github.com/tensorflow/tensorflow" target="_blank" rel="noopener">英文版GithHub仓库</a></p><p><a href="https://github.com/jikexueyuanwiki/tensorflow-zh" target="_blank" rel="noopener">中文版GithHub仓库</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;MNIST机器学习入门&quot;&gt;&lt;a href=&quot;#MNIST机器学习入门&quot; class=&quot;headerlink&quot; title=&quot;MNIST机器学习入门&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://wiki.jikexueyuan.com/project/tensorflow-zh/tutorials/mnist_beginners.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MNIST机器学习入门&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;MNIST:机器学习的入门，是一个入门级的计算机视觉数据集，包含了2部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;手写的数字图片&lt;/li&gt;
&lt;li&gt;数字图片对应的标签&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="机器学习" scheme="https:mubai.site/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="https:mubai.site/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Android仓库托管平台</title>
    <link href="https:mubai.site/2018-2-1-Android%E4%BB%93%E5%BA%93%E6%89%98%E7%AE%A1%E5%B9%B3%E5%8F%B0/"/>
    <id>https:mubai.site/2018-2-1-Android仓库托管平台/</id>
    <published>2018-01-31T16:00:00.000Z</published>
    <updated>2019-04-03T08:46:57.904Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Android-Library的托管平台介绍"><a href="#Android-Library的托管平台介绍" class="headerlink" title="Android Library的托管平台介绍"></a>Android Library的托管平台介绍</h4><blockquote><p>Android Studio是从build.gradle里面定义的Maven仓库服务器上下载library</p></blockquote><a id="more"></a><p>在build.gradle中会看到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()//使用Jcenter作为Maven</span><br><span class="line">        mavenCentral()//使用mavenCentral作为Maven</span><br><span class="line">        maven &#123;//自定义maven</span><br><span class="line">            url &apos;https://maven.google.com/&apos;</span><br><span class="line">            name &apos;Google&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过</p><ul><li><p>Jcenter</p><blockquote><p>Jcenter是一个由bintray.com维护的Maven仓库</p></blockquote></li><li><p>mavenCentral</p><blockquote><p>MavenCentral是由sonatype.org维护的Maven仓库</p></blockquote></li><li><p>maven { url ‘自己的仓库服务器地址’ }</p><blockquote><p>有时候会将library放在自己的服务器上，这时候就需要我们添加maven地址</p></blockquote></li></ul><p>但是一般来说我们只会使用<strong>Jcenter</strong>和<strong>mavenCentral</strong>，毕竟自己维护一个服务器地址成本较高，而且对于使用者来说他们只需要添加代码的依赖地址</p><blockquote><p>实际上除了Maven仓库外还有另外一种仓库：<a href="http://ant.apache.org/ivy/" target="_blank" rel="noopener">Ivy仓库</a></p></blockquote><h4 id="Jcenter和mavenCentral比较"><a href="#Jcenter和mavenCentral比较" class="headerlink" title="Jcenter和mavenCentral比较"></a>Jcenter和mavenCentral比较</h4><p>两个仓库都具有相同的使命：提供Java或者Android的Library服务</p><p>最开始的时候，AndroidStudio选择<strong>MavenCentral</strong>作为默认仓库，后来由于<strong>MavenCentral</strong>的不友好，对于开发者上传Library很难，同时由于其他的种种原因，AndroidStudio决定把<strong>MavenCentral</strong>换成<strong>Jcenter</strong></p><pre><code>* jcenter通过CDN发送library，开发者可以享受到更快的下载体验。* jcenter是全世界最大的Java仓库，因此在Maven Central 上有的 在jcenter上也极有可能有。换句话说jcenter是Maven Central的超集。* 上传library到仓库很简单，不需要像在 Maven Central上做很多复杂的事情* 友好的用户界面</code></pre><hr><blockquote><p>其他相关问题</p></blockquote><ul><li>如果要了解如何发布自己的library到Jcenter，可以查看<a href="http://mubai.site/%E9%A1%B9%E7%9B%AE%E5%8F%91%E5%B8%83%E5%88%B0%E5%85%AC%E5%85%B1%E7%9A%84jcenter%E4%BB%93%E5%BA%93/" target="_blank" rel="noopener">发布Library到Jcenter</a></li><li>有时候我们通过Jcenter依赖Library的时候加载很慢，可以查看<a href="http://blog.csdn.net/xiongbatianxia30146/article/details/63686359" target="_blank" rel="noopener">解决JCenter下载太慢的问题</a>来解决</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Android-Library的托管平台介绍&quot;&gt;&lt;a href=&quot;#Android-Library的托管平台介绍&quot; class=&quot;headerlink&quot; title=&quot;Android Library的托管平台介绍&quot;&gt;&lt;/a&gt;Android Library的托管平台介绍&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;Android Studio是从build.gradle里面定义的Maven仓库服务器上下载library&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Android" scheme="https:mubai.site/categories/Android/"/>
    
    
      <category term="Android" scheme="https:mubai.site/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>项目发布到jcenter仓库</title>
    <link href="https:mubai.site/2018-1-25-Jcenter%20/"/>
    <id>https:mubai.site/2018-1-25-Jcenter /</id>
    <published>2018-01-24T16:00:00.000Z</published>
    <updated>2019-04-03T08:46:50.286Z</updated>
    
    <content type="html"><![CDATA[<h3 id="项目所需的步骤"><a href="#项目所需的步骤" class="headerlink" title="项目所需的步骤"></a>项目所需的步骤</h3><h4 id="一、添加插件"><a href="#一、添加插件" class="headerlink" title="一、添加插件"></a>一、添加插件</h4><h5 id="在项目目录的build-gradle-中的-dependencies-添加："><a href="#在项目目录的build-gradle-中的-dependencies-添加：" class="headerlink" title="在项目目录的build.gradle 中的 dependencies 添加："></a>在项目目录的build.gradle 中的 dependencies 添加：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">classpath &quot;com.jfrog.bintray.gradle:gradle-bintray-plugin:1.5&quot; </span><br><span class="line">classpath &apos;com.github.dcendents:android-maven-gradle-plugin:1.4.1&apos;</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="二、配置gradle"><a href="#二、配置gradle" class="headerlink" title="二、配置gradle"></a>二、配置gradle</h4><h5 id="同时在需要添加到jcenter的libary的build-gradle根目录添加："><a href="#同时在需要添加到jcenter的libary的build-gradle根目录添加：" class="headerlink" title="同时在需要添加到jcenter的libary的build.gradle根目录添加："></a>同时在需要添加到jcenter的libary的build.gradle根目录添加：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &apos;com.github.dcendents.android-maven&apos; </span><br><span class="line">apply plugin: &apos;com.jfrog.bintray&apos;</span><br><span class="line">version = &quot;1.0.1&quot; //这里的version是可以更新的版本号*</span><br></pre></td></tr></table></figure><h5 id="1-在local-properties添加用户名和key"><a href="#1-在local-properties添加用户名和key" class="headerlink" title="(1)在local.properties添加用户名和key"></a>(1)在local.properties添加用户名和key</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bintray.user=openproject </span><br><span class="line">// your bintrayuser name </span><br><span class="line">bintray.apikey=****** </span><br><span class="line">// your bintray api key`</span><br></pre></td></tr></table></figure><h5 id="2-继续在根目录添加："><a href="#2-继续在根目录添加：" class="headerlink" title="(2)继续在根目录添加："></a>(2)继续在根目录添加：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def siteUrl = &apos;https://github.com/MoMuBai/Test&apos; </span><br><span class="line">// #修改# // 项目的主页地址，我这里是我的PickerView项目在github的链接地址 </span><br><span class="line">def gitUrl = &apos;https://github.com/MoMuBai/Test.git&apos; </span><br><span class="line">// #修改# // 项目 git 地址，我这里同样是用Github上的git地址 </span><br><span class="line">group = &quot;com.mubai&quot; </span><br><span class="line">// #修改# // 组名称</span><br></pre></td></tr></table></figure><h5 id="3-打包javadocjar和sourcejar"><a href="#3-打包javadocjar和sourcejar" class="headerlink" title="(3)打包javadocjar和sourcejar"></a>(3)打包javadocjar和sourcejar</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">install &#123; </span><br><span class="line">    repositories.mavenInstaller &#123;</span><br><span class="line">        // This generates POM.xml with proper parameters</span><br><span class="line">        pom &#123;</span><br><span class="line">            project &#123;</span><br><span class="line">                packaging &apos;aar&apos;</span><br><span class="line">                name &apos;Less Code For Android&apos;</span><br><span class="line">                url siteUrl</span><br><span class="line">                licenses &#123;</span><br><span class="line">                    license &#123;</span><br><span class="line">                        name &apos;The Apache Software License, Version 2.0&apos;</span><br><span class="line">                        url &apos;http://www.apache.org/licenses/LICENSE-2.0.txt&apos;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                developers &#123;</span><br><span class="line">                    developer &#123;</span><br><span class="line">                        id &apos;mubai&apos;</span><br><span class="line">                        name &apos;mubai.lzw&apos;</span><br><span class="line">                        email &apos;quickly520@126.com&apos;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                scm &#123;</span><br><span class="line">                    connection gitUrl</span><br><span class="line">                    developerConnection gitUrl</span><br><span class="line">                    url siteUrl</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-打包javadocjar和sourcejar"><a href="#4-打包javadocjar和sourcejar" class="headerlink" title="(4)打包javadocjar和sourcejar"></a>(4)打包javadocjar和sourcejar</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">task sourcesJar(type: Jar) &#123;</span><br><span class="line">    from android.sourceSets.main.java.srcDirs</span><br><span class="line">    classifier = &apos;sources&apos;</span><br><span class="line">&#125;</span><br><span class="line">task javadoc(type: Javadoc) &#123;</span><br><span class="line">    source = android.sourceSets.main.java.srcDirs</span><br><span class="line">    classpath += project.files(android.getBootClasspath().join(File.pathSeparator))</span><br><span class="line">&#125;</span><br><span class="line">task javadocJar(type: Jar, dependsOn: javadoc) &#123;</span><br><span class="line">    classifier = &apos;javadoc&apos;</span><br><span class="line">    from javadoc.destinationDir</span><br><span class="line">&#125;</span><br><span class="line">artifacts &#123;</span><br><span class="line">    archives javadocJar</span><br><span class="line">    archives sourcesJar</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-上传到Jcenter仓库-需要去从local-properties中读取"><a href="#5-上传到Jcenter仓库-需要去从local-properties中读取" class="headerlink" title="(5)上传到Jcenter仓库 需要去从local.properties中读取"></a>(5)上传到Jcenter仓库 需要去从local.properties中读取</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Properties properties = new Properties()</span><br><span class="line">properties.load(project.rootProject.file(&apos;local.properties&apos;).newDataInputStream())</span><br><span class="line">bintray &#123;</span><br><span class="line">    user = properties.getProperty(&quot;bintray.user&quot;)</span><br><span class="line">    key = properties.getProperty(&quot;bintray.apikey&quot;)</span><br><span class="line">    configurations = [&apos;archives&apos;]</span><br><span class="line">    pkg &#123;</span><br><span class="line">        repo = &quot;maven&quot;</span><br><span class="line">        name = &quot;test-library&quot;                // project name in jcenter</span><br><span class="line">        websiteUrl = siteUrl</span><br><span class="line">        vcsUrl = gitUrl</span><br><span class="line">        licenses = [&quot;Apache-2.0&quot;]</span><br><span class="line">        publish = true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三、执行命令"><a href="#三、执行命令" class="headerlink" title="三、执行命令"></a>三、执行命令</h4><h5 id="通过命令进入项目目录执行命令"><a href="#通过命令进入项目目录执行命令" class="headerlink" title="通过命令进入项目目录执行命令"></a>通过命令进入项目目录执行命令</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./gradlew javadocJar</span><br><span class="line">./gradlew sourcesJar</span><br><span class="line">./gradlew install</span><br><span class="line">./gradlew bintrayUpload</span><br></pre></td></tr></table></figure><h3 id="Bintray所需的步骤"><a href="#Bintray所需的步骤" class="headerlink" title="Bintray所需的步骤"></a><a href="https://bintray.com/" target="_blank" rel="noopener">Bintray</a>所需的步骤</h3><h4 id="一、注册账号也可以通过Git直接登录"><a href="#一、注册账号也可以通过Git直接登录" class="headerlink" title="一、注册账号也可以通过Git直接登录"></a>一、注册账号也可以通过Git直接登录</h4><h4 id="二、添加一个新的Repository-名字跟在gradle配置的一样"><a href="#二、添加一个新的Repository-名字跟在gradle配置的一样" class="headerlink" title="二、添加一个新的Repository(名字跟在gradle配置的一样)"></a>二、添加一个新的Repository(名字跟在gradle配置的一样)</h4><h4 id="三、在gradle命令执行完成后可以到Bintray进行提交审核-一般几个小时"><a href="#三、在gradle命令执行完成后可以到Bintray进行提交审核-一般几个小时" class="headerlink" title="三、在gradle命令执行完成后可以到Bintray进行提交审核(一般几个小时)"></a>三、在gradle命令执行完成后可以到Bintray进行提交审核(一般几个小时)</h4><h4 id="四、审核通过之后就可以进行依赖的添加使用了"><a href="#四、审核通过之后就可以进行依赖的添加使用了" class="headerlink" title="四、审核通过之后就可以进行依赖的添加使用了"></a>四、审核通过之后就可以进行依赖的添加使用了</h4><p><code>compile &#39;com.mubai:library:1.0.1&#39;</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;项目所需的步骤&quot;&gt;&lt;a href=&quot;#项目所需的步骤&quot; class=&quot;headerlink&quot; title=&quot;项目所需的步骤&quot;&gt;&lt;/a&gt;项目所需的步骤&lt;/h3&gt;&lt;h4 id=&quot;一、添加插件&quot;&gt;&lt;a href=&quot;#一、添加插件&quot; class=&quot;headerlink&quot; title=&quot;一、添加插件&quot;&gt;&lt;/a&gt;一、添加插件&lt;/h4&gt;&lt;h5 id=&quot;在项目目录的build-gradle-中的-dependencies-添加：&quot;&gt;&lt;a href=&quot;#在项目目录的build-gradle-中的-dependencies-添加：&quot; class=&quot;headerlink&quot; title=&quot;在项目目录的build.gradle 中的 dependencies 添加：&quot;&gt;&lt;/a&gt;在项目目录的build.gradle 中的 dependencies 添加：&lt;/h5&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;classpath &amp;quot;com.jfrog.bintray.gradle:gradle-bintray-plugin:1.5&amp;quot; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;classpath &amp;apos;com.github.dcendents:android-maven-gradle-plugin:1.4.1&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android" scheme="https:mubai.site/categories/Android/"/>
    
    
      <category term="Android" scheme="https:mubai.site/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android反编译</title>
    <link href="https:mubai.site/2018-1-18-%E5%8F%8D%E7%BC%96%E8%AF%91/"/>
    <id>https:mubai.site/2018-1-18-反编译/</id>
    <published>2018-01-17T16:00:00.000Z</published>
    <updated>2019-04-02T08:44:43.757Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Android" scheme="https:mubai.site/categories/Android/"/>
    
    
      <category term="Android" scheme="https:mubai.site/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android屏幕适配</title>
    <link href="https:mubai.site/2018-1-11-Android%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D/"/>
    <id>https:mubai.site/2018-1-11-Android屏幕适配/</id>
    <published>2018-01-10T16:00:00.000Z</published>
    <updated>2019-04-03T08:46:39.534Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>实际上很早就想写关于Android屏幕适配的总结了，但是由于各种各样的理由推迟了</p></blockquote><a id="more"></a><h4 id="什么是屏幕适配"><a href="#什么是屏幕适配" class="headerlink" title="什么是屏幕适配"></a>什么是屏幕适配</h4><p>屏幕适配即在不同分辨率、尺寸、比例的设备上显示达到一样的效果</p><h4 id="为什么要屏幕适配"><a href="#为什么要屏幕适配" class="headerlink" title="为什么要屏幕适配"></a>为什么要屏幕适配</h4><p>由于Android系统的开放性，任何用户、开发者、OEM厂商、运营商都可以对Android进行定制，修改成他们想要的样子，这种情况下导致了Android系统的碎片化严重</p><blockquote><p>碎片化：系统碎片化(小米MIUI、华为EMUI、魅族flyme)、屏幕大小碎片化(5.0、5.5、6.0)、屏幕分辨率碎片化(320x480、480x800、720x1280、1080x1920)</p><p>这里有Android碎片化的数据：<a href="https://opensignal.com/reports/2014/android-fragmentation/" target="_blank" rel="noopener">戳这里</a></p></blockquote><h4 id="如何进行屏幕适配"><a href="#如何进行屏幕适配" class="headerlink" title="如何进行屏幕适配"></a>如何进行屏幕适配</h4><h5 id="在屏幕适配开始前，我们需要对Android的一些屏幕相关单位有所了解"><a href="#在屏幕适配开始前，我们需要对Android的一些屏幕相关单位有所了解" class="headerlink" title="在屏幕适配开始前，我们需要对Android的一些屏幕相关单位有所了解"></a>在屏幕适配开始前，我们需要对Android的一些屏幕相关单位有所了解</h5><ul><li>像素：单位px，屏幕上的点，我们看到的图像都是由一个个小点构成的</li><li>屏幕尺寸：屏幕上对角线的长度，单位是英寸，一英寸为2.54厘米，现在市场上常见的有4.7、5.0、5.5、6.0等尺寸的手机</li><li>屏幕分辨率：横纵方向上的像素点数，如1920*1080，即纵向上有1920个像素点，横向上有1080个像素点</li><li>屏幕每英寸点数：单位dpi，为屏幕分辨率/屏幕尺寸所得的值，如一个1920*1080的手机，它的纵向尺寸为3英寸，横向尺寸为5.3英寸，那么它的像素密度为1080/3=360dpi，屏幕分辨率越高，尺寸越小，那么它的像素密度就越高</li><li>屏幕像素密度：density = dpi/160</li><li>屏幕像素无关密度：单位dp或者是dip，与物流像素点无关，是Android特有的单位，是为了保证在不同屏幕像素密度的设备上显示相同的效果</li><li>屏幕独立比例像素：单位sp，类似dp，一般是用来设置文字大小</li></ul><p>这里用张表格来各个单位之间的关系</p><table><thead><tr><th>密度类型</th><th style="text-align:center">代表的分辨率（px）</th><th style="text-align:right">屏幕每英寸点数（dpi）</th><th style="text-align:right">屏幕密度（density）</th><th style="text-align:right">换算（px/dp）</th><th style="text-align:right">比例</th></tr></thead><tbody><tr><td>低密度（ldpi）</td><td style="text-align:center">240x320</td><td style="text-align:right">120</td><td style="text-align:right">0.75</td><td style="text-align:right">1dp = 0.75px</td><td style="text-align:right">3</td></tr><tr><td>中密度（mdpi）</td><td style="text-align:center">320x480</td><td style="text-align:right">160</td><td style="text-align:right">1</td><td style="text-align:right">1dp = 1px</td><td style="text-align:right">4</td></tr><tr><td>高密度（hdpi）</td><td style="text-align:center">480x800</td><td style="text-align:right">240</td><td style="text-align:right">1.5</td><td style="text-align:right">1px = 1.5dp</td><td style="text-align:right">6</td></tr><tr><td>超高密度（xhdpi）</td><td style="text-align:center">720x1280</td><td style="text-align:right">320</td><td style="text-align:right">2</td><td style="text-align:right">1dp = 2px</td><td style="text-align:right">8</td></tr><tr><td>超超高密度（xxhdpi）</td><td style="text-align:center">1080x1920</td><td style="text-align:right">480</td><td style="text-align:right">3</td><td style="text-align:right">1dp = 3px</td><td style="text-align:right">12</td></tr></tbody></table><h5 id="如何适配"><a href="#如何适配" class="headerlink" title="如何适配"></a>如何适配</h5><hr><p>参考链接</p><p><a href="https://www.jianshu.com/p/ec5a1a30694b" target="_blank" rel="noopener">Android 屏幕适配：最全面的解决方案</a></p><p><a href="http://blog.csdn.net/zhaokaiqiang1992/article/details/45419023#%E5%B1%8F%E5%B9%95%E5%B0%BA%E5%AF%B8" target="_blank" rel="noopener">Android屏幕适配全攻略(最权威的官方适配指导)</a></p><p><a href="http://stormzhang.com/android/2014/05/16/android-screen-adaptation/" target="_blank" rel="noopener">Android 屏幕适配</a></p><p><a href="http://blog.csdn.net/guolin_blog/article/details/8830286" target="_blank" rel="noopener">Android官方提供的支持不同屏幕大小的全部方法</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;实际上很早就想写关于Android屏幕适配的总结了，但是由于各种各样的理由推迟了&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Android" scheme="https:mubai.site/categories/Android/"/>
    
    
      <category term="Android" scheme="https:mubai.site/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>阿里云大使</title>
    <link href="https:mubai.site/2018-1-10-%E9%98%BF%E9%87%8C%E4%BA%91%E5%A4%A7%E4%BD%BF%E8%A1%8C%E8%B5%B0%E4%B8%AD/"/>
    <id>https:mubai.site/2018-1-10-阿里云大使行走中/</id>
    <published>2018-01-09T16:00:00.000Z</published>
    <updated>2019-04-03T08:46:32.468Z</updated>
    
    <content type="html"><![CDATA[<p>💰💰💰💰💰💰💰💰💰💰💰💰💰💰💰💰💰💰💰💰💰💰💰</p><p><strong>满满的$$$镇楼</strong></p><blockquote><p>在使用阿里云提供的域名服务中偶然发现云大使这个组织，然后发现这是个让其他的人通过使用你的幸运券去购买阿里云产品，你就可以获得对应的返佣比例，最高可达30%(如被推荐的人新购买或者是升级了自己的域名服务。支付了10000元，则云大使就可以获得3000元的返佣)</p></blockquote><p>说的简单点，云大使就是<strong>分享幸运券-&gt;坐等返佣</strong>的过程，通俗点就是个<strong>赚钱，钱，钱</strong>的过程，重要的话要说三遍</p><a id="more"></a><blockquote><p>当然是要有人使用了你分享的幸运券的前提下</p></blockquote><p>我们现在就来说说如何用云大使实现我们的目标：<strong>月入百万、荣登CEO、迎娶白富美</strong>我的<strong><a href="https://promotion.aliyun.com/ntms/act/ambassador/sharetouser.html?userCode=2j1udai5&amp;utm_source=2j1udai5" target="_blank" rel="noopener">幸运券</a></strong></p><h5 id="1-加入云大使"><a href="#1-加入云大使" class="headerlink" title="1.加入云大使"></a>1.加入云大使</h5><p>首先需要你有<a href="https://www.aliyun.com/?utm_medium=text&amp;utm_source=bdbrand&amp;utm_campaign=bdbrand&amp;utm_content=se_32492" target="_blank" rel="noopener">阿里云</a>的账号，然后你就可以通过<a href="https://promotion.aliyun.com/ntms/yunparter/zhaomu.html?spm=5176.bbsr569878.0.0.ZUuEom" target="_blank" rel="noopener">云大使报名入口</a>加入云大使</p><h5 id="2-分享使用幸运券及好处"><a href="#2-分享使用幸运券及好处" class="headerlink" title="2.分享使用幸运券及好处"></a>2.分享使用幸运券及好处</h5><ul><li><p>网页端：加入云大使后会对应的<strong><a href="https://expense.console.aliyun.com/#/ambassador/ticket/product" target="_blank" rel="noopener">生成你的幸运券</a></strong>，然后你可以通过复制<strong><a href="https://promotion.aliyun.com/ntms/act/ambassador/sharetouser.html?userCode=2j1udai5&amp;utm_source=2j1udai5" target="_blank" rel="noopener">你的幸运券</a></strong>分享出去</p></li><li><p>App端：<strong>阿里云App-&gt;我的-&gt;推开奖励-&gt;分享全部产品幸运券</strong>然后就可以通过其他方式分享到支付宝、钉钉、微信、QQ等</p></li></ul><h5 id="3-使用幸运券"><a href="#3-使用幸运券" class="headerlink" title="3.使用幸运券"></a>3.使用幸运券</h5><ul><li><p>如何使用幸运券：其他人在选择<strong>阿里云产品-&gt;购买-&gt;确认订单的环节-&gt;使用云大使的幸运券-&gt;提交订单-&gt;完成支付</strong>，整个流程后即可认为幸运券被使用</p></li><li><p>使用幸运券的好处：</p><ul><li>幸运券实际上是有优惠的，只是它的优惠金额是随机的</li><li>订单支付大于0元可参与抽奖</li><li>首购ecs大于1000元可参与抽奖</li></ul></li></ul><blockquote><p>当前阿里云可以使用幸运券的产品共29款</p></blockquote><h5 id="4-坐等返佣"><a href="#4-坐等返佣" class="headerlink" title="4.坐等返佣"></a>4.坐等返佣</h5><p>18年1月返利新规<strong>【返佣率高达30%无封顶返利】</strong></p><p><img src="http://p0sgkjh7x.bkt.clouddn.com/47499416-AC74-4B5C-A057-CFB5E0D3F738.png" alt="1月份新规图"></p><ul><li><p>返利时间：一般情况下当月的奖励将会在下下月的20号左右返利，如1月月份推荐的返利将在18年3月20日左右发放，（一般情况下只会提前不会延后）返利将会发放到绑定的支付宝账号中</p></li><li><p>需要注意:要完成<strong>1实名认证-&gt;2.绑定支付宝-&gt;3.现金购云产品&gt;=100元(第3条在校学生通过学生认证除外)</strong>才能够完成返利提现</p></li></ul><hr><blockquote><p>附上阿里云可以使用幸运券产品图(18年1月份新图)，总有一款适合你，</p></blockquote><p><img src="http://p0sgkjh7x.bkt.clouddn.com/8406A892-DDBD-4345-83C8-24A9AE3D26A7.png" alt="图1"><br><img src="http://p0sgkjh7x.bkt.clouddn.com/32693FE6-4454-4440-B48B-BAEB2A81FCA4.png" alt="图2"><br><img src="http://p0sgkjh7x.bkt.clouddn.com/D7D61595-2640-4918-B4AC-1FB3A86C485C.png" alt="图3"></p><p>可以根据自己的需要选择云产品，使用我的<strong><a href="https://promotion.aliyun.com/ntms/act/ambassador/sharetouser.html?userCode=2j1udai5&amp;utm_source=2j1udai5" target="_blank" rel="noopener">幸运券</a></strong>来实现你的幸运产品</p><p>参考链接</p><p><a href="https://bbs.aliyun.com/read/325184.html?spm=5176.2020520127.100133.6.niQOZ8" target="_blank" rel="noopener">大神引路–新手云大使入门导引</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;💰💰💰💰💰💰💰💰💰💰💰💰💰💰💰💰💰💰💰💰💰💰💰&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;满满的$$$镇楼&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在使用阿里云提供的域名服务中偶然发现云大使这个组织，然后发现这是个让其他的人通过使用你的幸运券去购买阿里云产品，你就可以获得对应的返佣比例，最高可达30%(如被推荐的人新购买或者是升级了自己的域名服务。支付了10000元，则云大使就可以获得3000元的返佣)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;说的简单点，云大使就是&lt;strong&gt;分享幸运券-&amp;gt;坐等返佣&lt;/strong&gt;的过程，通俗点就是个&lt;strong&gt;赚钱，钱，钱&lt;/strong&gt;的过程，重要的话要说三遍&lt;/p&gt;
    
    </summary>
    
      <category term="闲文" scheme="https:mubai.site/categories/%E9%97%B2%E6%96%87/"/>
    
    
      <category term="闲文" scheme="https:mubai.site/tags/%E9%97%B2%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>谈谈Android中的JNI和NDK</title>
    <link href="https:mubai.site/2018-1-9-Android%20JNI%E5%92%8CNDK/"/>
    <id>https:mubai.site/2018-1-9-Android JNI和NDK/</id>
    <published>2018-01-08T16:00:00.000Z</published>
    <updated>2019-04-03T08:46:25.253Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近发现光看源码的过程是在太枯燥了，准备开始以博客的形式来解读源码，一方面是为了能让自己更好的巩固知识点，一方面是为了能展(zhuang)现(bi)下自己</p></blockquote><p>今天要来说说<strong>JNI</strong>和<strong>NDK</strong>，最近发现使用<strong>NDK</strong>开发的需求正在不断增加啊，不管是为了能<strong>与本地的代码交互</strong>或者是为了<strong>更好的体验(使用C、C++的so)</strong>都在不断的促使我们使用<strong>NDK</strong>。</p><a id="more"></a><h4 id="什么是JNI"><a href="#什么是JNI" class="headerlink" title="什么是JNI"></a>什么是JNI</h4><ul><li>定义：<strong>JNI(Java Native Interface)</strong> Java本地接口</li><li>作用：我们可以通过<strong>JNI</strong>来使<strong>Java</strong>能与<strong>本地的其他语言(C、C++)</strong>进行<strong>交互</strong></li><li>优势：实际开发中，有时候会遇到一些性能要求的功能，而<strong>Java</strong>代码在处理性能方面远远不如<strong>C、C++</strong>，所以我们可以通过<strong>C、C++</strong>开发功能，然后通过<strong>JNI</strong>来使得<strong>Java</strong>代码与<strong>C、C++代码</strong>的交互(很多人都会举例一大堆JNI的应用场景，实际上不管是什么使用场景都是基于<strong>Java</strong>代码和<strong>其他语言</strong>的交互)，所以说JNI可以扩展JVM的能力，可以进行驱动开发，复用已有的一些开源库，而且一些产品的核心技术一般也是采用JNI开发，不易被破解</li><li>劣势：尽管<strong>JNI</strong>带来了很多的使用场景，提高了与本地语言交互的能力，但是它也带来了一些不足，我们都知道Java火爆的原因之一就是它的<strong>跨平台</strong>，但是现在<strong>JNI</strong>与本地的语言的交互导致我们需要为不同的系统的本地语言来实现不同的代码，削弱了Java的<strong>跨平台性</strong>，而且有一点就是通过JNI调用还是会比C、C++编写的原生应用要慢一点</li></ul><h4 id="什么是NDK"><a href="#什么是NDK" class="headerlink" title="什么是NDK"></a>什么是NDK</h4><ul><li>定义：NDK(Native Development Kit)，Google对其定义为一套允许您使用原生代码语言(例如C和C++)实现部分应用的工具集</li><li>作用：能让我们快速的开发C、C++的so动态库，并且将so和应用一起打包成APK</li></ul><h4 id="JNI和NDK的关系"><a href="#JNI和NDK的关系" class="headerlink" title="JNI和NDK的关系"></a>JNI和NDK的关系</h4><p>NDK为我们生成了C、C++的so动态库，JNI又提供了Java代码和其他语言(C、C++)交互的能力，这两者之间可以实现互补，可以说JNI是目的，而NDK是实现JNI的手段，通过NDK来实现JNI的功能，最后达到“Java+C”的开发方式</p><h4 id="NDK的使用"><a href="#NDK的使用" class="headerlink" title="NDK的使用"></a>NDK的使用</h4><blockquote><p>开发环境：Mac OS 10.13.2 + Android Studio 3.0</p></blockquote><h5 id="NDK的添加配置"><a href="#NDK的添加配置" class="headerlink" title="NDK的添加配置"></a>NDK的添加配置</h5><p>打开<strong>Preferences-&gt;Appearance&amp;Behavior-&gt;SystemSettings-&gt;AndroidSDK-&gt;SDKTools</strong>勾选<strong>NDK</strong>下载</p><p><img src="http://p0sgkjh7x.bkt.clouddn.com/58B7EDC0-46FF-493F-BE65-937F00D93CEF.png" alt="NDK配置添加"></p><p>等待安装完毕</p><p>我这边已经安装完毕可以在<strong>local.properties</strong>中看到</p><blockquote><p>这些是Android Studio自动生成的</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ndk.dir=/Users/lzw/Library/Android/sdk/ndk-bundle</span><br><span class="line">sdk.dir=/Users/lzw/Library/Android/sdk</span><br></pre></td></tr></table></figure><h5 id="项目中添加JNI支持"><a href="#项目中添加JNI支持" class="headerlink" title="项目中添加JNI支持"></a>项目中添加JNI支持</h5><blockquote><p>我不添加好像也可以…</p></blockquote><p>在<strong>gradle.properties</strong>中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android.useDeprecatedNdk=true</span><br></pre></td></tr></table></figure><p>然后在app的<strong>build.gradle</strong>中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &apos;com.android.application&apos;</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion 23</span><br><span class="line">    buildToolsVersion &quot;26.0.2&quot;</span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        minSdkVersion 15</span><br><span class="line">        targetSdkVersion 23</span><br><span class="line">        versionCode 1</span><br><span class="line">        versionName &quot;1.0&quot;</span><br><span class="line"></span><br><span class="line">        testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot;</span><br><span class="line"></span><br><span class="line">        ndk &#123;</span><br><span class="line">        //要支持的CPU都有哪些，可以自己选择添加</span><br><span class="line">            abiFilters &quot;armeabi-v7a&quot;,&quot;armeabi&quot;,&quot;arm64-v8a&quot;,&quot;mips&quot;,&quot;mips64&quot;</span><br><span class="line">            //生成的so名称</span><br><span class="line">            moduleName &quot;MuBaiYs7&quot;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled false</span><br><span class="line">            proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])</span><br><span class="line">    compile &apos;com.android.support:appcompat-v7:23.1.0&apos;</span><br><span class="line">    testCompile &apos;junit:junit:4.12&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点在于添加了注释的那2句话：</p><h5 id="项目中添加Java访问C的接口类"><a href="#项目中添加Java访问C的接口类" class="headerlink" title="项目中添加Java访问C的接口类"></a>项目中添加Java访问C的接口类</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class AndroidJni &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 要与C层交互的方法</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static native String getString();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 加载so，要跟build.gradle中自己定义so名称保持一致</span><br><span class="line">     */</span><br><span class="line">    static &#123;</span><br><span class="line">        System.loadLibrary(&quot;MuBaiYs7&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们会根据方法<figure class="highlight plain"><figcaption><span>function Java_com_lzw_ys7_jni_AndroidJni_getString```创建方法，然后Studio会为我们在根目录中生成一个cpp的文件夹，里面有一个.c文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![C层中的方法](http://p0sgkjh7x.bkt.clouddn.com/D618011D-DB8B-4A1A-92F5-2702CEC7FB76.png)</span><br><span class="line"></span><br><span class="line">这个文件的名称是可以自己修改的，我们查看这个文件可以发现，它就提供了一个方法，返回一个字符串，这边我们让它返回&quot;MuBaiYs7Jni&quot;</span><br></pre></td></tr></table></figure></p><p>#include &lt;jni.h&gt;</p><p>JNIEXPORT jstring JNICALL<br>Java_com_lzw_ys7_jni_AndroidJni_getString(JNIEnv *env, jobject instance) {</p><pre><code>return (*env)-&gt;NewStringUTF(env, &quot;MuBaiYs7Jni&quot;);</code></pre><p>}</p><p><code>`</code></p><h5 id="调用Java代码"><a href="#调用Java代码" class="headerlink" title="调用Java代码"></a>调用Java代码</h5><ul><li>调用Jni的方法</li></ul><p><img src="http://p0sgkjh7x.bkt.clouddn.com/A66025A1-356E-414D-9CEE-E9FC8592584E.png" alt="具体调用"></p><ul><li>运行成功后我们可以看到，说明我们调用成功</li></ul><p><img src="http://p0sgkjh7x.bkt.clouddn.com/84E09BA1-1855-4685-8439-CCD1146227B6.png" alt="运行结果"></p><h5 id="得到so文件"><a href="#得到so文件" class="headerlink" title="得到so文件"></a>得到so文件</h5><blockquote><p>这边我们是自己使用项目中的C方法，但是实际项目中很多时候都是把方法封装成so文件进行开发，类似于jar包和arr包</p></blockquote><p>我们这边直接切换项目的展示形式：<strong>Android-&gt;Project</strong><br>然后查看build-&gt;intermediates-&gt;ndk-&gt;debug-&gt;lib</p><p><img src="http://p0sgkjh7x.bkt.clouddn.com/4421444A-9F7A-427E-AF44-B12D012804AF.png" alt="ndk"></p><p>这边的<strong>libMuBaiYs7.so</strong>就是我们根据项目中的<code>jnitest.c</code>文件封装出来的<strong>so</strong>文件</p><p>我们可以把这里的<strong>so</strong>文件复制到其他项目中的<strong>lib</strong>或者是<strong>jniLibs</strong>文件中进行使用</p><blockquote><p>需要注意的是不能单独复制<strong>so</strong>文件，要将各个CPU对应的<strong>so</strong>文件分别复制出来到文件中</p></blockquote><p>这边只是NDK和Jni的入门使用，关于Jni常用的类型和方法会在其他的时间进行学习介绍</p><p>未完待续</p><hr><p>参考链接：</p><p><a href="https://developer.android.google.cn/ndk/index.html" target="_blank" rel="noopener">Android NDK</a></p><p><a href="https://www.jianshu.com/p/aba734d5b5cd" target="_blank" rel="noopener">Android JNI编程—JNI基础</a></p><p><a href="https://www.jianshu.com/p/ac00d59993aa" target="_blank" rel="noopener">Android NDK开发：JNI基础篇</a></p><p><a href="http://www.jcodecraeer.com/a/anzhuokaifa/2017/0401/7769.html" target="_blank" rel="noopener">Android Studio jni开发入门——看我就够了！</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近发现光看源码的过程是在太枯燥了，准备开始以博客的形式来解读源码，一方面是为了能让自己更好的巩固知识点，一方面是为了能展(zhuang)现(bi)下自己&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天要来说说&lt;strong&gt;JNI&lt;/strong&gt;和&lt;strong&gt;NDK&lt;/strong&gt;，最近发现使用&lt;strong&gt;NDK&lt;/strong&gt;开发的需求正在不断增加啊，不管是为了能&lt;strong&gt;与本地的代码交互&lt;/strong&gt;或者是为了&lt;strong&gt;更好的体验(使用C、C++的so)&lt;/strong&gt;都在不断的促使我们使用&lt;strong&gt;NDK&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https:mubai.site/categories/Android/"/>
    
    
      <category term="Android" scheme="https:mubai.site/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>从比特币中浅谈区块链技术</title>
    <link href="https:mubai.site/2018-1-5-%E6%B5%85%E8%B0%88%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/"/>
    <id>https:mubai.site/2018-1-5-浅谈区块链技术/</id>
    <published>2018-01-04T16:00:00.000Z</published>
    <updated>2019-04-03T08:46:21.316Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>昨天的<strong>CPIH</strong>(中国医药控股有限公司)疯狂的涨幅566%，瞬间看懵了，有消息称是因为被收购了才导致的暴涨，(到后来已经慢慢下跌，最后收盘时涨幅137%），说实话真的是跟过山车一样，心脏病都能给你吓出来😶</p></blockquote><a id="more"></a><h3 id="比特币"><a href="#比特币" class="headerlink" title="比特币"></a>比特币</h3><blockquote><p>比特币(bitcoin)的概念是中本聪在09年提出的，它是数字货币</p></blockquote><p>17年的比特币 比特币就跟过山车一样</p><p>我们想通过比特币的交易来谈谈什么是区块链</p><h3 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h3><p>来自维基百科对区块链的定义</p><blockquote><p>区块链：(英语：blockchain)是用分布式数据库识别、传播和记载信息的智能化对等网络，也称为价值互联网，中本聪在08年与《比特币白皮书》中提出了”区块链”概念，并在09年创立了比特币社会网络，开发出第一个区块，即”创世区块”。</p></blockquote><p>区块链的本质是解决信任问题，降低信任成本的技术方案，目的是为了<strong>去中心化</strong>，<strong>去信用中介</strong>，它的核心是<strong>一堆个体</strong>，是通过<strong>去中心化</strong>和<strong>去信任</strong>的方式<strong>集体</strong>维护一个可靠数据库(加密安全性)，简单来说就是<strong>分布式记账</strong>，这个账本<strong>不可撤销</strong>，<strong>不能修改</strong>，它实际上也是比特币的底层技术。</p><p><em>任意节点损坏，不会影响其他节点(损坏的节点不需要理他)</em></p><p>大数据：数据的来源维度多，不是数据多</p><p>共识机制：所有人都是认可的</p><p>大数据是牺牲一致性来换取可用性和分区容忍性的，而区块链却先优先保证一致性</p><p>去中心化和共识机制的矛盾，需要注意平衡</p><h3 id="区块链的发展"><a href="#区块链的发展" class="headerlink" title="区块链的发展"></a>区块链的发展</h3><h4 id="比特币-（1-0）"><a href="#比特币-（1-0）" class="headerlink" title="比特币 （1.0）"></a>比特币 （1.0）</h4><h4 id="数字资产和智能合约-（2-0）"><a href="#数字资产和智能合约-（2-0）" class="headerlink" title="数字资产和智能合约 （2.0）"></a>数字资产和智能合约 （2.0）</h4><h4 id="区块链大社会-3-0"><a href="#区块链大社会-3-0" class="headerlink" title="区块链大社会  (3.0)"></a>区块链大社会  (3.0)</h4><h4 id="ICO金融"><a href="#ICO金融" class="headerlink" title="ICO金融"></a>ICO金融</h4><h4 id="新能源模式"><a href="#新能源模式" class="headerlink" title="新能源模式"></a>新能源模式</h4><h4 id="智能社区"><a href="#智能社区" class="headerlink" title="智能社区"></a>智能社区</h4><h4 id="供应链管理"><a href="#供应链管理" class="headerlink" title="供应链管理"></a>供应链管理</h4><h3 id="区块链的问题"><a href="#区块链的问题" class="headerlink" title="区块链的问题"></a>区块链的问题</h3><h4 id="性能和容量问题："><a href="#性能和容量问题：" class="headerlink" title="性能和容量问题："></a>性能和容量问题：</h4><ul><li><p>去中心化和共识机制的矛盾</p></li><li><p>账本存储容量和处理性能的矛盾</p></li></ul><h4 id="安全性问题"><a href="#安全性问题" class="headerlink" title="安全性问题"></a>安全性问题</h4><ul><li><p>51%攻击</p></li><li><p>私钥与终端安全</p></li><li><p>共识机制的安全</p></li></ul><h4 id="尚未建议统一的标准"><a href="#尚未建议统一的标准" class="headerlink" title="尚未建议统一的标准"></a>尚未建议统一的标准</h4><h4 id="衍生市场混乱"><a href="#衍生市场混乱" class="headerlink" title="衍生市场混乱"></a>衍生市场混乱</h4><h3 id="从企业的角度："><a href="#从企业的角度：" class="headerlink" title="从企业的角度："></a>从企业的角度：</h3><ul><li>没有找到大的落地应用场景</li><li>区块链急速目前不够成熟，无法支撑某些业务领域</li><li>行业人才匮乏，一般公司无法组建区块链技术团队开发产品</li><li>公众的认知相对较少，接受度不高</li><li>高能耗</li><li>数据库存储空间</li><li>处理大规模交易的抗压能力</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;昨天的&lt;strong&gt;CPIH&lt;/strong&gt;(中国医药控股有限公司)疯狂的涨幅566%，瞬间看懵了，有消息称是因为被收购了才导致的暴涨，(到后来已经慢慢下跌，最后收盘时涨幅137%），说实话真的是跟过山车一样，心脏病都能给你吓出来😶&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="闲文" scheme="https:mubai.site/categories/%E9%97%B2%E6%96%87/"/>
    
    
      <category term="闲文" scheme="https:mubai.site/tags/%E9%97%B2%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>AttachInfo的初步了解和解析</title>
    <link href="https:mubai.site/2017-12-30-AttachInfo%E7%9A%84%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3%E5%92%8C%E8%A7%A3%E6%9E%90/"/>
    <id>https:mubai.site/2017-12-30-AttachInfo的初步了解和解析/</id>
    <published>2017-12-29T16:00:00.000Z</published>
    <updated>2019-04-02T08:44:07.471Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">View&#123;</span><br><span class="line"> ...</span><br><span class="line">  /**</span><br><span class="line">   * A set of information given to a view when it is attached to its parent window.</span><br><span class="line">   */</span><br><span class="line">     final static class AttachInfo &#123;</span><br><span class="line">    interface Callbacks &#123;</span><br><span class="line">            void playSoundEffect(int effectId);</span><br><span class="line">            boolean performHapticFeedback(int effectId, boolean always);</span><br><span class="line">        &#125;</span><br><span class="line">         static class InvalidateInfo &#123;</span><br><span class="line">         ...</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        final IWindowSession mSession;</span><br><span class="line"></span><br><span class="line">        final IWindow mWindow;</span><br><span class="line"></span><br><span class="line">        final IBinder mWindowToken;</span><br><span class="line"></span><br><span class="line">        final Display mDisplay;</span><br><span class="line"></span><br><span class="line">        final Callbacks mRootCallbacks;</span><br><span class="line"></span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>View</strong>的显示过程是需要依附在<strong>Window</strong>窗口上的，而<strong>View</strong>和<strong>Window</strong>的关系是通过<strong>AttachInfo</strong>来管理的，但是实际上这个类我们使用的很少，它是View的内部类而且不是公开的，我们一般只有在ViewRootImpl等类中使用到</p><blockquote><p>我们可以通过AttachInfo来获取当前View依附的是哪个Window窗口</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
      <category term="Android" scheme="https:mubai.site/categories/Android/"/>
    
    
      <category term="Android" scheme="https:mubai.site/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>从项目需求到PopupWindow在到Window的过程浅析</title>
    <link href="https:mubai.site/2017-12-27-%E4%BB%8EPopupWindow%E5%88%B0Window%E7%9A%84%E8%BF%87%E7%A8%8B%E6%B5%85%E6%9E%90/"/>
    <id>https:mubai.site/2017-12-27-从PopupWindow到Window的过程浅析/</id>
    <published>2017-12-26T16:00:00.000Z</published>
    <updated>2019-04-03T08:46:11.252Z</updated>
    
    <content type="html"><![CDATA[<h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><blockquote><p>项目中有这么个需求，底部是5个Tab选项，中间那个是一个圆形的高位按钮选项，点击中间选项会从底部弹出个布局，并且这个布局的视觉效果是要在这个圆形选项的底部…这么说有点混乱，来张效果图看看</p></blockquote><a id="more"></a><p><img src="http://p0sgkjh7x.bkt.clouddn.com/3BD32333-AE0F-4F31-8D8A-596D12178F9B.png" height="220" width="150"><strong>点击场景后</strong><br><img src="http://p0sgkjh7x.bkt.clouddn.com/388EEDFA-1AFB-4DA1-9DDD-D605717110B0.png" height="220" width="150"></p><h4 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h4><blockquote><p>看到这2个设计图的时候第一想法是底部3个<strong>tab</strong>选项然后点击场景后弹出个<strong>PopupWindow</strong>，因为用过而且用的场景还挺多的。</p></blockquote><p>然后啪啦啪啦的一堆代码出现了，下面的3个<strong>tab</strong>选项用简单的实现了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    android:background=&quot;#4FC3F3&quot;</span><br><span class="line">    android:orientation=&quot;vertical&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;RelativeLayout</span><br><span class="line">        android:id=&quot;@+id/layout&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;50dp&quot;</span><br><span class="line">        android:layout_alignParentBottom=&quot;true&quot;</span><br><span class="line">        android:background=&quot;#D8D8D8&quot;</span><br><span class="line">        android:orientation=&quot;horizontal&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;TextView</span><br><span class="line">            android:layout_width=&quot;50dp&quot;</span><br><span class="line">            android:layout_height=&quot;40dp&quot;</span><br><span class="line">            android:layout_centerVertical=&quot;true&quot;</span><br><span class="line">            android:layout_marginLeft=&quot;15dp&quot;</span><br><span class="line">            android:background=&quot;#9F79EE&quot;</span><br><span class="line">            android:gravity=&quot;center&quot;</span><br><span class="line">            android:text=&quot;智控&quot; /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &lt;TextView</span><br><span class="line">            android:layout_width=&quot;50dp&quot;</span><br><span class="line">            android:layout_height=&quot;40dp&quot;</span><br><span class="line">            android:layout_alignParentRight=&quot;true&quot;</span><br><span class="line">            android:layout_centerVertical=&quot;true&quot;</span><br><span class="line">            android:layout_marginRight=&quot;15dp&quot;</span><br><span class="line">            android:background=&quot;#9F79EE&quot;</span><br><span class="line">            android:gravity=&quot;center&quot;</span><br><span class="line">            android:text=&quot;个人&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/RelativeLayout&gt;</span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">    android:id=&quot;@+id/noun_text&quot;</span><br><span class="line">        android:layout_width=&quot;60dp&quot;</span><br><span class="line">        android:layout_height=&quot;60dp&quot;</span><br><span class="line">        android:layout_alignParentBottom=&quot;true&quot;</span><br><span class="line">        android:layout_centerHorizontal=&quot;true&quot;</span><br><span class="line">        android:background=&quot;#FFFFFF&quot;</span><br><span class="line">        android:gravity=&quot;center&quot;</span><br><span class="line">        android:text=&quot;场景&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/RelativeLayout&gt;</span><br></pre></td></tr></table></figure><p>大概的效果就是这样的，只是个初步的布局，毕竟这边是为了演示效果</p><p><img src="http://p0sgkjh7x.bkt.clouddn.com/B8E680CD-11EC-4870-9D2B-C5B1F2EDDB7E.png" height="250" width="150"></p><p>然后添加中间场景的点击事件，刚也说了想用到<strong>PopupWindow</strong>从底部弹出，然后就开始去实现设计图的效果</p><p>下面就是PopupWindow的实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private PopupWindow mPopupWindow;</span><br><span class="line">/**</span><br><span class="line"> * PopupWindow的View</span><br><span class="line"> */</span><br><span class="line">private View popView;</span><br><span class="line">/**</span><br><span class="line"> *场景TextView</span><br><span class="line"> */</span><br><span class="line">private TextView nounText;</span><br><span class="line">/**</span><br><span class="line"> *底部Layout</span><br><span class="line"> */</span><br><span class="line">private LinearLayout layout;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">super.onCreate(savedInstanceState);</span><br><span class="line">setContentView(R.layout.activity_popup);</span><br><span class="line">nounText = (TextView) findViewById(R.id.noun_text);</span><br><span class="line">layout = (LinearLayout) findViewById(R.id.layout);</span><br><span class="line">popView = LayoutInflater.from(this).inflate(R.layout.popup_layout, null);</span><br><span class="line">mPopupWindow = new PopupWindow(popView, WindowManager.LayoutParams.MATCH_PARENT, WindowManager.LayoutParams.WRAP_CONTENT);</span><br><span class="line">mPopupWindow.setOutsideTouchable(true);</span><br><span class="line"></span><br><span class="line">nounText.setOnClickListener(v -&gt; &#123;</span><br><span class="line">    mPopupWindow.showAtLocation(nounText, Gravity.CENTER_HORIZONTAL | Gravity.BOTTOM, 0, layout.getHeight());</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而想法是美好的，但是现实往往是残酷的…</p><p>最后的实现效果却是这样的</p><p><img src="http://p0sgkjh7x.bkt.clouddn.com/912830D1-3B7D-4391-BB8C-6829D68213D1.png" height="250" width="150"><strong>对比下这2个图</strong><img src="http://p0sgkjh7x.bkt.clouddn.com/B8E680CD-11EC-4870-9D2B-C5B1F2EDDB7E.png" height="250" width="150"></p><p>咋一看是没有问题，但是实际上中间的那个场景选项并没有盖在底部的那个popView上面，当时的想法就是让设计改下(😶，然而就是想想而已)</p><p>后来开始思考如果让这个<strong>PopView</strong>在场景的下面，当时有2个思路：</p><ul><li>1.通过在<strong>PopView</strong>的底部中间加个半圆形衔接下面的场景选项，营造出遮盖的视觉效果</li><li>2.因为<strong>PopupWindow</strong>是需要依附在某个组件上的，想能不能再场景的底层在添加个组件(被场景选项遮盖着)，然后让<strong>PopupWindow</strong>去依附这个看不见的组件</li></ul><p>有了思路就开始动手试试看，然而现实是这2个都不能很好实现要的效果，第一个是因为添加半圆形的时候位置很容易出错，特别是适配的时候，第二个思路的结果发现结果还是跟原来的一样，尽管<strong>PopupWindow</strong>依附的是在场景下的组件，但是效果还是跟依附场景的时候一样😓…</p><blockquote><p><strong>Why(当时想法只剩下这个了…)</strong></p></blockquote><p>要想知道原因，我们就要从<strong>PopupWindow</strong>的内部实现方法来分析</p><h4 id="PopupWindow内部方法的初步分析"><a href="#PopupWindow内部方法的初步分析" class="headerlink" title="PopupWindow内部方法的初步分析"></a>PopupWindow内部方法的初步分析</h4><blockquote><p><strong>PopupWindow</strong>它不是一个<strong>View</strong>或者是<strong>ViewGroup</strong>，所以在使用的时候需要的传入我们的布局View,这边需要注意的是它既不是<strong>View</strong>也不是<strong>ViewGroup</strong>，那么它是什么呢？</p></blockquote><ul><li><strong>PopupWindow</strong>的创建</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private PopupWindow mPopupWindow;</span><br><span class="line">/**</span><br><span class="line"> * PopupWindow的View</span><br><span class="line"> */</span><br><span class="line">private View popView;</span><br><span class="line">popView = LayoutInflater.from(this).inflate(R.layout.popup_layout, null);</span><br><span class="line">mPopupWindow = new PopupWindow(popView, WindowManager.LayoutParams.MATCH_PARENT, WindowManager.LayoutParams.WRAP_CONTENT);</span><br></pre></td></tr></table></figure><p>代码中创建<strong>PopupWindow</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public PopupWindow(View contentView, int width, int height, boolean focusable) &#123;</span><br><span class="line">/**</span><br><span class="line"> * 如果contentView不为空，通过contentView获取WindowManager对象</span><br><span class="line"> * 所以这边我们可以想到了window窗口这个对象，进而popupWindow可能跟window有关，实际上从它的命名也能猜到了</span><br><span class="line"> */</span><br><span class="line">    if (contentView != null) &#123;</span><br><span class="line">        mContext = contentView.getContext();</span><br><span class="line">        mWindowManager = (WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE);</span><br><span class="line">    &#125;</span><br><span class="line">//设置contentView</span><br><span class="line">    setContentView(contentView);</span><br><span class="line">    //设置宽度</span><br><span class="line">    setWidth(width);</span><br><span class="line">    //设置高度</span><br><span class="line">    setHeight(height);</span><br><span class="line">    //默认focusable为false</span><br><span class="line">    setFocusable(focusable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建的过程实际上很简单,通过<strong>PopupWindow</strong>的构造方法传入需要的contentView、宽、高就能够得到一个<strong>PopupWindow</strong>对象，但是我们刚也说了它不是<strong>View</strong>也不是<strong>ViewGroup</strong>那它是如何能够显示的呢</p><p>在项目使用<strong>PopupWindow</strong>的时候是通过<strong>showAtLocation</strong>方法来设置具体的显示位置的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mPopupWindow.showAtLocation(nounText, Gravity.CENTER_HORIZONTAL | Gravity.BOTTOM, 0, layout.getHeight());</span><br></pre></td></tr></table></figure><p><strong>PopupWindow</strong>还有其他的设置显示的方法，这里我们就不具体的说明，但是实际上最后都是需要用到下面这几个方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//获取WindowManager的布局参数</span><br><span class="line">final WindowManager.LayoutParams p = createPopupLayoutParams(anchor.getWindowToken());</span><br><span class="line"></span><br><span class="line">//准备Pop</span><br><span class="line">preparePopup(p);</span><br><span class="line"></span><br><span class="line">//引用Pop</span><br><span class="line">invokePopup(p);</span><br></pre></td></tr></table></figure><p>所以我们最需要关注的还是这几个方法的实现过程</p><p>返回<strong>Window</strong>的布局参数<strong>WindowManager.LayoutParams</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private WindowManager.LayoutParams createPopupLayoutParams(IBinder token) &#123;</span><br><span class="line">    final WindowManager.LayoutParams p = new WindowManager.LayoutParams();</span><br><span class="line">...//这边省略了一些关于设置布局参数p的方法</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>准备<strong>PopupWindow</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private void preparePopup(WindowManager.LayoutParams p) &#123;</span><br><span class="line"> ...</span><br><span class="line">    if (mDecorView != null) &#123;</span><br><span class="line">        mDecorView.cancelTransitions();</span><br><span class="line">    &#125;</span><br><span class="line">    if (mBackground != null) &#123;//如果mBackground不为空即设置了popupWindow的背景图片</span><br><span class="line">        mBackgroundView = createBackgroundView(mContentView);</span><br><span class="line">        mBackgroundView.setBackground(mBackground);</span><br><span class="line">    &#125; else &#123;//如果没有设置背景图片的话，让contentView==背景View</span><br><span class="line">        mBackgroundView = mContentView;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mDecorView = createDecorView(mBackgroundView);</span><br><span class="line">    mBackgroundView.setElevation(mElevation);</span><br><span class="line">    p.setSurfaceInsets(mBackgroundView, true /*manual*/, true /*preservePrevious*/);</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引用<strong>PopupWindow</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private void invokePopup(WindowManager.LayoutParams p) &#123;</span><br><span class="line">    if (mContext != null) &#123;</span><br><span class="line">        p.packageName = mContext.getPackageName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final PopupDecorView decorView = mDecorView;</span><br><span class="line">    decorView.setFitsSystemWindows(mLayoutInsetDecor);</span><br><span class="line">    </span><br><span class="line">    setLayoutDirectionFromAnchor();</span><br><span class="line">//这边通过addView方法添加我们的PopupView</span><br><span class="line">    mWindowManager.addView(decorView, p);</span><br><span class="line"></span><br><span class="line">    if (mEnterTransition != null) &#123;</span><br><span class="line">        decorView.requestEnterTransition(mEnterTransition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<strong>WindowManager</strong>的<strong>addView()</strong>把我们的<strong>PopupDecorView</strong>以及布局的参数P添加到<strong>Window</strong>上</p><hr><p>未完待续…</p><h4 id="PopupWindow延伸问题"><a href="#PopupWindow延伸问题" class="headerlink" title="PopupWindow延伸问题:"></a>PopupWindow延伸问题:</h4><blockquote><p>这里会添加一些popupWindow常见的问题，陆续更新中…</p></blockquote><ul><li><p><strong>isShowing失效问题</strong></p><p>  在实现popupWindow的过程中，点击按错出现popupWindow，然后再次点击按钮的时候，需要把popupWindow dismiss掉，实现的方法为判断是否显示isShowing，为false才让popupWindow显示</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (!popupWindow.isShowing()) &#123;</span><br><span class="line">    popupWindow.showAsDropDown(view);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul><pre><code>但是发现不管怎么样，**isShowing**一直返回为**false**，所以每次点击按钮popupWindow都会重新显示，断点查看后，发现每次点击出现popupWindow的按钮的时候都会去执行dismiss方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 这里一直返回为false</span><br><span class="line"> */</span><br><span class="line">public boolean isShowing() &#123;</span><br><span class="line">       return mIsShowing;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">public void dismiss() &#123;</span><br><span class="line">       if (!isShowing() || isTransitioningToDismiss()) &#123;</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line">       ...省略</span><br><span class="line">       </span><br><span class="line">       mIsShowing = false;//每次点击都会改变mIsShowing为false</span><br><span class="line">       </span><br><span class="line">       ...省略</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>然后又发现代码中有这么一句话<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">popupWindowLogin.setOutsideTouchable(true);</span><br></pre></td></tr></table></figure>这是为了能实现点击popupWindow外部能消失的效果，然后这里突然想到我们点击按钮的时候也属于点击popupWindow外部，所以这里先调用了**dismiss**方法改变了我们的**mIsShowing**的值知道了具体的原因后，我们发现这里主要是要让按钮的点击变成popupWindow的点击效果，所以我们只要让popupWindow在显示的时候把焦点先抢过来，然后我们点击按钮的时候，实际上就是点击popupWindow，想起来以前焦点问题的时候有这么一句话：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">popupWindowLogin.setFocusable(true);</span><br></pre></td></tr></table></figure>将焦点设置给popupWindow，然后我们再次点击按钮的时候由于焦点在popupWindow上，所以我们就可以正常的获取**mIsShowing**的值，在来执行我们的判断了。&gt; 加上代码了试了下效果，果然可行，Nice！</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;项目中有这么个需求，底部是5个Tab选项，中间那个是一个圆形的高位按钮选项，点击中间选项会从底部弹出个布局，并且这个布局的视觉效果是要在这个圆形选项的底部…这么说有点混乱，来张效果图看看&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Android" scheme="https:mubai.site/categories/Android/"/>
    
    
      <category term="Android" scheme="https:mubai.site/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>LeakCancary的使用和原理</title>
    <link href="https:mubai.site/2017-12-23-LeakCancary%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86/"/>
    <id>https:mubai.site/2017-12-23-LeakCancary的使用和原理/</id>
    <published>2017-12-22T16:00:00.000Z</published>
    <updated>2019-04-03T08:46:00.448Z</updated>
    
    <content type="html"><![CDATA[<h3 id="目录："><a href="#目录：" class="headerlink" title="目录："></a>目录：</h3><ul><li>为什么会有<em>LeakCancary</em></li><li>什么是<em>LeakCancary</em></li><li><em>LeakCancary</em>的使用</li><li><em>LeakCancary</em>的实现过程</li></ul><a id="more"></a><hr><h4 id="Why-LeakCancary"><a href="#Why-LeakCancary" class="headerlink" title="Why LeakCancary"></a>Why LeakCancary</h4><blockquote><p><strong>Square</strong>在开源项目<strong>LeakCancary</strong>的前言就提到了</p><p><strong>“A small leak will sink a great ship”</strong></p><p>我们可以翻译过来用一句名言来表示：<br><strong>“千里之堤溃于蚁穴”</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError</span><br><span class="line">        at android.graphics.Bitmap.nativeCreate(Bitmap.java:-2)</span><br><span class="line">        at android.graphics.Bitmap.createBitmap(Bitmap.java:689)</span><br><span class="line">        at com.squareup.ui.SignView.createSignatureBitmap(SignView.java:121)</span><br></pre></td></tr></table></figure><p><strong>OOM</strong> 项目中最让人头疼的一个异常，它不像一些其他异常很显示的给你指出并且容易解决，它的产生原因一般都是内存对象的不正确使用导致GC无法正常的回收对象，进而产生内存泄露，让系统的内存空间逐渐的不够，然后导致内存溢出。</p><p><strong>Square</strong>公司有篇文章说过他们在使用Bitmap进行签名页面进行绘制过程中，创建的bitmap对象经常性的产生OOM。<br>为了解决这个问题，<strong>Square</strong>做出了很多的对策，包括：</p><ul><li>使用<strong>Bitmap.Config.ALPHA_8</strong>节省内存</li><li>手动捕获<strong>OOM</strong>，调用<strong>GC</strong></li></ul><p>但是实际上效果并不好，后来他们发现是方向错了，当系统中分配的内存已经不够了，这时候OOM可以发生在任何的地方，特别是一些大对象的使用，比如Bitmap的创建。OOM只是表象，更深层次的问题可能是：<strong>内存泄露</strong></p><p>但是在原来的时候排查内存泄露是个全手工的过程,为了解决这个问题，<strong>LeakCancary</strong>出现了。</p><h4 id="What-LeakCancary"><a href="#What-LeakCancary" class="headerlink" title="What LeakCancary"></a>What LeakCancary</h4><p><strong><a href="https://github.com/square/leakcanary" target="_blank" rel="noopener">LeakCancary</a></strong>是<strong>Square</strong>公司推出的一款Java和Android内存泄露检查框架，如果检测到某个地方产生了内存泄露，LeakCancary会生成一个显示的通知，并且在Locat会有相应的log日志提醒，通过显示的通知和log日志我们可以对内存泄露进行准确的定位并去解决它。</p><h4 id="Use-LeakCancary"><a href="#Use-LeakCancary" class="headerlink" title="Use LeakCancary"></a>Use LeakCancary</h4><p><img src="http://p0sgkjh7x.bkt.clouddn.com/374F4D1C-CDAA-4FA1-BD09-1EFEE81C4B81.png" alt="LeakCancary显示通知图"></p><p><em>LeakCancary显示通知图镇楼</em></p><p>关于<strong>LeakCancary</strong>的开源和使用，Square最初的目的是为了能更好的对app进行内存泄露的检测，而且是为了能更简的入手，所以它的使用就不会很复杂，实际上用法也是很简单：</p><ul><li>在build.gradle添加引用：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">debugCompile &apos;com.squareup.leakcanary:leakcanary-android:1.5.4&apos;</span><br><span class="line">releaseCompile &apos;com.squareup.leakcanary:leakcanary-android-no-op:1.5.4&apos;</span><br></pre></td></tr></table></figure><blockquote><p>当前最新版本为1.5.4，可以根据git上的最新版本进行升级</p></blockquote><ul><li>在<strong>自定义继承Application</strong>中添加<strong>RefWatcher</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Ys7App extends Application &#123;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * RefWatcher对象</span><br><span class="line">   */</span><br><span class="line">    private RefWatcher refWatcher;</span><br><span class="line"></span><br><span class="line">    public static RefWatcher getRefWatcher(Context context) &#123;</span><br><span class="line">        Ys7App application = (Ys7App) context.getApplicationContext();</span><br><span class="line">        return application.refWatcher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate() &#123;</span><br><span class="line">        super.onCreate();</span><br><span class="line">        refWatcher = LeakCanary.install(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>不要忘记把自定义继承的<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">然后我们就可以去写**内存泄露**了(咳咳，说错了，是去发现内存泄露)</span><br><span class="line"></span><br><span class="line">说个很常见的内存泄露问题：*关于Context对象的使用*</span><br><span class="line"></span><br><span class="line">项目中很多地方都需要用到**Context**对象,有时候我们会直接使用**Activity**的**Context**对象，有时候会使用全局的**Context**对象。关于这个我们要说说关于在**Activity**中使用单例模式的问题，很多时候我们需要去维护一个全局的方法，很容易想到用单例模式，它也是设计模式中最简单易懂的一个，但是它如果使用不好就会产生**内存泄露**问题。</span><br><span class="line"></span><br><span class="line">* TextView的一个单例实现类</span><br></pre></td></tr></table></figure></p></blockquote><p>public class TextHelper {<br>    private static TextHelper mTextHelper;<br>    private Context mContext;<br>    private TextView mTextView;</p><pre><code>private TextHelper(Context context) {    this.mContext = context;}public static TextHelper getTextHelper(Context context) {    if (null == mTextHelper) {        mTextHelper = new TextHelper(context);    }    return mTextHelper;}/** * 设置TextView的大小和颜色 * * @param textView */@SuppressLint(&quot;NewApi&quot;)public void setText(TextView textView) {    this.mTextView = textView;    this.mTextView.setTextSize(20f);    this.mTextView.setTextColor(mContext.getColor(R.color.black));}</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 这里因为我们需要引用到资源文件中的color文件，所以需要个**Context**对象</span><br><span class="line"></span><br><span class="line">* 在Activity中使用：</span><br></pre></td></tr></table></figure><p> TextHelper.getTextHelper(SDKActivity.this).setText(nameText);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt; 这里我们使用了当前**Activity**的**Context**对象</span><br><span class="line"></span><br><span class="line">这里因为在**Activity**中使用了当前的**Context**对象，看上去没什么问题，但是如果我们退出当前Activity后(引入了**LeakCancary**的前提)，会在通知栏看到产生了个内存泄露通知</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;http://p0sgkjh7x.bkt.clouddn.com/D879CC01A4E508F2835F89036A03A0A6.jpg&quot; height=&quot;250&quot; width=&quot;150&quot;/&gt;</span><br><span class="line"></span><br><span class="line">然后我们通过查看**Leaks**中的列表问题</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;http://p0sgkjh7x.bkt.clouddn.com/F6A127ED4F1BAA1DFD5CE4F6B3C8012A.jpg&quot; height=&quot;250&quot; width=&quot;150&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&gt; Leaks:由于App运行中产生了内存泄露然后显示在手机上，在这边是一个内存泄露的问题列表，然后我们可以通过查看每一项进行问题的查看</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;http://p0sgkjh7x.bkt.clouddn.com/94088C38003714DBF648267A164FF6B4.jpg&quot; height=&quot;250 &quot; width=&quot;150&quot; /&gt;</span><br><span class="line"></span><br><span class="line">这边就是我们通过leaked5.8查看的具体问题，可以看到Leaks已经帮我们把内存泄露的地方指出来了，这是因为我们的**Activity**在退出后它的**Context**对象被单例模式中的方法持有 着，但是**Activity**已经不存在了，这里就产生了内存泄露。</span><br><span class="line">&gt; 实际上这是个很简单但是又很容易犯的问题</span><br><span class="line">&gt; </span><br><span class="line">&gt; 同时我们也可以通过点击Leaks边上的**+**来进行更多信息的查看</span><br><span class="line"></span><br><span class="line">所以我们这里的话要解决这个内存泄露就要传入一个全局的**Context**对象</span><br></pre></td></tr></table></figure><p>TextHelper.getTextHelper(Application.getInstance()).setText(nameText);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">或者是直接在单例模式中直接获取全局的**Context**对象</span><br></pre></td></tr></table></figure><p>public class TextHelper {<br>    private static TextHelper mTextHelper;<br>    private Context mContext;<br>    private TextView mTextView;</p><pre><code>private TextHelper(Context context) {    this.mContext = Application.getInstance();}public static TextHelper getTextHelper() {    if (null == mTextHelper) {        mTextHelper = new TextHelper();    }    return mTextHelper;}/** * 设置TextView的大小和颜色 * * @param textView */@SuppressLint(&quot;NewApi&quot;)public void setText(TextView textView) {    this.mTextView = textView;    this.mTextView.setTextSize(20f);    this.mTextView.setTextColor(mContext.getColor(R.color.black));}</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">这里就能避免由于**Context**对象的被持有导致的**内存泄露**。</span><br><span class="line"></span><br><span class="line">&gt; 实际上我们项目开发过程中会或多或少的产生**内存泄露**，这里只是举了一个简单的例子，我们只能通过去发现然后排查解决。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### Behind LeakCancary</span><br><span class="line">&gt; 在使用框架的同时也要关注下背后的实现过程和原理</span><br><span class="line">&gt; 我们通过对源码进行一步步的分解</span><br><span class="line"></span><br><span class="line">* 返回**RefWatcher**的过程</span><br></pre></td></tr></table></figure><p>private RefWatcher refWatcher;<br>refWatcher = LeakCanary.install(this);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; 通过**install()**方法</span><br></pre></td></tr></table></figure><p>public static RefWatcher install(Application application) {<br>        return ((AndroidRefWatcherBuilder)refWatcher(application).listenerServiceClass(DisplayLeakService.class).excludedRefs(AndroidExcludedRefs.createAppDefaults().build())).buildAndInstall();<br>    }</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; 继续对**buildAndInstall()**进行分析</span><br></pre></td></tr></table></figure><p>public RefWatcher buildAndInstall() {<br>        RefWatcher refWatcher = this.build();<br>        if(refWatcher != RefWatcher.DISABLED) {<br>            LeakCanary.enableDisplayLeakActivity(this.context);<br>            ActivityRefWatcher.install((Application)this.context, refWatcher);<br>        }</p><pre><code>    return refWatcher;}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; 在这里会返回一个**AndroidRefWatcher**，所以我们在对**Activity**进行内存泄露检查的时候，不需要专门添加代码，这里的**AndroidRefWatcher**会自动的帮我们进行检查</span><br></pre></td></tr></table></figure><p>public final class ActivityRefWatcher {<br>    private final ActivityLifecycleCallbacks lifecycleCallbacks = new ActivityLifecycleCallbacks() {<br>        public void onActivityCreated(Activity activity, Bundle savedInstanceState) {<br>        }</p><pre><code>    public void onActivityStarted(Activity activity) {    }    public void onActivityResumed(Activity activity) {    }    public void onActivityPaused(Activity activity) {    }    public void onActivityStopped(Activity activity) {    }    public void onActivitySaveInstanceState(Activity activity, Bundle outState) {    }    public void onActivityDestroyed(Activity activity) {      //调用ActivityRefWatcher的watch方法       ActivityRefWatcher.this.onActivityDestroyed(activity);    }};</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 在**ActivityRefWatcher**中我们发现会有关于**Activity**生命周期的回调监听并且在**onDestroy()**中会去添加**ActivityRefWatcher**的**watch**方法，但是这里也需要注意的是**registerActivityLifecycleCallbacks()**是在Api14以后才添加的方法，所以如果要在Api14以前检测就需要自己去重写onDestory并在里面添加RefWatcher.watch()方法</span><br><span class="line"></span><br><span class="line">如果是在**Fragment**中需要检查内存泄露情况的话需要我们自己实现**RefWatcher**的**watch**方法</span><br></pre></td></tr></table></figure><p>public class BaseFragment extends Fragment {</p><pre><code>@Overridepublic void onDestroy() {    super.onDestroy();    //返回一个RefWatcher对象    RefWatcher refWatcher = Ys7App.getRefWatcher(getActivity());    refWatcher.watch(this);}</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; 在这里有个疑问，为什么**Square**公司在设计**LeakCancary**的时候，考虑到了**Activity**，添加了对应的**ActivityRefWatcher**，但是对于碎片**Fragment**并没有去设计对应的**FragmentRefWatcher**方法,不知道是因为Fragment的生命周期过多还是其他的原因，也许我们可以自己根据**ActivityRefWatcher**的实现方法设计一套自己的**FragmentRefWatcher**，先留个想法...</span><br><span class="line"></span><br><span class="line">* RefWatcher是如何能够对内存泄露进行检测的</span><br><span class="line"></span><br><span class="line">通过观察RefWatcher的watch()方法</span><br></pre></td></tr></table></figure><p>public void watch(Object watchedReference, String referenceName) {<br>if(this != DISABLED) {<br>…<br>long watchStartNanoTime = System.nanoTime();<br>String key = UUID.randomUUID().toString();<br>this.retainedKeys.add(key);<br>//创建一个KeyedWeakReference弱引用对象<br>KeyedWeakReference reference = new KeyedWeakReference(watchedReference, key, referenceName, this.queue);<br>this.ensureGoneAsync(watchStartNanoTime, reference);<br>}<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里创建了一个**KeyedWeakReference**对象，这是个弱引用的对象</span><br></pre></td></tr></table></figure><p>private void ensureGoneAsync(final long watchStartNanoTime, final KeyedWeakReference reference) {<br>//执行操作，检查弱引用对象是否被清除<br>this.watchExecutor.execute(new Retryable() {<br>    public Result run() {<br>        return RefWatcher.this.ensureGone(reference, watchStartNanoTime);<br>    }<br>});<br>}</p><p>Result ensureGone(KeyedWeakReference reference, long watchStartNanoTime) {<br>…<br>if(this.debuggerControl.isDebuggerAttached()) {<br>    return Result.RETRY;<br>} else if(this.gone(reference)) {<br>    return Result.DONE;<br>} else {<br>    //手动调用GC<br>    this.gcTrigger.runGc();<br>    this.removeWeaklyReachableReferences();<br>    //如果弱引用对象还存在，则说明内存泄露了，生成hprof文件<br>     if(!this.gone(reference)) {<br>                File heapDumpFile = this.heapDumper.dumpHeap();<br>                …<br>                this.heapdumpListener.analyze(new HeapDump(heapDumpFile, reference.key, reference.name, this.excludedRefs, watchDurationMs, gcDurationMs, heapDumpDurationMs));<br>            }<br>     }<br>    return Result.DONE;<br>}<br>//retainedKeys中是否包含弱引用对象的key<br>private boolean gone(KeyedWeakReference reference) {<br>        return !this.retainedKeys.contains(reference.key);<br>    }<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在**WatchExector**的后台线程中执行检查弱引用对象是否被清除，如果没有清除，则调用一次GC，(这边能够检查弱引用对象还是根据**KeyedWeakReference**是以key-value形式存在的对象)</span><br><span class="line">如果弱引用对象没有被清除，则说明内存泄露了，系统就导出hprof文件,保存在app系统目录下</span><br></pre></td></tr></table></figure><p>final class KeyedWeakReference extends WeakReference<object> {<br>        //key-value形式存在<br>    public final String key;<br>    public final String name;</object></p><pre><code>KeyedWeakReference(Object referent, String key, String name, ReferenceQueue&lt;Object&gt; referenceQueue) {    super(Preconditions.checkNotNull(referent, &quot;referent&quot;),     ...</code></pre><p>}</p><p><code>`</code></p><hr><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>根据<strong>Square</strong>公司的数据说明他们在使用了<strong>LeakCancary</strong>后，减少了<strong>94%</strong>由OOM导致的cash。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;目录：&quot;&gt;&lt;a href=&quot;#目录：&quot; class=&quot;headerlink&quot; title=&quot;目录：&quot;&gt;&lt;/a&gt;目录：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;为什么会有&lt;em&gt;LeakCancary&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;什么是&lt;em&gt;LeakCancary&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;LeakCancary&lt;/em&gt;的使用&lt;/li&gt;
&lt;li&gt;&lt;em&gt;LeakCancary&lt;/em&gt;的实现过程&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Android" scheme="https:mubai.site/categories/Android/"/>
    
    
      <category term="Android" scheme="https:mubai.site/tags/Android/"/>
    
  </entry>
  
</feed>

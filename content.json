[{"title":"GiftForGirl","date":"2020-03-20T16:00:00.000Z","path":"2020-3-21-礼物专线/","text":"GiftForGirl专为男士为女士送礼用，包括香水、口红、包包、手链、镯子、耳环、项链、丝巾、帽子、护肤品、化妆品、指甲油、睡衣、内衣等等，仅供参考 顺序不分先后，随便排的，开心就好，目前只是大概写写抄抄，内容待补充，未完待续 香水 口红 包包 手链 镯子 耳环 项链 丝巾 帽子 护肤品 化妆品 指甲油 太阳眼镜 手表 钱包 内衣 睡衣 1 香水 Dior CHANEL 菲拉格慕 范思哲 伊丽莎白雅顿 巴宝莉 阿玛尼 祖马龙 兰蔻 圣罗兰 橘滋 2 口红 圣罗兰YSL 魅可MAC 迪奥Dior 纪梵希Givenchy 资生堂SHISEIDO 美宝莲 阿玛尼Armaani 兰蔻LANCOME 香奈儿CHANEL 欧莱雅 汤姆福特Tom Ford 美丽小屋 3 包包 路易威登LV 香奈儿CHANEL 爱马仕Hermes 普拉达Prada 古驰Gucci 圣大保罗Polo 登喜路Dunhill 沙驰SATCHI 鳄鱼Lacoste 梦特娇Montagut 4 手链 潘多拉 路易威登LV 迪奥Dior 卡地亚 蒂芙尼 佐卡伊 芬迪 梵克雅宝 宝格丽 施华洛世奇 5 镯子 施华洛世奇 潘多拉 蒂芙尼 卡地亚 爱马仕 6 耳环 宝格丽 伯爵 梵克雅宝 Qeelin麒麟 施华洛世奇 橘滋 菲尼莎 依慧达 御木本 波米雷特 Oxette 尚晨珠宝 吉盟 梵蒂诺 7 项链 蒂芙尼 施华洛世奇 海盗船 Julie 卡地亚 宝格丽 蒙奇奇 梵克雅宝 爱马仕 迪奥 周大福 周生生 谢瑞麟TSL 潮宏基CHJ 周大生 老凤祥 六福 8 丝巾 爱马仕 玛利亚·古琦 万事利 博柏利 Zara飒拉 路易威登LV 鹿王 以纯 维信 宝石蝶 龙翔纺织 丝界 丝绸故事 喜得宝 上海故事 妩WOO 绝代佳人 9 帽子 彩蓝EB 来可派 丽华LH 爱马仕 博柏利 快乐狐狸 拜丽德 GAP盖璞 红日 盛锡福 10 护肤品 法国lancome(兰蔻)-睫毛膏、兰蔻粉水 美国estee lauder(雅诗兰黛)-adbanced night repair(简称anr)系列、海蓝之谜 日本shiseido(资生堂) 法国dior(迪奥)-蓝金唇膏、5色眼影 法国chanel(香奈尔) 美国clinique(倩碧)-护肤三步曲 日本sk-ii-护肤精华露(又称神仙水) 法国biotherm(碧欧泉)-活泉水分露 hr(赫莲娜)-极至之美胶原系列、维他命c精华系列 美国伊丽沙白.雅顿-8小时润泽霜 雅斯兰黛的眼霜 sk2的各种护肤品、面膜 前男友面膜 luna洗脸仪 面部按摩仪 Dreamtimes 梦幻时光爽肤水 FANCL芳柯 Ipsa流金水 Ipsa自律循环乳液 CPB水磨精华 珂润浸润保湿水+保湿面霜 碧欧泉新活泉爽肤组合 倩碧(润肤露)黄油 资生堂红色蜜露 DHC橄榄滋养套装 高丝雪肌精乳液 兰蔻精华肌底液(小黑瓶) 丝塔芙洁面乳 AVENE雅漾舒护活泉水 11 化妆品 欧莱雅： 顶级品牌：HR(赫莲娜)是旗舰产品 二线产品：Lancome(兰蔻)，Biotherm(碧欧泉) 三线或三线以下产品：LOrealParis(欧莱雅)，kiehls(契尔氏)，美爵士、Garnier(卡尼尔)，羽西，小护士，INNEOV 彩妆品牌：CCBPARIS、shuuemura(植村秀)、Maybelline(美宝莲) 药妆品牌：Vichy(薇姿)，LAROCHE-POSAY(理肤泉)、SkinCeuticals(杜克) 香水品牌：GiorgioArmaniParfums(阿玛尼)，RalphLaurenParfums(拉尔夫*劳伦、POLO),caelParfums(卡夏尔)，VIKTOR&amp;ROLF 发用品牌：KERASTASE卡诗、MATRIX、MIZANI、REDKEN、SOFTSHEENCARSO 宝洁公司 顶级品牌：SK-II(Maxfactor)—就是蜜丝佛陀 二线品牌：Olay(玉兰油)、Illume(伊奈美)、Always、Zest 彩妆品牌：Covergirl(封面女郎) 亚洲区第一彩妆品牌：ANNASUI(安娜苏) 香水品牌：Hugoboss、Locaste、ANNASUI(安娜苏)、Escada(艾斯卡达)、Dunhill(登喜路)、Valention、Lanvin(朗万)、PaulSmith(保罗史密斯) 洗护品牌：飘柔、海飞丝、激爽(刚淘汰)、潘婷、润妍、沙宣、伊卡璐(Clairol)、舒肤佳、Wella(威娜) 雅诗兰黛 顶级品牌：LaMer(海蓝之谜)—–港台翻译为海洋之蓝 一线品牌：雅诗兰黛 二线品牌：Clinique(倩碧) 三线品牌：Stila、Origins(品木宣言)、Prescriptives、、Aveda(肯梦)和JoMalone 顶级限量彩妆品牌：TomFord(汤姆福特) 彩妆品牌：BobbiBrown(芭比波朗)、M.A.C(魅可). 香水品牌：TommyHilfiger(唐美希绯格)、DKNY(唐可娜儿)、Aramis(雅男士) 开架品牌：BeautyBank(目前仅在Kohls百货售卖，总共推出了Flirt、AmericanBeauty、GoodSkin及以Grassroots4个系 资生堂 顶级品牌：CledePeau(CDP)、IPSA(茵芙莎) 二线品牌：Ettusais(爱杜莎)、CARITA 凯伊黛、Decleor 思妍丽 底线品牌：ShiseidoFitit、Asplir(爱泊丽)、DeLuxe、ff 、SELFIT(珊妃)、Whitia(白媞雅)、FT Shiseido、泊美 彩妆品牌：Maquillage 中国专售：AUPRES欧珀莱、Za姬芮 香水品牌：JeanPaulGaultier、三宅一生 洗护品牌：ShiseidoProfessional LVMH 护肤品牌：Guerlain(娇兰)、ChristianDior(迪奥)、纪梵希(Givenchy)、DomPerignon(唐-裴利农)、Bliss、CLARINS(娇韵诗) 彩妆品牌：Makeupforever(浮生若梦)、BENEFIT、Cosmetics、AcquadiParma、Fresh、SEPHORA(丝芙兰) 香水品牌：KENZO(高田贤三)，fendi(芬迪)，Celine(赛琳)、LOEWE、DOLCE&amp;GABBANA(杜嘉班纳)、CHAUMET(舒维)、CalvinKlein(CK)、ChristianLacroi Chanel(香奈儿) LG 顶级护肤品牌：OHUI 二线护肤品牌：IsaKnox爱之浓思、海皙蓝、LaeVert(莲婷) 底线品牌：曼丽妃丝、缇兰 12 指甲油 芭比波朗 RGB NARS CND 莎莉汉森 巴黎欧莱雅 ESSIE 露华浓 China Glaze OPI 美宝莲Maybelline Missha谜尚 歌诗美COSMAY 香奈儿 Za姬芮 丝芙兰 安娜苏AnnaSui Innisfree悦丝风吟 TheFaceShop菲斯小铺 露华浓Revlon 迪奥Dior 13 太阳眼镜 雷德蒙女士太阳镜 爱靓眼镜女士太阳镜 阿玛尼女士太阳镜 暴龙女士太阳镜 海伦凯勒女士太阳镜 宝丽来女士太阳镜 kalikali女士太阳镜 GUCCI女士太阳镜 香奈儿女士太阳镜 雷朋女士太阳镜 古驰女士太阳镜 帕莎女士太阳镜 阿玛尼女士太阳镜 卡地亚女士太阳镜 帕莎女士太阳镜 欣菲特女士太阳镜 海豚女士太阳镜 派丽蒙女士太阳镜 万宝龙女士太阳镜 保圣女士太阳镜 宝姿女士太阳镜 14 手表 dw手表 尼龙表带简约休闲女士手表、女士简约金属钢带手表、玫瑰金女士手表 雷达 浪琴 PRIMALUNA心月 系列L8.111.4.87.6腕表、圆舞曲系列-玫瑰金镶钻腕表 天梭 T028.210.11.057.01 名士 灵霓系列MOA10036腕表 美度 DONNA Caliber 80超长动力储存女士腕表 艾米龙 净雅系列06.2188.L.6.6.28.6腕表 万宝龙 明星经典系列U0110304腕表 艾美 典雅系列LC6016-SS002-130腕表 欧米茄 星座系列 卡地亚 蓝气球系列、桑托斯系列、伦敦SOLO系列、「坦克」女款、山度士 劳力士 日志 香奈儿BOY FRIEND 系列 爱彼皇家 橡树满天星 法穆兰 15 钱包 路易威登LV 古琦欧·古琦Gucci 香奈儿CHANEL 普拉达Prada 圣大保罗Polo 迪奥Dior 爱马仕Hermes 寇兹/寇驰COACH 登喜路Dunhill 芬迪Fendi 16 内衣 古今 婷美 法曼儿 华歌尔 仙黛尔 LA PERLA 都市丽人 欧迪芬 嘉莉诗 歌瑞尔 梦芭莎 猫人 安莉芳 维多利亚的秘密 雅芳 爱慕 黛安芬 曼妮芬 17 睡衣 芬腾 安之伴 美标Meibiao 爱慕Aimer 秋鹿 歌瑞尔 康妮雅 维多利亚的秘密 美梦 沃莱卡 安莉芳 雪俐","tags":[{"name":"礼物专线","slug":"礼物专线","permalink":"https:mubai.site/tags/礼物专线/"}]},{"title":"多线程交替打印数组元素","date":"2019-12-24T16:00:00.000Z","path":"2019-12-25-多线程交替打印数组/","text":"多线程交替打印数组元素 通过LockSupport:1234567891011121314151617181920212223242526272829private Thread a, b;private void threadPrintArray() &#123; int[] arr = new int[]&#123;1, 2, 3, 4, 5, 6&#125;; //通过Lock.support，可以阻塞一个线程，唤起一个线程 a = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i : arr) &#123; System.out.println(&quot;a：&quot; + i); LockSupport.unpark(b);//先唤起b线程 LockSupport.park();//阻塞自己 &#125; &#125; &#125;); b = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i : arr) &#123; LockSupport.park();//先阻塞自己，防止先打印b线程的值 System.out.println(&quot;b：&quot; + i); LockSupport.unpark(a);//唤起a线程 &#125; &#125; &#125;); a.start(); b.start();&#125; 通过Synchronized+wait/notify12345678910111213141516171819202122232425262728293031323334353637383940private Thread a, b;private void threadPrintArray() &#123;int[] arr = new int[]&#123;1, 2, 3, 4, 5, 6&#125;;//通过sync加锁 ，然后通过wait和notify来控制阻塞和唤起a = new Thread(new Runnable() &#123; @Override public void run() &#123; synchronized (arr) &#123; for (int i : arr) &#123; try &#123; System.out.println(&quot;a：&quot; + i); arr.notify();//先去唤起其他线程 arr.wait();//再去对自己阻塞 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125;);b = new Thread(new Runnable() &#123; @Override public void run() &#123; synchronized (arr) &#123; for (int i : arr) &#123; try &#123; System.out.println(&quot;b：&quot; + i); arr.notify();//先去唤起其他线程 arr.wait();//再去对自己阻塞 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125;);a.start();b.start();&#125; 通过ReentrantLock 单Condition控制(类似Sync+wait/notify) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748private ReentrantLock lock = new ReentrantLock();private Condition condition = lock.newCondition();private Thread a, b;private void threadPrintArray() &#123;int[] arr = new int[]&#123;1, 2, 3, 4, 5, 6&#125;;a = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; lock.lock(); for (int i : arr) &#123; System.out.println(&quot;a：&quot; + i); condition.singal();//唤起其他线程，即b线程 condition.await();//阻塞a线程 &#125; &#125; catch (Exception e) &#123; &#125; finally &#123; lock.unlock(); &#125; &#125;&#125;);b = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; lock.lock(); for (int i : arr) &#123; System.out.println(&quot;b：&quot; + i); condition.signal();//唤起其他线程，即a线程 condition.await();//阻塞b线程 &#125; &#125; catch (Exception e) &#123; &#125; finally &#123; lock.unlock(); &#125; &#125;&#125;);a.start();b.start();&#125; 多Condition来控制 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950private ReentrantLock lock = new ReentrantLock();private Condition aCondition = lock.newCondition();private Condition bCondition = lock.newCondition();private Thread a, b;private void threadPrintArray() &#123;int[] arr = new int[]&#123;1, 2, 3, 4, 5, 6&#125;;a = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; lock.lock(); for (int i : arr) &#123; System.out.println(&quot;a：&quot; + i); bCondition.signal();//唤起b线程 aCondition.await();//阻塞a线程 &#125; &#125; catch (Exception e) &#123; &#125; finally &#123; lock.unlock(); &#125; &#125;&#125;);b = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; lock.lock(); for (int i : arr) &#123; System.out.println(&quot;b：&quot; + i); aCondition.signal();//唤起a线程 bCondition.await();//阻塞b线程 &#125; &#125; catch (Exception e) &#123; &#125; finally &#123; lock.unlock(); &#125; &#125;&#125;);a.start();b.start();&#125; 通过原子类+自旋实现1234567891011121314151617181920212223242526272829303132AtomicInteger threadNo = new AtomicInteger(1);private Thread a, b;private void threadPrintArray() &#123;int[] arr = new int[]&#123;1, 2, 3, 4, 5, 6&#125;;a = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i : arr) &#123; while(threadNo.get() != 1)&#123;&#125;//如果等于1，即不是a线程的 自旋 System.out.println(&quot;a：&quot; + i); threadNo.get.set(2); &#125; &#125;&#125;);b = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i : arr) &#123; while(threadNo.get() != 2)&#123;&#125;//如果等于2，即不是b线程的 自旋 System.out.println(&quot;b：&quot; + i); threadNo.get.set(1); &#125; &#125;&#125;);a.start();b.start();&#125;","tags":[{"name":"Android","slug":"Android","permalink":"https:mubai.site/tags/Android/"}]},{"title":"沉浸式状态栏","date":"2019-12-19T16:00:00.000Z","path":"2019-12-20-沉浸式状态栏/","text":"沉浸式状态栏怎么搞 实现沉浸式状态栏主要跟以下四个Api相关: View#setSystemUiVisibility() Window#addFlags() View#setFitsSystemWindows Window#setStatusBarColor() View#setSystemUiVisibility()及其各种Flags首先setSystemUiVisibility()这个方法就是设置状态栏或者导航栏的各种属性的。 View.SYSTEM_UI_FLAG_FULLSCREEN: 视图全屏并隐藏状态栏，当用户交互时（如下滑状态栏）会恢复隐藏的状态栏（例子：电子书阅读）缺点：进入Activity会产生一个从非全屏到全屏的闪动效果 View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY： 粘性沉浸模式，需要和SYSTEM_UI_FLAG_FULLSCREEN或者SYSTEM_UI_FLAG_HIDE_NAVIGATION联用，当使用View.setSystemUiVisibility(View.SYSTEM_UI_FLAG_FULLSCREEN|View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY)联用时视图全屏，当用户产生交互时（如下滑状态栏）不会恢复状态栏，只会以半透明的方式覆盖在视图上面并在一定时间内自动消失 View.SYSTEM_UI_FLAG_IMMERSIVE： 沉浸模式，只能和SYSTEM_UI_FLAG_FULLSCREEN联用，效果和View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY一样，目前已被后者替代 View.SYSTEM_UI_FLAG_LOW_PROFILE: 低配模式，会隐藏一些不重要的状态栏和导航栏的图标 View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN： 视图全屏且不会产生闪动，状态栏会覆盖在视图上面 View.SYSTEM_UI_FLAG_LAYOUT_STABLE： 使视图稳定，当使用fitSystemWindows（）（下面会单独介绍这个方法）需要视图稳定，一般和View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN联用 View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR:Android6.0系统以上增加的属性，设置了这个属性，状态栏会以与状态栏背景颜色兼容的模式绘制。什么意思呢？就是说如果当前的状态栏颜色是浅色，那么就有可能造成状态栏上的图标看不清了，但是如果你设置这个属性以后，状态栏的图标就会以深色绘制，这样就没有什么UI上的问题了。 Window.addFlags()及其各种FlagsWindowManager.LayoutParams相关属性： FLAG_TRANSLUCENT_STATUS:Android4.4系统增加的属性，它会使状态栏透明透明并且自动执行View.SYSTEM_UI_FLAG_LAYOUT_STABLE和View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN FLAG_FULLSCREEN:视图全屏并隐藏状态栏，效果相当于View.SYSTEM_UI_FLAG_FULLSCREEN+View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY，并且视图稳定（不会因为系统控件的变化（如输入法），而重新布局） FLAG_FORCE_NOT_FULLSCREEN：重写了FLAG_FULLSCREEN并强制显示状态栏（没有啥卵用） FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS：Android5.0系统以上支持，如果设置了该属性，系统栏（状态栏和导航栏）将以透明背景绘制，并且该窗口中的相应区域将填充setStatusBar（）和setNavigationBarColor（）中设置的颜色 View#setFitsSystemWindows此方法只有当设置SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN或者SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION才有有效，当窗口发生变化时，View需要调整自身内容以适应窗口的变化，你可以理解为当和SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN一起联用的时候，是给View加了个bottomTop属性，宽度填充视图，高度就是状态栏的高度；当和SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION一起联用的时候，是给View加了个bottomBottom属性，宽度填充视图，高度就是导航栏的高度，建议给布局的顶层ViewGroup使用 Window#setStatusBarColor()Android5.0系统及以上开始支持，设置状态栏的颜色，为了使这个状态有效必须要设置FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS而且不能设置FLAG_TRANSLUCENT_STATUS 实现沉浸式状态栏的具体套路实现沉浸式状态栏分为三个阶段， Android4.4~Android5.0以下; Android5.0~Android6.0以下； Android6.0以上； Android4.4~Android5.0阶段以下：Android真正可以实现沉浸式状态栏是从4.4开始的，因为4.4系统加入了一个重要的属性Window.LayoutParams.FLAG_TRANSLUCENT_STATUS，这个属性能干嘛，前面已经说过了，下面直接开搞。首先，沉浸式状态栏一般有两种情况，一种是背景是一张图片，一种是颜色跟标题栏一致的 背景是一张图片的情况：非常非常好实现，一行代码直接搞定 1activity.getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS); FLAG_TRANSLUCENT_STATUS这个属性会让状态栏以白色绘制，同时还会执行SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN和SYSTEM_UI_FLAG_LAYOUT_STABLE这样就会让状态栏浮在图片的上面，这样就形成了沉浸式的效果 颜色跟标题栏一致的情况 这种情况在4.4~5.0以下这个阶段实现起来就稍微复杂了一点，因为这个阶段还没有执行setStatusBarColor（）这个方法，因此这个阶段实现的套路是，先制造一个假的View背景颜色跟标题栏的颜色一致，高度跟状态栏的高度一致，添加到顶层DecorView上面，然后让Android的最顶层的内容布局调用setFitsSystemWindows空出来状态栏的高度，最后调用FLAG_TRANSLUCENT_STATUS这个属性即可，让状态栏透明并浮在假View上 123456789View statusView = new View(activity);ViewGroup.LayoutParams statusViewLayoutParams = new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, getStatusBarHeight(activity));ViewGroup decorView = (ViewGroup) activity.getWindow().getDecorView();decorView.addView(statusView, statusViewLayoutParams);ViewGroup rootView = decorView.findViewById(Window.ID_ANDROID_CONTENT);if (rootView != null) &#123; rootView.setFitsSystemWindows(true);&#125;activity.getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS); 注意：从两张效果图的图片可以看出，沉浸式状态在这一阶段的表现还不是太好，上面会有一层黑色的半透明浮层，但是也基本可以实现了沉浸式。 Android5.0~Android6.0以下这一阶段Android系统为我们增加了一个非常重要的API，Window#setStatusBarColor()，关于它的用法前面已经有所介绍，这里不再赘述，以及一个配合这个api使用的属性FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS，直接开搞 背景是一张图的情况 1234activity.getWindow().addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);activity.getWindow().setStatusBarColor(Color.TRANSPARENT);activity.getWindow().clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);activity.getWindow().getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN); 这里简单解释一下，我们把状态栏的颜色设置成透明，同时让状态栏浮在视图上面且保持稳定，这样图片就会顶到视图的顶部，因此就实现了沉浸式的效果，代码很简单，万一看不懂就翻翻上面对各种api的介绍 颜色状态栏 直接给状态栏设置对应的颜色 123activity.getWindow().addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS); activity.getWindow().clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);activity.getWindow().setStatusBarColor(color); 给状态栏设置透明色并让状态栏浮在视图顶层，配合setFitsSystemWindows（） 1234activity.getWindow().getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_STABLE);activity.getWindow().addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS); activity.getWindow().clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);activity.getWindow().setStatusBarColor(Color.TRANSPARENT);toolBar.setFitsSystemWindows(true);//这里根据自己的布局情况 Android6.0及以上之所以又分了这一个阶段，是因为我们在5.0~6.0阶段发现了一个小问题，就是当我们要给状态栏设置的颜色是白色或者浅色的时候，因为默认的状态上图标的颜色是白色就会造成看不清的现象 为了避免这种情况，Android系统在6.0的时候增加了一个属性SYSTEM_UI_FLAG_LIGHT_STATUS_BAR，此前已经介绍过这个属性，这里不再赘述，使用了它以后，状态栏上的图标文字就会默认使用黑色绘制。 12345activity.getWindow().addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);activity.getWindow().clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);activity.getWindow().setStatusBarColor(color);if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123; activity.getWindow().getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR);&#125; ps:小米和魅族系统在Android5.0修改自家系统的源码，因此他们在5.0的时候就提供这个API，也就是说小米和魅族Android5.0系统的手机就支持了浅色主题模式。 沿着别人走过的路，跟上去发现不一样的风景参考链接： 转载自：https://www.jianshu.com/p/f84f7e07e0d6","tags":[{"name":"Android","slug":"Android","permalink":"https:mubai.site/tags/Android/"}]},{"title":"Rxjava2 太多方法了，记不住呀","date":"2019-12-01T16:00:00.000Z","path":"2019-12-2-Rxjava2 太多方法了，记不住呀/","text":"Rxjava2 太多方法了，记不住呀 总结下 一、什么是Rxjava以及Obserable的多种创建方式123456789101112131415161718192021222324251.create():创建一个完成的被观察者(Observable)---&gt;:RxJava中创建被观察者最基本的操作符2.empty():快速创建后只发送complete事件，直接通知完成3.error():快速创建后只发送error事件，直接通知异常4.never():快速创建后不发送任何事件5.just():快速创建后直接发送传入的事件---&gt;参数最多只能10个，即发送的事件最多10个6.fromArray():快速创建后直接发送传入的数组数据---&gt;参数为数组，子类型为任意类型，可10个以上7.fromIterable():快速创建后直接发送传入的集合List数据---&gt;参数为集合List，子类型为任意类型，可10个以上 8.defer():直到观察者Observer订阅被观察者Observable时，才动态创建被观察者&amp;发送事件---&gt;通过Observable工厂方法创建被观察者，每次订阅后都会得到一个最新创建的被观察者Observable，确保里面的数据是最新的 9.timer():快速创建被观察者，指定延时时间，发送一个数值为0的事件---&gt;延时指定时间后发送一个参数为0的事件，相当于onNext（0）10.interval():快速创建被观察者，每隔指定时间发送事件---&gt;发送事件序列，从0开始，无限递增111.intervalRange():快速创建被观察者，每隔指定时间发送事件，可指定发送事件数---&gt;发送无限递增1的事件序列，可指定起始值大小和事件次数，可延时，类似interval()12.range():快速创建被观察者，连续发送一个时间序列，可指定范围---&gt;发送无限递增1的事件序列，可指定起始值大小和事件次数，不可延时，类似intervalRange()13.rangeLong():同上，区别在于数据参数为类型Long 二、操作符(一).变换操作符12345671.map():对Observable发送的每一个事件进行转换 2.flatMap():对Observable发送的整个个事件进行转换（无序）3.concatMap():对Observable发送的整个个事件进行转换（有序）4.buffer():从Observable的事件中获取事件放到缓存区再发送事件 (二).组合操作符1234567891.concat()与concatArray():组合多个被观察者发送数据，合并后按照顺序执行---&gt;区别：组合被观察者数量：concat()&lt;=4,concatArray()无限制2.Merge()与MergeArray():组合多个被观察者发送数据，合并后按照时间顺序执行---&gt;区别：组合被观察者数量：Merge()&lt;=4,MergeArray()无限制3.concatDelayError():将错误事件延迟到所以事件执行完后才执行错误事件 4.megreDelayError():类似上面concatDelayError5.startWith()与startWithArray():在一个被观察者发送数据前，追加发送一些数据---&gt;调用顺序：先追加的后调用，后追加的先调用 (三).合并操作符1234567891.zip():合并多个被观察者发送的事件，生成一个新的事件序列。---&gt;严格按照事件序列进行合并,最后Observable的数据=多个Observable中数量最少的2.combineLatest():将两个Observable产生的结果进行合并，合并新的Observable发送给订阅者---&gt;当其中一个Observable发送数据，都与另一个Observable最后发送的数据结合，类似zip()，不同的是按照时间点合并3.combineLatestDelayError():将错误事件延迟到所以事件执行完后才执行错误事件4.reduce():把观察者需要发送的事件聚合成一个事件并且发送。---&gt;前两个被观察者聚合成新的被观察者，再与下一数据聚合，一次类推5.collect():将被观察者发送的数据放到一个容器中处理 (四).统计发送事件的数量1count()方法是统计Observable(被观察者)发送的事件的数量 (五).延迟操作符1234567891011121314151.doOnNext():执行onNext()事件前调用2.doOnEach():当Observable每发送一次数据就调用一次3.doAfterNext():执行onNext()事件后调用4.doOnError():发送错误事件时调用5.doAfterTerminate():无论是正常发送事件完毕/异常终止都回调6.doOnSubscribe():观察者订阅时回调7.doOnComplete():正常发送事件完毕后8.doFinally() :最后执行 (六).错误处理操作符123456789101112131.onErrorReturn():Observable发生错误或异常时发送一个相同类型的特殊事件，并且终止事件发送。 2.onErrorResumeNext():Observable发生错误或异常时产生新的Observable发送一个特殊事件，并且终止事件发送。3.onExceptionResumeNext():同上，不同点：这里只能拦截异常不能拦截错误4.retry():发生异常或错误时重试源Observable的请求5.retryWhen() :同上，不同点：将错误异常传递给新的Observable通知源Observable6.repeat():重复源Observable发送事件（抛出异常错误不能重复发送）7.repeatWhen():在回调方法中创建新的Observable，通过新的observable是否重复订阅和发送事件。 (七).过滤操作符12345678910111213141516171.filter():按照指定的条件(自定义)对被观察者发出的结果进行过滤，再提交给被观察者---&gt;在回调方法中实现规则过滤 2.ofType():根据指定的数据类型对被观察者发出的结果进行过滤，再提交给被观察者---&gt;参数传入对结果过滤的类型3.elementAt() :将指定索引被观察者发出的事件提交给观察者，索引为0---&gt;参数传入索引4.distinct():去重，去掉被观察者产生的重复的结果，将不重复的提交给观察者5.debounce():只接收到倒计时时间外的被观察者发出的事件，每个事件发出时会重置倒计时时间。---&gt;参数传入每个事件的倒计时时间6.first():将被观察者产生的第一个结果提交给被观察者处理7.last():将被观察者产生的最后一个结果提交给观察者处理8.skip():跳过前n个被观察者产生的结果，将后面的提交给观察者处理---&gt;参数传入指定跳过的数量9.take():将前n个被观察者产生的结果提交给观察者处理，其他的不做处理---&gt;参数传入指定执行的数量 (八).其他他操作符1234567891.groupBy():对于源Observable(被观察者)产生的结果进行分组，形成一个类型为GroupedObservable的结果集，存在一个方法为getKey()，通过该方法获取结果集的key值---&gt;如果事件结果没有处理，那么take()处理一下，否则会内存泄漏2.cast():用于类型转换，将源Observable的源类型转为指定的.class---&gt;如果类型不正确则会抛出转换异常。3.scan() 遍历源Observable产生的结果，依次每个结果按照指定的规则进行计算，计算后的结果作为下一项迭代的参数，每一次迭代项都会把计算结果输出给订阅者。---&gt;每次计算的结果用于下次计算4.join():把两个Observable产生的结果进行合并，合并结果组成一个新的Observable，可以控制每个Observable产生结果的生命周期，在每个结果的生命周期内，可以与另一个Observable产生的结果按照一定的规则进行合并---&gt;合并结果产生新的Observable5.groupJoin() :类似上述，第三个参数不一致，返回新的Observable处理 背压 背压指的是上游的被观察者发送的速度太快，而观察者处理的速度较慢，处理不过来，就会出现异常Backpressure Hot Obserable:创建后Obserable就立马发送事件，都不支持背压 Cold Obserable:订阅后才开始发送事件，部分支持，部分不支持 解决方案就是通过下游告诉上游的被观察者降低发送速度 在RxJava1.0中，由于Obserable部分支持部分不支持，在支持背压的Obserable中 我们可以通过响应式拉取，即让观察者去通知被观察者发送事件，request，不支持背压的可以通过过滤事件结果，合并事件结果等方式来解决。 在RxJava2.0中，有了新的Flowable来解决背压，通过Flowable创建的都是非阻塞背压，注意的是这边的观察者是实现Subscriber。(Flowable的队列长度是128) 沿着别人走过的路，跟上去发现不一样的风景参考链接： 转载：https://blog.csdn.net/m0_37796683/article/details/102525484","tags":[{"name":"Android","slug":"Android","permalink":"https:mubai.site/tags/Android/"}]},{"title":"Activity 布局加载分析","date":"2019-11-01T16:00:00.000Z","path":"2019-11-2-Activity 布局加载分析/","text":"关于Activity需要知道的更多内容 前言关于Activity的创建以及执行回调onCreate方法我们已经知道了（看这里：https://www.jianshu.com/p/3de730c145be），然后我们今天想知道我们在onCreate中调用setContentView方法的时候，xml是如何加载的，所以今天就跟着源码来看看。ps：源码版本为 android-26 一般来说我们写一个XxxActivity都会去继承Activity、FragmentActivity、AppCompatActivity这3个的其中一个，我们今天就分别对这几个父类Activity去分析 1、Activity的xml加载过程 2、FragmentActivity的xml加载过程 3、AppCompatActivity的xml加载过程 一、Activity的xml加载过程进入我们setContentView方法12345## Activitypublic void setContentView(@LayoutRes int layoutResID) &#123; getWindow().setContentView(layoutResID);//1、调用phoneWindow的setContentView方法 initWindowDecorActionBar();&#125; 这边注释的地方getWindow方法获取的一个window对象，它的实现类是PhoneWindow，它在Activity的attach中进行创建出来。 12345678## Activityfinal void attach(Context context, ..., Window window, ActivityConfigCallback activityConfigCallback) &#123; ... mWindow = new PhoneWindow(this, window, activityConfigCallback);//这边进行window对象的初始化 ... mWindow.setColorMode(info.colorMode); &#125; 我们跟进PhoneWindow，看看它里面的setContentView方法123456789101112131415161718##PhoneWindow@Overridepublic void setContentView(int layoutResID) &#123; if (mContentParent == null) &#123; installDecor();//1、加载DecorView &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; mContentParent.removeAllViews(); &#125; if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID, getContext()); transitionTo(newScene); &#125; else &#123; mLayoutInflater.inflate(layoutResID, mContentParent);//2、布局加载器 &#125; ...&#125; 注释1是加载DecorView，注释2通过布局加载器将xml解析成view树，并且将view树添加到mContentParent中 1、加载DecorView123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126### PhoneWindow/** * 加载DecorView */private void installDecor() &#123; mForceDecorInstall = false; if (mDecor == null) &#123; mDecor = generateDecor(-1);//1、创建DecorView ... &#125; else &#123; mDecor.setWindow(this);//2、DecorView绑定到Window &#125; if (mContentParent == null) &#123; mContentParent = generateLayout(mDecor);//3、根据DecorView生成Layout，得到一个mContentParent ... &#125; &#125;/* * 1、创建DecorView */protected DecorView generateDecor(int featureId) &#123; ... //这边去创建DecorView return new DecorView(context, featureId, this, getAttributes());&#125;/* *2、调用DecorView的setWindow，传入PhoneWindow对象 */ void setWindow(PhoneWindow phoneWindow) &#123; mWindow = phoneWindow; ... &#125;/* *3、根据DecorView生成Layout */protected ViewGroup generateLayout(DecorView decor) &#123; // Apply data from current theme. //1、获取当前的主题，然后设置相关数据到window上 TypedArray a = getWindowStyle(); ... mIsFloating = a.getBoolean(R.styleable.Window_windowIsFloating, false);//2、当前Window是否浮动在上面，默认为false int flagsToUpdate = (FLAG_LAYOUT_IN_SCREEN|FLAG_LAYOUT_INSET_DECOR) &amp; (~getForcedWindowFlags()); if (mIsFloating) &#123; setLayout(WRAP_CONTENT, WRAP_CONTENT);//3、传入window的宽、高 setFlags(0, flagsToUpdate); &#125; else &#123; setFlags(FLAG_LAYOUT_IN_SCREEN|FLAG_LAYOUT_INSET_DECOR, flagsToUpdate); &#125; if (a.getBoolean(R.styleable.Window_windowNoTitle, false)) &#123;//4、window是否有title requestFeature(FEATURE_NO_TITLE);//5、请求指定Window的风格，它必须在setContentView之前 &#125; else if (a.getBoolean(R.styleable.Window_windowActionBar, false)) &#123; // Don&apos;t allow an action bar if there is no title. requestFeature(FEATURE_ACTION_BAR); &#125; ... //6、这边会很多的设置窗口属性的判断和方法，具体可以大家可以去看源码 ... // Inflate the window decor. //7、根据上面设置的窗口的属性 ，设置相应的 layoutResource int layoutResource; int features = getLocalFeatures(); if ((features &amp; (1 &lt;&lt; FEATURE_SWIPE_TO_DISMISS)) != 0) &#123; layoutResource = R.layout.screen_swipe_dismiss; setCloseOnSwipeEnabled(true); &#125; else if ((features &amp; ((1 &lt;&lt; FEATURE_LEFT_ICON) | (1 &lt;&lt; FEATURE_RIGHT_ICON))) != 0) &#123; if (mIsFloating) &#123; TypedValue res = new TypedValue(); getContext().getTheme().resolveAttribute( R.attr.dialogTitleIconsDecorLayout, res, true); layoutResource = res.resourceId; &#125; else &#123; layoutResource = R.layout.screen_title_icons; &#125; removeFeature(FEATURE_ACTION_BAR); &#125; else if ((features &amp; ((1 &lt;&lt; FEATURE_PROGRESS) | (1 &lt;&lt; FEATURE_INDETERMINATE_PROGRESS))) != 0 &amp;&amp; (features &amp; (1 &lt;&lt; FEATURE_ACTION_BAR)) == 0) &#123; layoutResource = R.layout.screen_progress; &#125; else if ((features &amp; (1 &lt;&lt; FEATURE_CUSTOM_TITLE)) != 0) &#123; if (mIsFloating) &#123; TypedValue res = new TypedValue(); getContext().getTheme().resolveAttribute( R.attr.dialogCustomTitleDecorLayout, res, true); layoutResource = res.resourceId; &#125; else &#123; layoutResource = R.layout.screen_custom_title; &#125; removeFeature(FEATURE_ACTION_BAR); &#125; else if ((features &amp; (1 &lt;&lt; FEATURE_NO_TITLE)) == 0) &#123; if (mIsFloating) &#123; TypedValue res = new TypedValue(); getContext().getTheme().resolveAttribute( R.attr.dialogTitleDecorLayout, res, true); layoutResource = res.resourceId; &#125; else if ((features &amp; (1 &lt;&lt; FEATURE_ACTION_BAR)) != 0) &#123; layoutResource = a.getResourceId( R.styleable.Window_windowActionBarFullscreenDecorLayout, R.layout.screen_action_bar); &#125; else &#123; layoutResource = R.layout.screen_title; &#125; &#125; else if ((features &amp; (1 &lt;&lt; FEATURE_ACTION_MODE_OVERLAY)) != 0) &#123; layoutResource = R.layout.screen_simple_overlay_action_mode; &#125; else &#123; // Embedded, so no decoration is needed. layoutResource = R.layout.screen_simple; &#125; mDecor.startChanging();//8、开始DecorView的变化 mDecor.onResourcesLoaded(mLayoutInflater, layoutResource);//9、根据布局文件xml加载得到View树 ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);//10、根据content id返回一个contentParent，是一个viewGroup mDecor.finishChanging(); //11、结束DecorView的变化 return contentParent; //12、返回一个contentParent&#125; 在上面这段源码中，我们主要是做了几件事： 1、注释1这里的样式通常是用来描述窗口的，通常view的样式是通过layout来描述的，而窗口的样式是通过Androidmanifest.xml来配置的，所以我们这里通过调用getWindowStyle方法，然后得到一个TypedArray对象，这个类我们比较熟悉，在我们自定义View的时候，如果需要自定义style，我们都会在初始化的时候得到一个TypedArray对象，然后去设置相关的样式。 2、注释2返回一个boolean值，表示我们的window是否悬浮在上面，然后根据这个值去设置相关的window宽高和其他的标签，注释4和注释6的地方判断window是否有title或者是否没有ActionBar，然后通过注释5的地方调用requestFeature去设置相关属性，所以我们这边会是否能联想到我们去如果在Activity的onCreat方法里去设置全屏的时候，需要在setConentView之前去设置，因为在setContentView之后的话，installDecor方法就已经执行完毕了，那我们设置的window属性就没有作用了。 3、注释7的地方根据上面设置的窗口的属性，来设置相关的layoutResource，我们可以去源码中查找相应的layout，具体位置在：frameworks/base/core/res/res/layout下 1234567891011121314151617181920##screen_simple&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:fitsSystemWindows=&quot;true&quot; android:orientation=&quot;vertical&quot;&gt; &lt;ViewStub android:id=&quot;@+id/action_mode_bar_stub&quot; android:inflatedId=&quot;@+id/action_mode_bar&quot; android:layout=&quot;@layout/action_mode_bar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:theme=&quot;?attr/actionBarTheme&quot; /&gt; &lt;FrameLayout android:id=&quot;@android:id/content&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:foregroundInsidePadding=&quot;false&quot; android:foregroundGravity=&quot;fill_horizontal|top&quot; android:foreground=&quot;?android:attr/windowContentOverlay&quot; /&gt;&lt;/LinearLayout&gt; 12345678910111213141516171819##screen_simple_overlay_action_mode&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:fitsSystemWindows=&quot;true&quot;&gt; &lt;FrameLayout android:id=&quot;@android:id/content&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:foregroundInsidePadding=&quot;false&quot; android:foregroundGravity=&quot;fill_horizontal|top&quot; android:foreground=&quot;?android:attr/windowContentOverlay&quot; /&gt; &lt;ViewStub android:id=&quot;@+id/action_mode_bar_stub&quot; android:inflatedId=&quot;@+id/action_mode_bar&quot; android:layout=&quot;@layout/action_mode_bar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:theme=&quot;?attr/actionBarTheme&quot; /&gt;&lt;/FrameLayout&gt; 我们能够发现这几个layout里面都包含了一个id为content的FrameLayout，它是用来添加我们自己的布局。 4、注释9根据我们上面得到的布局文件加载onResourcesLoaded得到view树1234567891011121314151617181920212223242526272829303132333435363738394041424344##DecorViewvoid onResourcesLoaded(LayoutInflater inflater, int layoutResource) &#123; ... //创建一个DecorCaptionView，它是Decor的标题View, 它包含了标题和窗口控件按钮，它的可见性取决于工作空间和窗口类型 mDecorCaptionView = createDecorCaptionView(inflater); final View root = inflater.inflate(layoutResource, null);//1、用LayoutInflate来加载xml布局文件得到view //2、 若不 null 则先添加 mDecorCaptionView, 再向 mDecorCaptionView 中添加 root if (mDecorCaptionView != null) &#123; if (mDecorCaptionView.getParent() == null) &#123; //将 mDecorCaptionView 添加到DecorView addView(mDecorCaptionView, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT)); &#125; //获取的到root add到 mDecorCaptionView 中 mDecorCaptionView.addView(root, new ViewGroup.MarginLayoutParams(MATCH_PARENT, MATCH_PARENT)); &#125; else &#123; // 3、若mDecorCaptionView为 null, 则直接添加调用addView将 root 加到 DecorView 中 // Put it below the color views. addView(root, 0, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT)); &#125; // 4、强转成 ViewGroup, 传递给 mContentRoot mContentRoot = (ViewGroup) root; initializeElevation();&#125;private DecorCaptionView createDecorCaptionView(LayoutInflater inflater) &#123; ... //这里将源码稍微变动下，直接调用inflateDecorCaptionView方法 DecorCaptionView decorCaptionView = inflateDecorCaptionView(inflater) ... return decorCaptionView;&#125;private DecorCaptionView inflateDecorCaptionView(LayoutInflater inflater) &#123; final Context context = getContext(); inflater = inflater.from(context); //这边通过LayoutInflater来获到DecorCaptionView final DecorCaptionView view = (DecorCaptionView) inflater.inflate(R.layout.decor_caption, null); setDecorCaptionShade(context, view); return view;&#125; 可以看到在onResourcesLoaded这里是我们做了4件事： 4.1、注释1是根据LayoutInflate加载xml布局文件得到View对象 root 4.2、注释2判断DecorCaptionView是否为null，不为null，先去添加DecorCaptionView，再去添加root（DecorCaptionView是一个标题view，这个类表示用于控制自由格式上窗口的特殊屏幕元素） 4.3、注释3如果DecorCaptionView为null，就直接将root添加到DecorView中 4.4、注释4是将root强转成一个ViewGroup并传递给mContentRoot 5、在注释10这里根据我们的ID_ANDROID_CONTENT通过findViewById返回一个contentParent，它是我们在步骤3中的DecorView中mContentRoot中的FrameLayout的Id，也就是我们通过setContentView将布局添加进去的地方。12##Window public static final int ID_ANDROID_CONTENT = com.android.internal.R.id.content 2、布局加载器加载xml生成View树通过LayoutInflater布局加载器去生成View树1234567891011##LayoutInflaterpublic View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) &#123; final Resources res = getContext().getResources(); ... final XmlResourceParser parser = res.getLayout(resource);//1、根据xml id 得到一个xml解析器资源 try &#123; return inflate(parser, root, attachToRoot);//2、传入xml解析器资源和mContentParent &#125; finally &#123; parser.close(); &#125;&#125; 1、注释1得到一个xml解析器资源 2、注释3 调用inflate返回view1234567891011121314151617181920212223242526272829303132333435363738394041424344##LayoutInflaterpublic View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) &#123; synchronized (mConstructorArgs) &#123; ... View result = root;//1、它就是我们最终返回的view对象 try &#123; // Look for the root node. int type; ... final String name = parser.getName();//XmlPullParser解析xml，获取里面的标签name if (TAG_MERGE.equals(name)) &#123;//这里获取的name如果是merge，则root不能为null，否则会抛出异常 if (root == null || !attachToRoot) &#123; throw new InflateException(&quot;&lt;merge /&gt; can be used only with a valid &quot; + &quot;ViewGroup root and attachToRoot=true&quot;); &#125; rInflate(parser, root, inflaterContext, attrs, false); &#125; else &#123; // Temp is the root view that was found in the xml //2、这边创建得到一个临时的view对象 temp final View temp = createViewFromTag(root, name, inflaterContext, attrs); ViewGroup.LayoutParams params = null; ... if (root != null &amp;&amp; attachToRoot) &#123;//3、这边判断如果root不为null，则将临时的view对象temp添加到root中 root.addView(temp, params); &#125; if (root == null || !attachToRoot) &#123;//4、如果root为null，将temp传递给我们的最终view result = temp; &#125; &#125; &#125; ... return result; &#125;&#125; 这里通过一系列的判断和传递最终会得到一个View对象，它就是我们根据xml去解析加载出来的View树。 附加一张window和contentView的层次结构图 二、AppCompatActivity的xml加载跟进AppCompatActivity的setContentView方法12345##AppCompatActivity@Overridepublic void setContentView(@LayoutRes int layoutResID) &#123; getDelegate().setContentView(layoutResID);//调用getDelegate的setContentView&#125; 这边的getDelegate返回的是一个AppCompatDelegate，它是一个抽象类，这边我们跟踪发现最后是在AppCompatDelegateImplV9中调用了setContentView方法123456789##AppCompatDelegateImplV9@Overridepublic void setContentView(int resId) &#123; ensureSubDecor();//1、创建DecorView ViewGroup contentParent = (ViewGroup) mSubDecor.findViewById(android.R.id.content);//2、这边根据content id去返回一个contentParent contentParent.removeAllViews(); LayoutInflater.from(mContext).inflate(resId, contentParent);//3、通过LayoutInflater布局加载器将xml解析得到View树，添加到contentParent中 mOriginalWindowCallback.onContentChanged();&#125; 1、注释1创建DecorView1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980##AppCompatDelegateImplV9private void ensureSubDecor() &#123; if (!mSubDecorInstalled) &#123; mSubDecor = createSubDecor();//调用createSubDecor方法 ... &#125;&#125;private ViewGroup createSubDecor() &#123; TypedArray a = mContext.obtainStyledAttributes(R.styleable.AppCompatTheme); //获取当前的主题，然后设置相关数据到window上 ... mWindow.getDecorView();//1、调用PhoneWindow的getDecorView方法 final LayoutInflater inflater = LayoutInflater.from(mContext); ViewGroup subDecor = null;//定义一个viewgroup //2、根据window的样式不同去加载不同的layout if (!mWindowNoTitle) &#123; if (mIsFloating) &#123; ... subDecor = (ViewGroup) inflater.inflate( R.layout.abc_dialog_title_material, null); ... &#125; else if (mHasActionBar) &#123; ... subDecor = (ViewGroup) LayoutInflater.from(themedContext) .inflate(R.layout.abc_screen_toolbar, null); ... &#125; &#125; else &#123; if (mOverlayActionMode) &#123; subDecor = (ViewGroup) inflater.inflate( R.layout.abc_screen_simple_overlay_action_mode, null); &#125; else &#123; subDecor = (ViewGroup) inflater.inflate(R.layout.abc_screen_simple, null); &#125; ... &#125; ... //3、下面具体分析 // Make the decor optionally fit system windows, like the window&apos;s decor ViewUtils.makeOptionalFitsSystemWindows(subDecor); final ContentFrameLayout contentView = (ContentFrameLayout) subDecor.findViewById( R.id.action_bar_activity_content); final ViewGroup windowContentView = (ViewGroup) mWindow.findViewById(android.R.id.content); if (windowContentView != null) &#123; while (windowContentView.getChildCount() &gt; 0) &#123; final View child = windowContentView.getChildAt(0); windowContentView.removeViewAt(0); contentView.addView(child); &#125; // Change our content FrameLayout to use the android.R.id.content id. // Useful for fragments. windowContentView.setId(View.NO_ID); contentView.setId(android.R.id.content); // The decorContent may have a foreground drawable set (windowContentOverlay). // Remove this as we handle it ourselves if (windowContentView instanceof FrameLayout) &#123; ((FrameLayout) windowContentView).setForeground(null); &#125; &#125; //4、调用PhoneWindow的setContentView方法 // Now set the Window&apos;s content view with the decor mWindow.setContentView(subDecor); ... return subDecor;&#125; 在ensureSubDecor调用了createSubDecor方法： 1、注释1调用了PhoneWindow的getDecorView方法，我们可以看到这里去调用了installDecor方法，这个方法我们在本篇的Activity的xml加载过程已经分析过了。 12345678##PhoneWindow@Overridepublic final View getDecorView() &#123; if (mDecor == null || mForceDecorInstall) &#123; installDecor(); &#125; return mDecor;&#125; 2、注释2根据不同的window主题样式去加载不同的layout，然后通过布局加载器将xml解析成subDecor，每一个layout中都会include一个名为abc_screen_content_include.xml的layout，这个layout包含id为action_bar_activity_content的ContentFrameLayout。 1234567891011121314151617181920212223242526272829303132源码位置：/frameworks/support/v7/appcompat/res/layout/abc_dialog_title_material.xml##abc_screen_simple_overlay_action_mode&lt;android.support.v7.widget.FitWindowsFrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:id=&quot;@+id/action_bar_root&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:fitsSystemWindows=&quot;true&quot;&gt; &lt;include layout=&quot;@layout/abc_screen_content_include&quot; /&gt; &lt;android.support.v7.widget.ViewStubCompat android:id=&quot;@+id/action_mode_bar_stub&quot; android:inflatedId=&quot;@+id/action_mode_bar&quot; android:layout=&quot;@layout/abc_action_mode_bar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; /&gt;&lt;/android.support.v7.widget.FitWindowsFrameLayout&gt;##abc_screen_content_include&lt;merge xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;android.support.v7.widget.ContentFrameLayout android:id=&quot;@id/action_bar_activity_content&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:foregroundGravity=&quot;fill_horizontal|top&quot; android:foreground=&quot;?android:attr/windowContentOverlay&quot; /&gt;&lt;/merge&gt; 3、在注释3调用调用findViewById找到id为action_bar_activity_content的contentView，然后在通过PhoneWindow找到id为content的windowContentView，然后去循环遍历windowContentView，将它的的子View添加到contentView中去，然后在把windowContentView的id设置为-1，contentView的id设置为原来windowContentView的id content，这个地方可以简单的理解为就是将DecorView(windowContentView)中的view转移到subDecor(contentView)中。 4、注释4调用PhoneWindow的setContentView方法，将subDecor传递进去，然后将subDecor存放到mContentParent中，这边我们可以发现它和上一部分(Activity)的区别，在Activity中mContentParent是直接用来存放我们自定义xml布局的，在AppCompatActivity中，mContentParent会先存放一个subDecor，然后在subDecor才是真正存放我们的自定义xml布局。 12345678910111213141516171819202122232425262728##PhoneWindow@Overridepublic void setContentView(View view) &#123; setContentView(view, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));&#125;@Overridepublic void setContentView(View view, ViewGroup.LayoutParams params) &#123; if (mContentParent == null) &#123; installDecor(); &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; mContentParent.removeAllViews(); &#125; if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; view.setLayoutParams(params); final Scene newScene = new Scene(mContentParent, view); transitionTo(newScene); &#125; else &#123; mContentParent.addView(view, params); &#125; mContentParent.requestApplyInsets(); final Callback cb = getCallback(); if (cb != null &amp;&amp; !isDestroyed()) &#123; cb.onContentChanged(); &#125; mContentParentExplicitlySet = true;&#125; 一张层次结构图带你理解： 三、FragmentActivity的xml加载关于FragmentActivity，我们可以发现它自己是没有实现setContentView的，它是直接调用了父类Activity的setContentView方法，所以我们可以看上面的Activity的xml加载过程就可以了。但是为什么会有FragmentActivity以及它的作用呢，这就要从Fragment说起来，在Android3.0以前是没有Fragment的，为了能让3.0以前能使用Fragment我们需要引入了support包，然后去继承FragmentActivity就可以使用Fragment，在3.0以后我们可以选择直接继承Activity，就可以正常使用Fragment了。而且3.0以前获取FragmentManager的方法是getSupportFragmentManager，3.0以后直接用getFragmentManager就可以了。关于Fragment和FragmentManager我们会在另外的文字里进行分析，这里就不多讲。 ps：关于FragmentActivity的api原文 FragmentActivity is a special activity provided in the Support Library to handle fragments on system versions older than API level 11. If the lowest system version you support is API level 11 or higher, then you can use a regular Activity. 沿着别人走过的路，跟上去发现不一样的风景参考链接： 1、https://www.jianshu.com/p/3872219cc07a 2、https://www.jianshu.com/p/fc717b47b322","tags":[{"name":"Android","slug":"Android","permalink":"https:mubai.site/tags/Android/"}]},{"title":"Application的创建、Activity的创建","date":"2019-10-27T16:00:00.000Z","path":"2019-10-28-Application的创建、Activity的创建/","text":"关于Activity需要知道的更多内容 前言Activity作为作为四大组件中我们最常见的一个组件，经常接触使用，但是往往每次让我们对这个组件进行说明的时候，我们只知道它的几个生命周期，几种启动模式，但是具体的更多的就讲不出来了。ps：我在写这个之前实际上也是一知半解，所以今天我们一起去看看Activity更多的东西，源码版本为 android-26 1、Application的创建 2、Activity的创建和生命周期 一、Application的创建我们知道，java程序想运行都是通过调用main方法来启动，我们的Android应用程序也是如此，但是我们每次都是直接点击手机屏幕的应用图标就直接启动了app，这时候难免有疑惑，我们为什么不需要调用main方法就可以直接启动我们的程序呢，虽然我们没有直接的去写main方法，但是实际上还是通过ActivityThread类的main方法来作为我们应用程序的入口。12345678910111213141516# ActivityThread类public static void main(String[] args) &#123; ... Looper.prepareMainLooper(); ActivityThread thread = new ActivityThread();//1、这边new了一个ActivityThread对象 thread.attach(false);//2、这边去进行连接，连接什么？ if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; if (false) &#123; Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;)); &#125; Looper.loop(); throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;); &#125; 在ActivityThread类中，能看到一个main方法，它就是我们程序的入口，在注释1的地方，会去创建一个ActivityThread对象，在注释2的地方，调用thread的attach方法去连接，具体的连接什么我们继续看下面的代码 123456789101112131415#ActivityThread类private void attach(boolean system) &#123; ... if (!system) &#123; ... final IActivityManager mgr = ActivityManager.getService();//1、通过AIDL，获取AMS的代理对象IActivityManager try &#123; mgr.attachApplication(mAppThread);//2、这边将AMS和我们的应用进程application进行连接 &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125; &#125; else &#123; ... &#125; &#125; 关于AIDL，这边不进行展开，我们关心的是注释2，这边通过AIDL将AMS和我们应用进程application进行连接，具体的是调用ActivityManagerService的attachApplication方法进行连接。12345678910#ActivityManagerService类@Overridepublic final void attachApplication(IApplicationThread thread) &#123; synchronized (this) &#123; int callingPid = Binder.getCallingPid();//1、获取pid final long origId = Binder.clearCallingIdentity(); attachApplicationLocked(thread, callingPid);//2、传入pid进行连接 Binder.restoreCallingIdentity(origId); &#125; &#125; 这边的注释1通过Binder对象获取应用的pid，注释2处调用attachApplicationLocked的方法传入pid连接application。需要注意的这边加了synchronized关键字，表示我们需要等待这里执行完毕才能下一步，也就是说我们一个应用需要当我们application被连接后才能走下面的流程。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586##ActivityManagerServiceprivate final boolean attachApplicationLocked(IApplicationThread thread, int pid, int callingUid, long startSeq) &#123; ProcessRecord app; //1、进程记录类，保存相关的信息 long startTime = SystemClock.uptimeMillis(); if (pid != MY_PID &amp;&amp; pid &gt;= 0) &#123; synchronized (mPidsSelfLocked) &#123; app = mPidsSelfLocked.get(pid); //2、根据id获取相关信息赋值给记录对象 &#125; &#125; ... if (app.instr != null) &#123; //3、判断进程是否正在活跃 //Application 4、绑定到当前线程 thread.bindApplication(processName, appInfo, providers, app.instr.mClass, profilerInfo, app.instr.mArguments, app.instr.mWatcher, app.instr.mUiAutomationConnection, testMode, mBinderTransactionTrackingEnabled, enableTrackAllocation, isRestrictedBackupMode || !normalMode, app.persistent, new Configuration(getGlobalConfiguration()), app.compat, getCommonServicesLocked(app.isolated), mCoreSettingsObserver.getCoreSettingsLocked(), buildSerial, isAutofillCompatEnabled); &#125; else &#123; //Application 4、绑定到当前线程 thread.bindApplication(processName, appInfo, providers, null, profilerInfo, null, null, null, testMode, mBinderTransactionTrackingEnabled, enableTrackAllocation, isRestrictedBackupMode || !normalMode, app.persistent, new Configuration(getGlobalConfiguration()), app.compat, getCommonServicesLocked(app.isolated), mCoreSettingsObserver.getCoreSettingsLocked(), buildSerial, isAutofillCompatEnabled); &#125; ... // See if the top visible activity is waiting to run in this process... //查看顶部可见活动是否正在等待在此进程中进行 if (normalMode) &#123; try &#123; //TODO 5、Activity创建的分析 //检测top的Activity是否在运行中等待 if (mStackSupervisor.attachApattachApplicationplicationLocked(app)) &#123; didSomething = true; &#125; &#125; catch (Exception e) &#123; Slog.wtf(TAG, &quot;Exception thrown launching activities in &quot; + app, e); badApp = true; &#125; &#125; // Find any services that should be running in this process... //查看在此进程中进行的服务 if (!badApp) &#123; try &#123; didSomething |= mServices.attachApplicationLocked(app, processName); checkTime(startTime, &quot;attachApplicationLocked: after mServices.attachApplicationLocked&quot;); &#125; catch (Exception e) &#123; Slog.wtf(TAG, &quot;Exception thrown starting services in &quot; + app, e); badApp = true; &#125; &#125; // Check if a next-broadcast receiver is in this process... //查看在此进程中进行的广播接收者 if (!badApp &amp;&amp; isPendingBroadcastProcessLocked(pid)) &#123; try &#123; didSomething |= sendPendingBroadcastsLocked(app); checkTime(startTime, &quot;attachApplicationLocked: after sendPendingBroadcastsLocked&quot;); &#125; catch (Exception e) &#123; // If the app died trying to launch the receiver we declare it &apos;bad&apos; Slog.wtf(TAG, &quot;Exception thrown dispatching broadcasts in &quot; + app, e); badApp = true; &#125; &#125; // Check whether the next backup agent is in this process... //检测下一个备份代理是否在此进程中 if (!badApp &amp;&amp; mBackupTarget != null &amp;&amp; mBackupTarget.app == app) &#123; if (DEBUG_BACKUP) Slog.v(TAG_BACKUP, &quot;New app is backup target, launching agent for &quot; + app); notifyPackageUse(mBackupTarget.appInfo.packageName, PackageManager.NOTIFY_PACKAGE_USE_BACKUP); try &#123; thread.scheduleCreateBackupAgent(mBackupTarget.appInfo, compatibilityInfoForPackageLocked(mBackupTarget.appInfo), mBackupTarget.backupMode); &#125; catch (Exception e) &#123; Slog.wtf(TAG, &quot;Exception thrown creating backup agent in &quot; + app, e); badApp = true; &#125; &#125; ...&#125; 看具体的attachApplicationLocked方法里面，注释1处创建了一个进程记录对象用来保存进程的相关信息，注释2根据id获取到相关信息赋值给记录对象，注释3先判断进行是否活跃，然后调用bindApplication的方法进行application的绑定，这边的thread是IApplicationThread对象，IApplicationThread它是一个AIDL的接口，是系统进程调用应用进程的接口，它的实现类是ApplicationThread，是一个在ActivityThread的内部类，注释5的地方是关于Activity的创建，我们这边先跳过，等我们将Application进行绑定完成后在来分析。123456789101112131415161718##ActivityThread.ApplicationThreadpublic final void bindApplication(String processName, ApplicationInfo appInfo...，String buildSerial) &#123; if (services != null) &#123; // Setup the service cache in the ServiceManager ServiceManager.initServiceCache(services); &#125; setCoreSettings(coreSettings);//1、添加核心设置 //2、将bindApplication带进来的信息封装到AppBindData类中，通过handler发送出去 AppBindData data = new AppBindData(); data.processName = processName; data.appInfo = appInfo; data.providers = providers; ... sendMessage(H.BIND_APPLICATION, data);//3、将data通过handler发送出去，具体的WHAT 是 H.BIND_APPLICATION &#125; 在注释1会去添加一些核心的设置，我们这边就不去关注，我们看注释2的地方，去将带进来的信息封装到data中然后在注释3通过handler发送出去，具体的WHAT 是 H.BIND_APPLICATION。H是一个继承Handler的子类，这边我们去看下消息是如何被分发处理的。12345678910111213141516##ActivityThread.Hpublic void handleMessage(Message msg) &#123; ... switch (msg.what) &#123; ... case BIND_APPLICATION: //1、这边进行handler消息的处理 处理创建Application的消息 Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;bindApplication&quot;); AppBindData data = (AppBindData) msg.obj; handleBindApplication(data); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; ... &#125; ...&#125; 这边注释1处理创建Application的消息，调用handleBindApplication的方法去绑定application1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950##ActivityThreadprivate void handleBindApplication(AppBindData data) &#123; final InstrumentationInfo ii;//1、创建InstrumentationInfo对象 ... final ContextImpl appContext = ContextImpl.createAppContext(this, data.info); 2、 //获取application的context上下文 // 3、加载instrumentation if (ii != null) &#123; ... mInstrumentation.init(this, instrContext, appContext, component, data.instrumentationWatcher, data.instrumentationUiAutomationConnection); //4、instrumentation初始化 ... &#125; else &#123; mInstrumentation = new Instrumentation(); &#125; try &#123; Application app = data.info.makeApplication(data.restrictedBackupMode, null);//5、通过makeApplication方法创建application ... // Do this after providers, since instrumentation tests generally start their // test thread at this point, and we don&apos;t want that racing. try &#123; mInstrumentation.onCreate(data.instrumentationArgs); &#125; catch (Exception e) &#123; throw new RuntimeException( &quot;Exception thrown in onCreate() of &quot; + data.instrumentationName + &quot;: &quot; + e.toString(), e); &#125; try &#123; mInstrumentation.callApplicationOnCreate(app);//6、回调application的onCreate方法 &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(app, e)) &#123; throw new RuntimeException( &quot;Unable to create application &quot; + app.getClass().getName() + &quot;: &quot; + e.toString(), e); &#125; &#125; &#125; finally &#123; StrictMode.setThreadPolicy(savedPolicy); &#125; &#125; 这个方法里面处理了许多事情，注释1创建了一个InstrumentationInfo对象，在注释2获取了application的上下文，注释3和4去加载并初始化了InstrumentationInfo，注释5是我们的关键地方，通过调用makeApplication的方法创建了我们的application，我们看下makeApplication的方法都做了什么操作。然后在注释6调用InstrumentationInfo去回调application的onCreate方法，到这里我们的application就创建并且回到了我们熟悉onCreate方法。 1234567891011121314151617181920212223242526272829303132333435363738##LoadedApkpublic Application makeApplication(boolean forceDefaultAppClass, Instrumentation instrumentation) &#123; if (mApplication != null) &#123;//1、如果mApplication不为null，直接返回mApplication对象 return mApplication; &#125; Application app = null; //如果是有自定义的application，就用这个，如果没有，就用系统的application String appClass = mApplicationInfo.className; if (forceDefaultAppClass || (appClass == null)) &#123; appClass = &quot;android.app.Application&quot;; &#125; try &#123; //2、获得类加载器然后通过反射去new一个Appliction java.lang.ClassLoader cl = getClassLoader(); ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this); app = mActivityThread.mInstrumentation.newApplication( cl, appClass, appContext); appContext.setOuterContext(app); &#125; catch (Exception e) &#123; ... &#125; mActivityThread.mAllApplications.add(app); mApplication = app;//3、赋值给mApplication if (instrumentation != null) &#123;//4、这边会为instrumentation是为null的 try &#123; instrumentation.callApplicationOnCreate(app);//5、这边如果instrumentation不为null，才能执行到这里 &#125; catch (Exception e) &#123; if (!instrumentation.onException(app, e)) &#123; ... &#125; &#125; &#125; ... return app; &#125; 这边我们首先判断mApplication如果不为null，直接返回这个对象，如果为null的话，我们通过类加载然后反射去new出一个application对象并且赋值给mApplication，还有这边因为我们在调用makeApplication方法时传入的Instrumentation是个null对象，所以我们这边不会去执行callApplicationOnCreate回调onCreate方法的。具体的回调onCreate会在上面的源码注释6的地方去执行回调。 二、Activity的创建这边我们首先需要知道Activity的状态和生命周期 状态：运行、暂停、停止、销毁(运行和暂停是不可见的，停止和销毁是不可见的)生命周期：包括了常见的onCreate、onResume、onStart、onPause、onStop、onDestory等 上面的分析过程中我们在ActivityManagerService类中留了一个1234567891011##ActivityManagerServiceprivate final boolean attachApplicationLocked(IApplicationThread thread, int pid, int callingUid, long startSeq) &#123; ... //5、检测最可见的Activity是否在运行进程中等待，如果再则创建Activity //TODO 待分析Activity的创建 if (mStackSupervisor.attachApplicationLocked(app)) &#123; didSomething = true; &#125;&#125;... 这边我们对它进行深入下看看是如何创建的1234567891011121314151617181920212223242526272829##ActivityStackSupervisorboolean attachApplicationLocked(ProcessRecord app) throws RemoteException &#123; ... for (int displayNdx = mActivityDisplays.size() - 1; displayNdx &gt;= 0; --displayNdx) &#123; ArrayList&lt;ActivityStack&gt; stacks = mActivityDisplays.valueAt(displayNdx).mStacks; for (int stackNdx = stacks.size() - 1; stackNdx &gt;= 0; --stackNdx) &#123; final ActivityStack stack = stacks.get(stackNdx); if (!isFocusedStack(stack)) &#123; continue; &#125; //ActivityRecord来维护Activity运行时的状态信息，需要将Activity绑定到AMS，ActivityRecord才能开始Activity的生命周期 ActivityRecord hr = stack.topRunningActivityLocked(); if (hr != null) &#123; if (hr.app == null &amp;&amp; app.uid == hr.info.applicationInfo.uid &amp;&amp; processName.equals(hr.processName)) &#123; try &#123; if (realStartActivityLocked(hr, app, true, true)) &#123;//1、真正的创建Activity didSomething = true; &#125; &#125; catch (RemoteException e) &#123; throw e; &#125; &#125; &#125; &#125; &#125; ... return didSomething; &#125; 在realStartActivityLocked我们会创建Activity1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253##ActivityStackSupervisor final boolean realStartActivityLocked(ActivityRecord r, ProcessRecord app, boolean andResume, boolean checkConfig) throws RemoteException &#123; ... r.startFreezingScreenLocked(app, 0);//1、开始屏幕相关的启动 // schedule launch ticks to collect information about slow apps. r.startLaunchTickingLocked();//2、启动定时锁定 r.app = app; app.waitingToKill = null; r.launchCount++;//3、每启动一次launchCount的数量自增 r.lastLaunchTime = SystemClock.uptimeMillis();//4、修改最后一次的启动时间 final ActivityStack stack = task.getStack(); try &#123; ... //5、根据具体的包名，通知应用 mService.notifyPackageUse(r.intent.getComponent().getPackageName(), PackageManager.NOTIFY_PACKAGE_USE_ACTIVITY); ... //6、调用ApplicationThread的scheduleLaunchActivity 方法去启动LaunchActivity app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken, System.identityHashCode(r), r.info, // TODO: Have this take the merged configuration instead of separate global and // override configs. mergedConfiguration.getGlobalConfiguration(), mergedConfiguration.getOverrideConfiguration(), r.compat, r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results, newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo); ... &#125; catch (RemoteException e) &#123; ... &#125; ... if (isFocusedStack(stack)) &#123; mService.startSetupActivityLocked();7、开始设置活动锁 &#125; if (r.app != null) &#123; mService.mServices.updateServiceConnectionActivitiesLocked(r.app);//8、更新服务连接活动锁 &#125; return true; &#125; 这边的注释很多，但是我们主要关心的是注释6，这边调用ApplicationThread的scheduleLaunchActivity 方法去启动LaunchActivity，我们回到ApplicationThread 123456789101112##ActivityThread.ApplicationThread@Overridepublic final void scheduleLaunchActivity(Intent intent, IBinder token, int ident, ..., ProfilerInfo profilerInfo) &#123; updateProcessState(procState, false); ActivityClientRecord r = new ActivityClientRecord(); ... sendMessage(H.LAUNCH_ACTIVITY, r);//通过handler发送启动Activity的消息&#125; 这边是不是很眼熟，我们刚刚的application的绑定也是通过handler去发送消息去处理(这边我们能发现handler是有多么重要了吧，哈哈)，我们去ActivityThread的子类H去看下具体的activity创建的消息处理1234567891011public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case LAUNCH_ACTIVITY: &#123;//1、接收到关于创建Activity的消息，进行处理 Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityStart&quot;); final ActivityClientRecord r = (ActivityClientRecord) msg.obj; r.packageInfo = getPackageInfoNoCheck( r.activityInfo.applicationInfo, r.compatInfo); handleLaunchActivity(r, null, &quot;LAUNCH_ACTIVITY&quot;);//2、去创建LaunchActivity Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); &#125;&#125; 根据message的what值我们找到了具体的消息处理，这边会通过handleLaunchActivity去处理我们Activity创建123456789101112131415161718192021222324##ActivityThread private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) &#123; ... Activity a = performLaunchActivity(r, customIntent);//1、去执行LaunchActivity if (a != null) &#123; r.createdConfig = new Configuration(mConfiguration); reportSizeConfigurations(r); Bundle oldState = r.state; handleResumeActivity(r.token, false, r.isForward, !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason);//2、处理可见Activity ... &#125; else &#123; // If there was an error, for any reason, tell the activity manager to stop us. try &#123; //3、这边如何activity是个null的对象，直接通过ActivityManagerService调用finishActivity去关闭掉 ActivityManager.getService() .finishActivity(r.token, Activity.RESULT_CANCELED, null, Activity.DONT_FINISH_TASK_WITH_ACTIVITY); &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125; &#125; &#125; 这边我们先看注释1的performLaunchActivity方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455##ActivityThreadprivate Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; ... ActivityInfo aInfo = r.activityInfo;//1、获取Activity的信息 if (r.packageInfo == null) &#123; r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo, Context.CONTEXT_INCLUDE_CODE); &#125; ... ContextImpl appContext = createBaseContextForActivity(r);//2、获取Acitivty的上下文 Activity activity = null; try &#123; java.lang.ClassLoader cl = appContext.getClassLoader();//3、获取类加载器，使用cl(类加载器）加载出Activity，再使用反射new出Activity activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); StrictMode.incrementExpectedActivityCount(activity.getClass()); r.intent.setExtrasClassLoader(cl); r.intent.prepareToEnterProcess(); if (r.state != null) &#123; r.state.setClassLoader(cl); &#125; &#125; catch (Exception e) &#123; ... &#125; try &#123; //4、这边又去调用一次makeApplication方法 Application app = r.packageInfo.makeApplication(false, mInstrumentation); if (activity != null) &#123; ... appContext.setOuterContext(activity); activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor, window, r.configCallback); ... if (r.isPersistable()) &#123;//5、这边去调用Activity的onCreate方法 mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); &#125; else &#123; mInstrumentation.callActivityOnCreate(activity, r.state); &#125; ... &#125; catch (SuperNotCalledException e) &#123; throw e; &#125; catch (Exception e) &#123; ... &#125; return activity; &#125; 在注释3我们会发现这边是获取类加载去然后通过反射去new出一个Activity，然后在注释5去回调Activity的onCreate方法，到这边我们就能去调用我们的setContentView去加载布局了。注释4的地方又调用了一次makeApplication方法，如果Application不为null，直接返回application对象。现在我们回到上一个源码的注释2那里，看看handleResumeActivity都做了什么?1234567##ActivityThread final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward, boolean reallyResume, int seq, String reason) &#123; ... r = performResumeActivity(token, clearHide, reason); ... &#125; 这个方法里面有很多代码，我们只需要去看performResumeActivity方法1234567##ActivityThreadpublic final ActivityClientRecord performResumeActivity(IBinder token, boolean clearHide, String reason) &#123; ... r.activity.performResume();//主要是这个方法 ... return r;&#125; 这边是调用Activity的performResume方法12345678910111213##Activityfinal void performResume() &#123; performRestart(); mFragments.execPendingActions(); mLastNonConfigurationInstances = null; mCalled = false; // mResumed is set by the instrumentation mInstrumentation.callActivityOnResume(this);//回调Activity的onResume方法 &#125; 到这边我们就能发现它跟Activity的onCreate的回调是类似的，都是通过mInstrumentation.callActivityxxx去回调执行。 沿着别人走过的路，跟上去发现不一样的风景参考链接：https://www.jianshu.com/p/f55467033146","tags":[{"name":"Android","slug":"Android","permalink":"https:mubai.site/tags/Android/"}]},{"title":"5.1节日旅游攻略","date":"2019-03-30T16:00:00.000Z","path":"2019-3-31-5.1旅游攻略/","text":"5.1节日旅游攻略、未完待续 5.1节日旅游攻略第一站：乌镇出发站：杭州 出发时间：5.1 动车： G7572：9:57 ￥21.5*2 G7316：10:12 ￥21.5*2 时间：5.1-5.2 酒店：乌镇小宿 ￥468 门票：西栅+东栅联票 ￥190*2 景点：列举了主要景点 1、西栅：最适合夜游及住宿的区域，夜晚的水上莲花可以look look 1.1、中国邮政：光绪年间的邮局 1.2、草木本色染坊：拍照 1.3、白莲塔：乌镇最高建筑 1.4、三寸金莲馆：中国女性裹足史 1.5、月老庙：许愿 1.6、邵明书院：邵明太子读书处 1.7、囍庆堂：江南婚礼 1.8、西市河：最美夜景地 1.9、天下第一锅：申请吉尼斯纪录 1.10、乌镇大剧院/大戏院：感受当地人文生活 1.11、茅盾纪念堂：纪念馆 2、东栅 2.1、茅盾故居：文学大师茅盾故居 2.2、宏源泰染坊：拍照 2.3、三白酒坊：酿酒过程 2.4、江南百床馆：中国第一家收藏、展出江南古床的博物馆 2.5、逢源双桥：按男左女右走一遍可以左右逢源 2.6、江南民俗馆：江南民俗文化展示 2.7、江南木雕陈列馆：古代木雕展览 2.8、财神湾：发财啊，去去去。 2.9、立志书院：茅盾的手稿、作品、提字 2.10、修真观广场 2.11、余榴梁钱币馆：各个国家的钱币展示 3、南栅和北栅都属于未开发的地段，原生态 美食：找找看 第二站：苏州出发站：乌镇 出发时间：5.2 动车： G7586：10：04 ￥85.5*2 G7572：10:126 ￥90.5*2 时间：5.2-5.4 酒店：苏州小院 ￥530*2 景点：苏州景点太多 1、观前街 1.1、拙政园：天下园林之母，门票：70*2 1.2、苏州博物馆：苏州园林风格 1.3、平江路：苏州保存最好的古街 1.4、狮子林：叠石最有名，四大名园之一 1.5、苏州古典园林：世界文化遗产 1.6、太平天国忠王符：苏式彩绘 2、十全街 2.1、网师园：苏州四大名园之一 2.2、沧浪亭：苏州最古老园林 2.3、苏州大学：中国十大最美校园之一 2.4、苏州云岩寺塔：中国第一斜塔 3、石路商圈 3.1、虎丘：吴中第一名胜 3.2、七里山塘：姑苏第一名街 3.3、留园：小家碧玉式，四大名园之一 3.4、剑池：虎丘最神秘的名胜 3.5、万景山庄：苏派盆景精品园 3.6、山塘书院：听苏州评弹 3.7、拥翠山庄：苏州唯一无水园林 4、金鸡湖： 4.1、金鸡湖：骑行、夜景 4.2、月光码头：苏州十大最美夜景之首 5、周庄 5.1、周庄古镇：中国第一水乡 5.2、双桥：故乡的回忆蓝本 5.3、沈万三故居：沈万三 5.4、沈厅：沈万三后人的宅子 5.5、南湖秋月园：水中佛国 5.6、周庄博物馆：了解周庄历史 5.7、富安桥：周庄最古老的桥 6、同里 6.1、同里古镇：江南六大古镇之一 6.2、退思园：世界文化遗产 6.3、珍珠塔：同里最大园林 6.4、耕乐堂：同里八景之一 7、阳澄湖 7.1阳澄湖半岛旅游度假区：阳澄湖大闸蟹 8、太湖 8.1、苏州东山景区：太湖山水第一镇 8.2、苏州西山景区：太湖第一大岛 美食：找找 终点站：杭州时间：5.4","tags":[{"name":"闲文","slug":"闲文","permalink":"https:mubai.site/tags/闲文/"}]},{"title":"Me","date":"2019-02-19T16:00:00.000Z","path":"Me/","text":"个人简历，更新中 - 个人简历 姓名： 林志文 花名： 沐白 Email： quickly520@126.com 优势… 工作经历 杭州筑家易网络科技股份有限公司 2016.8-至今 杭州一幅画网络科技有限公司 2016.4-2016.7 项目经历… 自我评价…","tags":[{"name":"简历","slug":"简历","permalink":"https:mubai.site/tags/简历/"}]},{"title":"物联网设备-WiFi/Bluetooth/ZigBee配网方式","date":"2018-10-08T16:00:00.000Z","path":"2018-10-9-物联网通信-WiFi:BT:ZigBee芯片级方案解析/","text":"一、WIFI设备配网智能家居的设备智能化，很多家电设备都安装上了WiFi模块, 方便用户通过手机控制和远程查看家里情况，典型的设备如智能插座，智能空调，智能空气净化器。智能设备首次配置，这个过程简单来讲就是把WiFi设备初始化后，连到家里的无线路由器上。第一次配置成功后，基本就一劳永逸了。 1、目前流行的wifi配置模式一般有以下2种: AP模式： 智能硬件处于AP模式，手机用于station模式,手机连接智能插座的AP后组成局域网,手机发送需要连接路由的SSID及密码至智能插座,智能硬件主动去连接指定路由后,完成连接 AP（兼容） 模式 AP 是 (Wireless) Access Point 的缩写，即 (无线) 访问接入点。简单来讲就像是无线路由器一样，设备打开后进入 AP 模式，在手机的网络列表里面，可以搜索到类似 TPLINK_XXX 的名字（SSID）。 连接步骤： 1、连接路由器（获取路由器名称） 2、请求配网token，用户输入 WiFi 名字和密码后 3、初始化硬件设备，使设备进入 AP 模式，Wifi 灯慢闪 4、手机切回 WiFi：接入上述 设备出现的 WiFi 名字（SSID）的网络 （类似 TPLINK_XXX）。连上设备后，通过 UDP 发送 经过 AES 加密过的 ssid/password/token 5、设备通过 UDP 包获取配置信息，切换网络模式，连接上家里 WiFi，配置完成。断开设备热点。发送token，注册到服务端，登录MQTT服务器 6、手机切回到家里面的 WiFi ，根据token，去服务端查找设备。 7、服务器返回智能设备的信息 一键配置(smartconfig)模式: 智能硬件处于混杂模式下,监听网络中的所有报文;手机APP将SSID和密码编码到UDP报文中,通过广播包或组播报发送,智能硬件接收到UDP报文后解码,得到正确的SSID和密码,然后主动连接指定SSID的路由,完成连接 EZ（快捷）Easy-Connect 模式 这种快速连接方式，相对于 AP 模式连接简化操作，省了很多步骤，首次配置速度更快。 1、手机连上 WiFi，开启 APP 软件，点击”添加新设备”，进入配置界面，输入手机所在 WiFi 密码，请求配网token 2、智能硬件开启混杂模式监听所有网络数据包，Wifi 灯快闪 3、手机通过广播、组播循环发送 ssid/password/token 4、硬件设备通过 UDP 包（长度）获取配置信息捕捉到ssid/password/token，Wifi灯熄灭，连接路由器，连接成功后Wifi灯常亮。发送token，注册到服务端，注册成功后登录MQTT服务器。（广播根据 UDP 包长度，组播根据 IP 地址信息） 5、手机根据token，去服务端查找设备，返回设备信息 2、当前主流IOT的wifi方案有:这个功能最早是TI提出并应用于CC3200上;不过从原理上讲,只要芯片驱动支持开启混杂模式(WiFi Promiscuous),就可以支持一键配网功能,只是各个厂家叫法及实现编码方式不同而已; 手机编码发送采用有UDP组播或广播,不同的发送方式和编码,对应的解码过程也不一样.,当前测试发现,微信是通过UDP广播包实现的;TI是通过往一固定IP地址发送udp包;其他芯片厂家提供的一般为UDP组播方式; 由于无线数据传播必定是广播的,所以必然可以被监听到;如果AP没有加密的话,UDP直接可以把相关的信息发送出来.但是路由器AP一般都是加密的,而且加密方式不固定.wifi模块在无法直接解析出数据包 1、广播：发送方可通过改变其所需要发送数据包的长度进行控制所以只要指定出一套利用长度编码的通讯协议,就可利用数据包的Lenght字段进行数据传递 2、 组播：组播地址是保留的D类地址从224.0.0.0-239.255.255.255IP地址与MAC地址映射关系为:将MAC地址的前25位设定为01.00.5e,而MAC地址的后23位对应IP地址的位;故发送端可以将数据编码在组播ip的后23bit中,通过组播包发送,接收端进行解码即可 二、Bluetooth配网三、Zjgbee 参考资料： Wifi: WLAN(Wireless Local Area Network)无线局域网络，是一个概念，网络技术术语，IEEE802.11标准是无线局域网最通用的标准Wifi(Wireless Fidelity)是设备商成立的一个联盟，负责测试认证，是使用802.11技术实现的 ZjgBee: 目前在国内采用ZigBee协议智能家居的有3家公司的芯片，恩智浦（NXP）公司（小米智能家居采用的就是该公司的ZigBee芯片），TI公司（德州仪器）CC2530芯片（国内95%以上的公司采用该ZigBee芯片），芯科（Silicon Labs）公司（国内只有极少数公司采用该公司芯片，如聪明屋智能家居采用的是该公司的EM357芯片），该芯片属于ZigBee芯片领域的工业级高性能级别，应用到智能家居居有绝对的优势，规避了传统ZigBee芯片智能家居组网规模小、易丢包不稳定的顽疾。事实证明芯科芯片的智能网关，在保证智能家居系统稳定运行的前提下可以携带120个以上的节点，TI和恩智浦的只能带30个以内的节点。另外芯科（Silicon Labs）公司又发布EFR32MG系列ZigBee芯片，其中部分芯片能同时支持4种无线协议：ZigBee、Thread、BLE（蓝牙）、Proprietary（sub GHZ，小无线），说通俗一点就是用芯科（Silicon Labs）ZigBee芯片开发的ZigBee智能家居可以兼容Thread、BLE（蓝牙）、Proprietary（sub GHZ，小无线）这3种通讯协议的产品，能和这3种通信协议的设备互联互通，技术创新遥遥领先，所以说要做好ZigBee技术智能家居，芯片选择至关重要。","tags":[{"name":"物联网","slug":"物联网","permalink":"https:mubai.site/tags/物联网/"}]},{"title":"Nexus+Maven搭建私有库","date":"2018-07-11T16:00:00.000Z","path":"2018-7-12-Nexus+Maven搭建私有库/","text":"Maven：项目管理和自动构建的工具,maven包集中存放的地方就是maven仓库。这些仓库可以放在本地，也可以放在某个远程服务器上，可以是私有的，也可以是共有的。 Nexus：强大的maven仓库管理器，简化了本地仓库的维护和外部仓库的访问 1.下载安装Nexus3.0nexus的下载地址：https://blog.sonatype.com/ 2.启动Nexus将下载后的zip解压到某个路径下执行 /Users/***/nexus-3.12.1-01-mac/nexus-3.12.1-01/bin/nexus start 执行成功后 Starting nexus 3.浏览器打开Nexushttp://127.0.0.1:8081/nexus/ 注：启动服务需要等待一会 4.用户登录默认的是游客身份，可以查看，但是不能配置需要配置的时候使用管理员身份登录： admin/admin123 5.Blob Stroes依赖index存储目录，默认存储在default下： \\sonatype-work\\nexus3\\blobs\\default 也可以自己新建一个目录专门存在某个仓库的索引，在创建repository可以选择 6.reponsitoryNexus默认创建了几个仓库group:是一个仓库组，包含了hosted和proxy两种库，下载时按配置顺序从中依次查找hosted:一般是部署我们项目打包的jar，供内部人员下载proxy：代理远程仓库，maven-central是默认maven中央仓库代理，通过代理从远程仓库中下载的依赖都会被缓存到nexus的proxy库中 7.创建自己的reponsitory一般情况下我们会选择创建一个hosted仓库 步骤为repositories –&gt; Add –&gt; hosted repository，在页面的下半部分输入框中填入repository id和repository name即可，另外把deployment policy设置为Allow Redeploy，点击save就创建完成了 这边我们可以看到我们创建成功的reponsitory，这里有个仓库的地址http://127.0.0.1:8081/repository/test-comment-release/可以复制出来 8.创建完成后我们在androidStudio创建一个项目，项目中创建一个model在根目录的build.gradle的repositories中添加： maven{ url ‘http://127.0.0.1:8081/repository/test-comment-release/&#39;} 然后在model的build.gradle中添加 1234567891011121314151617181920212223uploadArchives &#123; configuration = configurations.archives repositories &#123; mavenDeployer &#123; snapshotRepository(url: MAVEN_REPO_SNAPSHOT_URL) &#123; authentication(userName: NEXUS_USERNAME, password: NEXUS_PASSWORD) &#125; repository(url: MAVEN_REPO_RELEASE_URL) &#123; authentication(userName: NEXUS_USERNAME, password: NEXUS_PASSWORD) &#125; pom.project &#123; version &apos;1.0.0&apos;//版本号可以直接指定 artifactId &apos;comment-sdk&apos;//这边的id我们可以指定 groupId GROUP_ID packaging TYPE description DESCRIPTION &#125; &#125; &#125;&#125;artifacts &#123; archives file(&apos;model名称.aar&apos;)//我们的model名.aar&#125; 注意的是需要在model的build.gradle中添加(使得这个model可以作为maven) 1apply plugin: &apos;maven&apos; 9.在gradle.properties中添加：12345678910111213141516171819202122# Maven仓库的URLMAVEN_REPO_RELEASE_URL=http://127.0.0.1:8081/repository/mubai-comment-release/ 这边是正式的仓库的地址MAVEN_REPO_SNAPSHOT_URL=http://127.0.0.1:8081/repository/mubai-comment-snapshot/ 这边是snapshot的仓库的地址# 对应maven的GroupId的值GROUP = com.comment.sdk 这边我们可以自己指定##### 登录nexus ossde的用户名NEXUS_USERNAME=admin# 登录nexus oss的密码NEXUS_PASSWORD=admin123# groupidGROUP_ID = com.comment.sdk 这边我们可以自己指定# typeTYPE = aar# descriptionDESCRIPTION = This is comment sdk 描述 然后点击右侧的Gradle找到我们需要上传的model，然后里面的upload中的uploadArchives双击，然后等待上传aar成功 10.上传成功后我们可以在nexus上看到我们的上传的aar11.然后我们在需要用到的项目中，先去根目录build的地方添加：12maven&#123; url &apos;http://可以换成服务器的ip地址:8081/repository/mubai-comment-release/&apos;&#125; 然后在具体的app的build中添加： 12#前面是我们GROUP_ID:ArtifactId:版本号(这些id我们都可以自己在配置的时候去指定)compile &apos;com.comment.sdk:comment-sdk-debug:1.1.0&apos; 然后我们就可以引用我们aar包里面的东西 实际上使用nexus只是作为一个管理aar包的托管服务器，我们在利用gradle将aar包上传到nexus上面 补充说明： maven仓库地址和ID的命名规则 正式仓库地址：MAVEN_REPO_RELEASE_URL=http://192.168.1.20:8081/nexus/content/groups/app-public/ 快照仓库地址：MAVEN_REPO_SNAPSHOT_URL=http://192.168.1.20:8081/nexus/content/repositories/snapshots/ GroupId: com.zjy.iot.app artifactId ‘iot-app-xxx-sdk’","tags":[{"name":"Maven","slug":"Maven","permalink":"https:mubai.site/tags/Maven/"}]},{"title":"Android Gradle","date":"2018-02-25T16:00:00.000Z","path":"2018-2-26-Android Gradle 中遇到的问题/","text":"1Failed to resolve: xxx.xxx.xxx:xxx:x.x.x Show in File Show in Project Structure dialog 有时候在我们创建项目引入一个新的依赖或者打开一个从网上clone下来的项目的时候会遇到这样的问题","tags":[{"name":"Android","slug":"Android","permalink":"https:mubai.site/tags/Android/"}]},{"title":"Android9.0曝光新特性","date":"2018-02-04T16:00:00.000Z","path":"2018-2-5-Android9.0曝光新特性/","text":"安卓9.0将加入电话录音功能：提高通话安全性 通话录音是目前许多手机都有的功能，但安卓原生系统并没有自带这项功能。 据外媒Android Headlines消息称，发现Google在下个安卓开放源代码（AOSP）中发现新的代码，(此代码可能指向记录录音功能)说明下个安卓版本将会具有记录录音功能。 据悉，原声Android9.0的版本可以提供通话录音，而且通过提示用户进行操作，并且双方在通话的过程中，手机系统每15秒钟会发出一次蜂鸣声(手机将会把频率为1400Hz、每15秒钟重复一次的提示音添加到通话中，该声音将会被通话双方都听到，让对方确认你正在录音)，这种声音是提示呼叫者他们的对话正在被录音。 为了保证安全性，这段录音文件极有可能会存在Google云服务器中(话说国内如何访问呢…) 另外，据说Android9.0会提高系统的封闭性，让一些高度自由化的操作断绝掉(比如高权限插件、自动签到、个性化UI定制等)，整体的系统机制向iOS靠拢，对于用户来说只能说是喜忧参半，采用封闭机制，APP自启动、高敏感权限申请，等不再会出现，安全性、流畅度、稳定性都将大幅提升，但是却要牺牲原本的可玩性，只能说鱼与熊掌不能兼得吧！ 当然对于开发者来说，提高系统的封闭性后，缺点在于我们对于一些需要的权限、操作需要更多的实现代码，同时原本的一些功能需要通过不同的方式方法实现，好处在于我们可以开发出安全性、稳定性更高的App！","tags":[{"name":"Android","slug":"Android","permalink":"https:mubai.site/tags/Android/"}]},{"title":"Android各大应用商店应用图标、截图尺寸","date":"2018-02-04T16:00:00.000Z","path":"2018-2-5-Android各大商店应用图标、截图尺寸/","text":"360 应用图标：512 * 512png 应用截图：480 * 800 5张 png 百度 应用图标：512*512 png 应用截图：480 * 800 5张 腾讯 应用图标：16 16一张，512 512一张 png 应用截图：480 * 800 5张 png 华为 应用图标：16 16一张，512 512一张 png 应用截图：480 * 800 5张 png 魅族 应用图标：16 16一张，512 512一张 png 应用截图：480 * 800 5张 png Oppo 应用图标：16 16一张，512 512一张 png 应用截图：480 * 800 5张 png Vivo 应用图标：16 16一张，512 512一张 png 应用截图：480 * 800 5张 png 锤子 应用图标：16 16一张，512 512一张 png 应用截图：480 * 800 5张 png","tags":[{"name":"Android","slug":"Android","permalink":"https:mubai.site/tags/Android/"}]},{"title":"TensorFlow入门","date":"2018-02-02T16:00:00.000Z","path":"2018-2-3-TensorFlow入门/","text":"MNIST机器学习入门MNIST:机器学习的入门，是一个入门级的计算机视觉数据集，包含了2部分： 手写的数字图片 数字图片对应的标签 MNIST数据集：官网地址是Yann LeCun’s website下载下来的数据集被分成了2部分：60000行的训练数据集(mnist.train)和10000行的测试数据集(mnist.test) 这么切分的好处在于：在机器学习模式设计时必须有一个单独的测试数据集不用与训练而是用来评估这个模型的性能，从而更加容易把设计的模型推广到其他数据集上(泛化) 参考链接 英文官方网站 TensorFlow 官方文档中文版 英文版GithHub仓库 中文版GithHub仓库","tags":[{"name":"机器学习","slug":"机器学习","permalink":"https:mubai.site/tags/机器学习/"}]},{"title":"Android仓库托管平台","date":"2018-01-31T16:00:00.000Z","path":"2018-2-1-Android仓库托管平台/","text":"Android Library的托管平台介绍 Android Studio是从build.gradle里面定义的Maven仓库服务器上下载library 在build.gradle中会看到 12345678910allprojects &#123; repositories &#123; jcenter()//使用Jcenter作为Maven mavenCentral()//使用mavenCentral作为Maven maven &#123;//自定义maven url &apos;https://maven.google.com/&apos; name &apos;Google&apos; &#125; &#125;&#125; 我们可以通过 Jcenter Jcenter是一个由bintray.com维护的Maven仓库 mavenCentral MavenCentral是由sonatype.org维护的Maven仓库 maven { url ‘自己的仓库服务器地址’ } 有时候会将library放在自己的服务器上，这时候就需要我们添加maven地址 但是一般来说我们只会使用Jcenter和mavenCentral，毕竟自己维护一个服务器地址成本较高，而且对于使用者来说他们只需要添加代码的依赖地址 实际上除了Maven仓库外还有另外一种仓库：Ivy仓库 Jcenter和mavenCentral比较两个仓库都具有相同的使命：提供Java或者Android的Library服务 最开始的时候，AndroidStudio选择MavenCentral作为默认仓库，后来由于MavenCentral的不友好，对于开发者上传Library很难，同时由于其他的种种原因，AndroidStudio决定把MavenCentral换成Jcenter * jcenter通过CDN发送library，开发者可以享受到更快的下载体验。 * jcenter是全世界最大的Java仓库，因此在Maven Central 上有的 在jcenter上也极有可能有。换句话说jcenter是Maven Central的超集。 * 上传library到仓库很简单，不需要像在 Maven Central上做很多复杂的事情 * 友好的用户界面 其他相关问题 如果要了解如何发布自己的library到Jcenter，可以查看发布Library到Jcenter 有时候我们通过Jcenter依赖Library的时候加载很慢，可以查看解决JCenter下载太慢的问题来解决","tags":[{"name":"Android","slug":"Android","permalink":"https:mubai.site/tags/Android/"}]},{"title":"项目发布到jcenter仓库","date":"2018-01-24T16:00:00.000Z","path":"2018-1-25-Jcenter /","text":"项目所需的步骤一、添加插件在项目目录的build.gradle 中的 dependencies 添加：12classpath &quot;com.jfrog.bintray.gradle:gradle-bintray-plugin:1.5&quot; classpath &apos;com.github.dcendents:android-maven-gradle-plugin:1.4.1&apos; 二、配置gradle同时在需要添加到jcenter的libary的build.gradle根目录添加：123apply plugin: &apos;com.github.dcendents.android-maven&apos; apply plugin: &apos;com.jfrog.bintray&apos;version = &quot;1.0.1&quot; //这里的version是可以更新的版本号* (1)在local.properties添加用户名和key1234bintray.user=openproject // your bintrayuser name bintray.apikey=****** // your bintray api key` (2)继续在根目录添加：123456def siteUrl = &apos;https://github.com/MoMuBai/Test&apos; // #修改# // 项目的主页地址，我这里是我的PickerView项目在github的链接地址 def gitUrl = &apos;https://github.com/MoMuBai/Test.git&apos; // #修改# // 项目 git 地址，我这里同样是用Github上的git地址 group = &quot;com.mubai&quot; // #修改# // 组名称 (3)打包javadocjar和sourcejar123456789101112131415161718192021222324252627282930install &#123; repositories.mavenInstaller &#123; // This generates POM.xml with proper parameters pom &#123; project &#123; packaging &apos;aar&apos; name &apos;Less Code For Android&apos; url siteUrl licenses &#123; license &#123; name &apos;The Apache Software License, Version 2.0&apos; url &apos;http://www.apache.org/licenses/LICENSE-2.0.txt&apos; &#125; &#125; developers &#123; developer &#123; id &apos;mubai&apos; name &apos;mubai.lzw&apos; email &apos;quickly520@126.com&apos; &#125; &#125; scm &#123; connection gitUrl developerConnection gitUrl url siteUrl &#125; &#125; &#125; &#125;&#125; (4)打包javadocjar和sourcejar12345678910111213141516task sourcesJar(type: Jar) &#123; from android.sourceSets.main.java.srcDirs classifier = &apos;sources&apos;&#125;task javadoc(type: Javadoc) &#123; source = android.sourceSets.main.java.srcDirs classpath += project.files(android.getBootClasspath().join(File.pathSeparator))&#125;task javadocJar(type: Jar, dependsOn: javadoc) &#123; classifier = &apos;javadoc&apos; from javadoc.destinationDir&#125;artifacts &#123; archives javadocJar archives sourcesJar&#125; (5)上传到Jcenter仓库 需要去从local.properties中读取123456789101112131415Properties properties = new Properties()properties.load(project.rootProject.file(&apos;local.properties&apos;).newDataInputStream())bintray &#123; user = properties.getProperty(&quot;bintray.user&quot;) key = properties.getProperty(&quot;bintray.apikey&quot;) configurations = [&apos;archives&apos;] pkg &#123; repo = &quot;maven&quot; name = &quot;test-library&quot; // project name in jcenter websiteUrl = siteUrl vcsUrl = gitUrl licenses = [&quot;Apache-2.0&quot;] publish = true &#125;&#125; 三、执行命令通过命令进入项目目录执行命令1234./gradlew javadocJar./gradlew sourcesJar./gradlew install./gradlew bintrayUpload Bintray所需的步骤一、注册账号也可以通过Git直接登录二、添加一个新的Repository(名字跟在gradle配置的一样)三、在gradle命令执行完成后可以到Bintray进行提交审核(一般几个小时)四、审核通过之后就可以进行依赖的添加使用了compile &#39;com.mubai:library:1.0.1&#39;","tags":[{"name":"Android","slug":"Android","permalink":"https:mubai.site/tags/Android/"}]},{"title":"Android反编译","date":"2018-01-17T16:00:00.000Z","path":"2018-1-18-反编译/","text":"","tags":[{"name":"Android","slug":"Android","permalink":"https:mubai.site/tags/Android/"}]},{"title":"Android屏幕适配","date":"2018-01-10T16:00:00.000Z","path":"2018-1-11-Android屏幕适配/","text":"实际上很早就想写关于Android屏幕适配的总结了，但是由于各种各样的理由推迟了 什么是屏幕适配屏幕适配即在不同分辨率、尺寸、比例的设备上显示达到一样的效果 为什么要屏幕适配由于Android系统的开放性，任何用户、开发者、OEM厂商、运营商都可以对Android进行定制，修改成他们想要的样子，这种情况下导致了Android系统的碎片化严重 碎片化：系统碎片化(小米MIUI、华为EMUI、魅族flyme)、屏幕大小碎片化(5.0、5.5、6.0)、屏幕分辨率碎片化(320x480、480x800、720x1280、1080x1920) 这里有Android碎片化的数据：戳这里 如何进行屏幕适配在屏幕适配开始前，我们需要对Android的一些屏幕相关单位有所了解 像素：单位px，屏幕上的点，我们看到的图像都是由一个个小点构成的 屏幕尺寸：屏幕上对角线的长度，单位是英寸，一英寸为2.54厘米，现在市场上常见的有4.7、5.0、5.5、6.0等尺寸的手机 屏幕分辨率：横纵方向上的像素点数，如1920*1080，即纵向上有1920个像素点，横向上有1080个像素点 屏幕每英寸点数：单位dpi，为屏幕分辨率/屏幕尺寸所得的值，如一个1920*1080的手机，它的纵向尺寸为3英寸，横向尺寸为5.3英寸，那么它的像素密度为1080/3=360dpi，屏幕分辨率越高，尺寸越小，那么它的像素密度就越高 屏幕像素密度：density = dpi/160 屏幕像素无关密度：单位dp或者是dip，与物流像素点无关，是Android特有的单位，是为了保证在不同屏幕像素密度的设备上显示相同的效果 屏幕独立比例像素：单位sp，类似dp，一般是用来设置文字大小 这里用张表格来各个单位之间的关系 密度类型 代表的分辨率（px） 屏幕每英寸点数（dpi） 屏幕密度（density） 换算（px/dp） 比例 低密度（ldpi） 240x320 120 0.75 1dp = 0.75px 3 中密度（mdpi） 320x480 160 1 1dp = 1px 4 高密度（hdpi） 480x800 240 1.5 1px = 1.5dp 6 超高密度（xhdpi） 720x1280 320 2 1dp = 2px 8 超超高密度（xxhdpi） 1080x1920 480 3 1dp = 3px 12 如何适配 参考链接 Android 屏幕适配：最全面的解决方案 Android屏幕适配全攻略(最权威的官方适配指导) Android 屏幕适配 Android官方提供的支持不同屏幕大小的全部方法","tags":[{"name":"Android","slug":"Android","permalink":"https:mubai.site/tags/Android/"}]},{"title":"阿里云大使","date":"2018-01-09T16:00:00.000Z","path":"2018-1-10-阿里云大使行走中/","text":"💰💰💰💰💰💰💰💰💰💰💰💰💰💰💰💰💰💰💰💰💰💰💰 满满的$$$镇楼 在使用阿里云提供的域名服务中偶然发现云大使这个组织，然后发现这是个让其他的人通过使用你的幸运券去购买阿里云产品，你就可以获得对应的返佣比例，最高可达30%(如被推荐的人新购买或者是升级了自己的域名服务。支付了10000元，则云大使就可以获得3000元的返佣) 说的简单点，云大使就是分享幸运券-&gt;坐等返佣的过程，通俗点就是个赚钱，钱，钱的过程，重要的话要说三遍 当然是要有人使用了你分享的幸运券的前提下 我们现在就来说说如何用云大使实现我们的目标：月入百万、荣登CEO、迎娶白富美我的幸运券 1.加入云大使首先需要你有阿里云的账号，然后你就可以通过云大使报名入口加入云大使 2.分享使用幸运券及好处 网页端：加入云大使后会对应的生成你的幸运券，然后你可以通过复制你的幸运券分享出去 App端：阿里云App-&gt;我的-&gt;推开奖励-&gt;分享全部产品幸运券然后就可以通过其他方式分享到支付宝、钉钉、微信、QQ等 3.使用幸运券 如何使用幸运券：其他人在选择阿里云产品-&gt;购买-&gt;确认订单的环节-&gt;使用云大使的幸运券-&gt;提交订单-&gt;完成支付，整个流程后即可认为幸运券被使用 使用幸运券的好处： 幸运券实际上是有优惠的，只是它的优惠金额是随机的 订单支付大于0元可参与抽奖 首购ecs大于1000元可参与抽奖 当前阿里云可以使用幸运券的产品共29款 4.坐等返佣18年1月返利新规【返佣率高达30%无封顶返利】 返利时间：一般情况下当月的奖励将会在下下月的20号左右返利，如1月月份推荐的返利将在18年3月20日左右发放，（一般情况下只会提前不会延后）返利将会发放到绑定的支付宝账号中 需要注意:要完成1实名认证-&gt;2.绑定支付宝-&gt;3.现金购云产品&gt;=100元(第3条在校学生通过学生认证除外)才能够完成返利提现 附上阿里云可以使用幸运券产品图(18年1月份新图)，总有一款适合你， 可以根据自己的需要选择云产品，使用我的幸运券来实现你的幸运产品 参考链接 大神引路–新手云大使入门导引","tags":[{"name":"闲文","slug":"闲文","permalink":"https:mubai.site/tags/闲文/"}]},{"title":"谈谈Android中的JNI和NDK","date":"2018-01-08T16:00:00.000Z","path":"2018-1-9-Android JNI和NDK/","text":"最近发现光看源码的过程是在太枯燥了，准备开始以博客的形式来解读源码，一方面是为了能让自己更好的巩固知识点，一方面是为了能展(zhuang)现(bi)下自己 今天要来说说JNI和NDK，最近发现使用NDK开发的需求正在不断增加啊，不管是为了能与本地的代码交互或者是为了更好的体验(使用C、C++的so)都在不断的促使我们使用NDK。 什么是JNI 定义：JNI(Java Native Interface) Java本地接口 作用：我们可以通过JNI来使Java能与本地的其他语言(C、C++)进行交互 优势：实际开发中，有时候会遇到一些性能要求的功能，而Java代码在处理性能方面远远不如C、C++，所以我们可以通过C、C++开发功能，然后通过JNI来使得Java代码与C、C++代码的交互(很多人都会举例一大堆JNI的应用场景，实际上不管是什么使用场景都是基于Java代码和其他语言的交互)，所以说JNI可以扩展JVM的能力，可以进行驱动开发，复用已有的一些开源库，而且一些产品的核心技术一般也是采用JNI开发，不易被破解 劣势：尽管JNI带来了很多的使用场景，提高了与本地语言交互的能力，但是它也带来了一些不足，我们都知道Java火爆的原因之一就是它的跨平台，但是现在JNI与本地的语言的交互导致我们需要为不同的系统的本地语言来实现不同的代码，削弱了Java的跨平台性，而且有一点就是通过JNI调用还是会比C、C++编写的原生应用要慢一点 什么是NDK 定义：NDK(Native Development Kit)，Google对其定义为一套允许您使用原生代码语言(例如C和C++)实现部分应用的工具集 作用：能让我们快速的开发C、C++的so动态库，并且将so和应用一起打包成APK JNI和NDK的关系NDK为我们生成了C、C++的so动态库，JNI又提供了Java代码和其他语言(C、C++)交互的能力，这两者之间可以实现互补，可以说JNI是目的，而NDK是实现JNI的手段，通过NDK来实现JNI的功能，最后达到“Java+C”的开发方式 NDK的使用 开发环境：Mac OS 10.13.2 + Android Studio 3.0 NDK的添加配置打开Preferences-&gt;Appearance&amp;Behavior-&gt;SystemSettings-&gt;AndroidSDK-&gt;SDKTools勾选NDK下载 等待安装完毕 我这边已经安装完毕可以在local.properties中看到 这些是Android Studio自动生成的 12ndk.dir=/Users/lzw/Library/Android/sdk/ndk-bundlesdk.dir=/Users/lzw/Library/Android/sdk 项目中添加JNI支持 我不添加好像也可以… 在gradle.properties中添加 1android.useDeprecatedNdk=true 然后在app的build.gradle中添加 12345678910111213141516171819202122232425262728293031323334353637apply plugin: &apos;com.android.application&apos;android &#123; compileSdkVersion 23 buildToolsVersion &quot;26.0.2&quot; defaultConfig &#123; minSdkVersion 15 targetSdkVersion 23 versionCode 1 versionName &quot;1.0&quot; testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot; ndk &#123; //要支持的CPU都有哪些，可以自己选择添加 abiFilters &quot;armeabi-v7a&quot;,&quot;armeabi&quot;,&quot;arm64-v8a&quot;,&quot;mips&quot;,&quot;mips64&quot; //生成的so名称 moduleName &quot;MuBaiYs7&quot; &#125; &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; &#125; &#125;&#125;dependencies &#123; compile fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;]) compile &apos;com.android.support:appcompat-v7:23.1.0&apos; testCompile &apos;junit:junit:4.12&apos;&#125; 重点在于添加了注释的那2句话： 项目中添加Java访问C的接口类123456789101112131415public class AndroidJni &#123; /** * 要与C层交互的方法 * * @return */ public static native String getString(); /** * 加载so，要跟build.gradle中自己定义so名称保持一致 */ static &#123; System.loadLibrary(&quot;MuBaiYs7&quot;); &#125;&#125; 然后我们会根据方法function Java_com_lzw_ys7_jni_AndroidJni_getString```创建方法，然后Studio会为我们在根目录中生成一个cpp的文件夹，里面有一个.c文件1234![C层中的方法](http://p0sgkjh7x.bkt.clouddn.com/D618011D-DB8B-4A1A-92F5-2702CEC7FB76.png)这个文件的名称是可以自己修改的，我们查看这个文件可以发现，它就提供了一个方法，返回一个字符串，这边我们让它返回&quot;MuBaiYs7Jni&quot; #include &lt;jni.h&gt; JNIEXPORT jstring JNICALLJava_com_lzw_ys7_jni_AndroidJni_getString(JNIEnv *env, jobject instance) { return (*env)-&gt;NewStringUTF(env, &quot;MuBaiYs7Jni&quot;); } ` 调用Java代码 调用Jni的方法 运行成功后我们可以看到，说明我们调用成功 得到so文件 这边我们是自己使用项目中的C方法，但是实际项目中很多时候都是把方法封装成so文件进行开发，类似于jar包和arr包 我们这边直接切换项目的展示形式：Android-&gt;Project然后查看build-&gt;intermediates-&gt;ndk-&gt;debug-&gt;lib 这边的libMuBaiYs7.so就是我们根据项目中的jnitest.c文件封装出来的so文件 我们可以把这里的so文件复制到其他项目中的lib或者是jniLibs文件中进行使用 需要注意的是不能单独复制so文件，要将各个CPU对应的so文件分别复制出来到文件中 这边只是NDK和Jni的入门使用，关于Jni常用的类型和方法会在其他的时间进行学习介绍 未完待续 参考链接： Android NDK Android JNI编程—JNI基础 Android NDK开发：JNI基础篇 Android Studio jni开发入门——看我就够了！","tags":[{"name":"Android","slug":"Android","permalink":"https:mubai.site/tags/Android/"}]},{"title":"从比特币中浅谈区块链技术","date":"2018-01-04T16:00:00.000Z","path":"2018-1-5-浅谈区块链技术/","text":"昨天的CPIH(中国医药控股有限公司)疯狂的涨幅566%，瞬间看懵了，有消息称是因为被收购了才导致的暴涨，(到后来已经慢慢下跌，最后收盘时涨幅137%），说实话真的是跟过山车一样，心脏病都能给你吓出来😶 比特币 比特币(bitcoin)的概念是中本聪在09年提出的，它是数字货币 17年的比特币 比特币就跟过山车一样 我们想通过比特币的交易来谈谈什么是区块链 区块链来自维基百科对区块链的定义 区块链：(英语：blockchain)是用分布式数据库识别、传播和记载信息的智能化对等网络，也称为价值互联网，中本聪在08年与《比特币白皮书》中提出了”区块链”概念，并在09年创立了比特币社会网络，开发出第一个区块，即”创世区块”。 区块链的本质是解决信任问题，降低信任成本的技术方案，目的是为了去中心化，去信用中介，它的核心是一堆个体，是通过去中心化和去信任的方式集体维护一个可靠数据库(加密安全性)，简单来说就是分布式记账，这个账本不可撤销，不能修改，它实际上也是比特币的底层技术。 任意节点损坏，不会影响其他节点(损坏的节点不需要理他) 大数据：数据的来源维度多，不是数据多 共识机制：所有人都是认可的 大数据是牺牲一致性来换取可用性和分区容忍性的，而区块链却先优先保证一致性 去中心化和共识机制的矛盾，需要注意平衡 区块链的发展比特币 （1.0）数字资产和智能合约 （2.0）区块链大社会 (3.0)ICO金融新能源模式智能社区供应链管理区块链的问题性能和容量问题： 去中心化和共识机制的矛盾 账本存储容量和处理性能的矛盾 安全性问题 51%攻击 私钥与终端安全 共识机制的安全 尚未建议统一的标准衍生市场混乱从企业的角度： 没有找到大的落地应用场景 区块链急速目前不够成熟，无法支撑某些业务领域 行业人才匮乏，一般公司无法组建区块链技术团队开发产品 公众的认知相对较少，接受度不高 高能耗 数据库存储空间 处理大规模交易的抗压能力","tags":[{"name":"闲文","slug":"闲文","permalink":"https:mubai.site/tags/闲文/"}]},{"title":"AttachInfo的初步了解和解析","date":"2017-12-29T16:00:00.000Z","path":"2017-12-30-AttachInfo的初步了解和解析/","text":"1234567891011121314151617181920212223242526272829View&#123; ... /** * A set of information given to a view when it is attached to its parent window. */ final static class AttachInfo &#123; interface Callbacks &#123; void playSoundEffect(int effectId); boolean performHapticFeedback(int effectId, boolean always); &#125; static class InvalidateInfo &#123; ... &#125; final IWindowSession mSession; final IWindow mWindow; final IBinder mWindowToken; final Display mDisplay; final Callbacks mRootCallbacks; ... &#125; ...&#125; View的显示过程是需要依附在Window窗口上的，而View和Window的关系是通过AttachInfo来管理的，但是实际上这个类我们使用的很少，它是View的内部类而且不是公开的，我们一般只有在ViewRootImpl等类中使用到 我们可以通过AttachInfo来获取当前View依附的是哪个Window窗口","tags":[{"name":"Android","slug":"Android","permalink":"https:mubai.site/tags/Android/"}]},{"title":"从项目需求到PopupWindow在到Window的过程浅析","date":"2017-12-26T16:00:00.000Z","path":"2017-12-27-从PopupWindow到Window的过程浅析/","text":"引言 项目中有这么个需求，底部是5个Tab选项，中间那个是一个圆形的高位按钮选项，点击中间选项会从底部弹出个布局，并且这个布局的视觉效果是要在这个圆形选项的底部…这么说有点混乱，来张效果图看看 点击场景后 实现过程 看到这2个设计图的时候第一想法是底部3个tab选项然后点击场景后弹出个PopupWindow，因为用过而且用的场景还挺多的。 然后啪啦啪啦的一堆代码出现了，下面的3个tab选项用简单的实现了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;#4FC3F3&quot; android:orientation=&quot;vertical&quot;&gt; &lt;RelativeLayout android:id=&quot;@+id/layout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;50dp&quot; android:layout_alignParentBottom=&quot;true&quot; android:background=&quot;#D8D8D8&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;TextView android:layout_width=&quot;50dp&quot; android:layout_height=&quot;40dp&quot; android:layout_centerVertical=&quot;true&quot; android:layout_marginLeft=&quot;15dp&quot; android:background=&quot;#9F79EE&quot; android:gravity=&quot;center&quot; android:text=&quot;智控&quot; /&gt; &lt;TextView android:layout_width=&quot;50dp&quot; android:layout_height=&quot;40dp&quot; android:layout_alignParentRight=&quot;true&quot; android:layout_centerVertical=&quot;true&quot; android:layout_marginRight=&quot;15dp&quot; android:background=&quot;#9F79EE&quot; android:gravity=&quot;center&quot; android:text=&quot;个人&quot; /&gt; &lt;/RelativeLayout&gt; &lt;TextView android:id=&quot;@+id/noun_text&quot; android:layout_width=&quot;60dp&quot; android:layout_height=&quot;60dp&quot; android:layout_alignParentBottom=&quot;true&quot; android:layout_centerHorizontal=&quot;true&quot; android:background=&quot;#FFFFFF&quot; android:gravity=&quot;center&quot; android:text=&quot;场景&quot; /&gt;&lt;/RelativeLayout&gt; 大概的效果就是这样的，只是个初步的布局，毕竟这边是为了演示效果 然后添加中间场景的点击事件，刚也说了想用到PopupWindow从底部弹出，然后就开始去实现设计图的效果 下面就是PopupWindow的实现 1234567891011121314151617181920212223242526272829private PopupWindow mPopupWindow;/** * PopupWindow的View */private View popView;/** *场景TextView */private TextView nounText;/** *底部Layout */private LinearLayout layout;@Overrideprotected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_popup); nounText = (TextView) findViewById(R.id.noun_text); layout = (LinearLayout) findViewById(R.id.layout); popView = LayoutInflater.from(this).inflate(R.layout.popup_layout, null); mPopupWindow = new PopupWindow(popView, WindowManager.LayoutParams.MATCH_PARENT, WindowManager.LayoutParams.WRAP_CONTENT); mPopupWindow.setOutsideTouchable(true); nounText.setOnClickListener(v -&gt; &#123; mPopupWindow.showAtLocation(nounText, Gravity.CENTER_HORIZONTAL | Gravity.BOTTOM, 0, layout.getHeight()); &#125;);&#125; 然而想法是美好的，但是现实往往是残酷的… 最后的实现效果却是这样的 对比下这2个图 咋一看是没有问题，但是实际上中间的那个场景选项并没有盖在底部的那个popView上面，当时的想法就是让设计改下(😶，然而就是想想而已) 后来开始思考如果让这个PopView在场景的下面，当时有2个思路： 1.通过在PopView的底部中间加个半圆形衔接下面的场景选项，营造出遮盖的视觉效果 2.因为PopupWindow是需要依附在某个组件上的，想能不能再场景的底层在添加个组件(被场景选项遮盖着)，然后让PopupWindow去依附这个看不见的组件 有了思路就开始动手试试看，然而现实是这2个都不能很好实现要的效果，第一个是因为添加半圆形的时候位置很容易出错，特别是适配的时候，第二个思路的结果发现结果还是跟原来的一样，尽管PopupWindow依附的是在场景下的组件，但是效果还是跟依附场景的时候一样😓… Why(当时想法只剩下这个了…) 要想知道原因，我们就要从PopupWindow的内部实现方法来分析 PopupWindow内部方法的初步分析 PopupWindow它不是一个View或者是ViewGroup，所以在使用的时候需要的传入我们的布局View,这边需要注意的是它既不是View也不是ViewGroup，那么它是什么呢？ PopupWindow的创建 1234567private PopupWindow mPopupWindow;/** * PopupWindow的View */private View popView;popView = LayoutInflater.from(this).inflate(R.layout.popup_layout, null);mPopupWindow = new PopupWindow(popView, WindowManager.LayoutParams.MATCH_PARENT, WindowManager.LayoutParams.WRAP_CONTENT); 代码中创建PopupWindow 123456789101112131415161718public PopupWindow(View contentView, int width, int height, boolean focusable) &#123; /** * 如果contentView不为空，通过contentView获取WindowManager对象 * 所以这边我们可以想到了window窗口这个对象，进而popupWindow可能跟window有关，实际上从它的命名也能猜到了 */ if (contentView != null) &#123; mContext = contentView.getContext(); mWindowManager = (WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE); &#125; //设置contentView setContentView(contentView); //设置宽度 setWidth(width); //设置高度 setHeight(height); //默认focusable为false setFocusable(focusable);&#125; 创建的过程实际上很简单,通过PopupWindow的构造方法传入需要的contentView、宽、高就能够得到一个PopupWindow对象，但是我们刚也说了它不是View也不是ViewGroup那它是如何能够显示的呢 在项目使用PopupWindow的时候是通过showAtLocation方法来设置具体的显示位置的 1mPopupWindow.showAtLocation(nounText, Gravity.CENTER_HORIZONTAL | Gravity.BOTTOM, 0, layout.getHeight()); PopupWindow还有其他的设置显示的方法，这里我们就不具体的说明，但是实际上最后都是需要用到下面这几个方法 12345678//获取WindowManager的布局参数final WindowManager.LayoutParams p = createPopupLayoutParams(anchor.getWindowToken());//准备PoppreparePopup(p);//引用PopinvokePopup(p); 所以我们最需要关注的还是这几个方法的实现过程 返回Window的布局参数WindowManager.LayoutParams 12345private WindowManager.LayoutParams createPopupLayoutParams(IBinder token) &#123; final WindowManager.LayoutParams p = new WindowManager.LayoutParams(); ...//这边省略了一些关于设置布局参数p的方法 return p;&#125; 准备PopupWindow 1234567891011121314151617private void preparePopup(WindowManager.LayoutParams p) &#123; ... if (mDecorView != null) &#123; mDecorView.cancelTransitions(); &#125; if (mBackground != null) &#123;//如果mBackground不为空即设置了popupWindow的背景图片 mBackgroundView = createBackgroundView(mContentView); mBackgroundView.setBackground(mBackground); &#125; else &#123;//如果没有设置背景图片的话，让contentView==背景View mBackgroundView = mContentView; &#125; mDecorView = createDecorView(mBackgroundView); mBackgroundView.setElevation(mElevation); p.setSurfaceInsets(mBackgroundView, true /*manual*/, true /*preservePrevious*/); ...&#125; 引用PopupWindow 12345678910111213141516private void invokePopup(WindowManager.LayoutParams p) &#123; if (mContext != null) &#123; p.packageName = mContext.getPackageName(); &#125; final PopupDecorView decorView = mDecorView; decorView.setFitsSystemWindows(mLayoutInsetDecor); setLayoutDirectionFromAnchor(); //这边通过addView方法添加我们的PopupView mWindowManager.addView(decorView, p); if (mEnterTransition != null) &#123; decorView.requestEnterTransition(mEnterTransition); &#125;&#125; 通过WindowManager的addView()把我们的PopupDecorView以及布局的参数P添加到Window上 未完待续… PopupWindow延伸问题: 这里会添加一些popupWindow常见的问题，陆续更新中… isShowing失效问题 在实现popupWindow的过程中，点击按错出现popupWindow，然后再次点击按钮的时候，需要把popupWindow dismiss掉，实现的方法为判断是否显示isShowing，为false才让popupWindow显示 123if (!popupWindow.isShowing()) &#123; popupWindow.showAsDropDown(view); &#125; 但是发现不管怎么样，**isShowing**一直返回为**false**，所以每次点击按钮popupWindow都会重新显示，断点查看后，发现每次点击出现popupWindow的按钮的时候都会去执行dismiss方法 1234567891011121314151617/** * 这里一直返回为false */public boolean isShowing() &#123; return mIsShowing; &#125;public void dismiss() &#123; if (!isShowing() || isTransitioningToDismiss()) &#123; return; &#125; ...省略 mIsShowing = false;//每次点击都会改变mIsShowing为false ...省略 &#125; 然后又发现代码中有这么一句话 1popupWindowLogin.setOutsideTouchable(true); 这是为了能实现点击popupWindow外部能消失的效果，然后这里突然想到我们点击按钮的时候也属于点击popupWindow外部，所以这里先调用了**dismiss**方法改变了我们的**mIsShowing**的值 知道了具体的原因后，我们发现这里主要是要让按钮的点击变成popupWindow的点击效果，所以我们只要让popupWindow在显示的时候把焦点先抢过来，然后我们点击按钮的时候，实际上就是点击popupWindow，想起来以前焦点问题的时候有这么一句话： 1popupWindowLogin.setFocusable(true); 将焦点设置给popupWindow，然后我们再次点击按钮的时候由于焦点在popupWindow上，所以我们就可以正常的获取**mIsShowing**的值，在来执行我们的判断了。 &gt; 加上代码了试了下效果，果然可行，Nice！","tags":[{"name":"Android","slug":"Android","permalink":"https:mubai.site/tags/Android/"}]},{"title":"LeakCancary的使用和原理","date":"2017-12-22T16:00:00.000Z","path":"2017-12-23-LeakCancary的使用和原理/","text":"目录： 为什么会有LeakCancary 什么是LeakCancary LeakCancary的使用 LeakCancary的实现过程 Why LeakCancary Square在开源项目LeakCancary的前言就提到了 “A small leak will sink a great ship” 我们可以翻译过来用一句名言来表示：“千里之堤溃于蚁穴” 1234java.lang.OutOfMemoryError at android.graphics.Bitmap.nativeCreate(Bitmap.java:-2) at android.graphics.Bitmap.createBitmap(Bitmap.java:689) at com.squareup.ui.SignView.createSignatureBitmap(SignView.java:121) OOM 项目中最让人头疼的一个异常，它不像一些其他异常很显示的给你指出并且容易解决，它的产生原因一般都是内存对象的不正确使用导致GC无法正常的回收对象，进而产生内存泄露，让系统的内存空间逐渐的不够，然后导致内存溢出。 Square公司有篇文章说过他们在使用Bitmap进行签名页面进行绘制过程中，创建的bitmap对象经常性的产生OOM。为了解决这个问题，Square做出了很多的对策，包括： 使用Bitmap.Config.ALPHA_8节省内存 手动捕获OOM，调用GC 但是实际上效果并不好，后来他们发现是方向错了，当系统中分配的内存已经不够了，这时候OOM可以发生在任何的地方，特别是一些大对象的使用，比如Bitmap的创建。OOM只是表象，更深层次的问题可能是：内存泄露 但是在原来的时候排查内存泄露是个全手工的过程,为了解决这个问题，LeakCancary出现了。 What LeakCancaryLeakCancary是Square公司推出的一款Java和Android内存泄露检查框架，如果检测到某个地方产生了内存泄露，LeakCancary会生成一个显示的通知，并且在Locat会有相应的log日志提醒，通过显示的通知和log日志我们可以对内存泄露进行准确的定位并去解决它。 Use LeakCancary LeakCancary显示通知图镇楼 关于LeakCancary的开源和使用，Square最初的目的是为了能更好的对app进行内存泄露的检测，而且是为了能更简的入手，所以它的使用就不会很复杂，实际上用法也是很简单： 在build.gradle添加引用： 12debugCompile &apos;com.squareup.leakcanary:leakcanary-android:1.5.4&apos;releaseCompile &apos;com.squareup.leakcanary:leakcanary-android-no-op:1.5.4&apos; 当前最新版本为1.5.4，可以根据git上的最新版本进行升级 在自定义继承Application中添加RefWatcher 12345678910111213141516171819public class Ys7App extends Application &#123; /** * RefWatcher对象 */ private RefWatcher refWatcher; public static RefWatcher getRefWatcher(Context context) &#123; Ys7App application = (Ys7App) context.getApplicationContext(); return application.refWatcher; &#125; @Override public void onCreate() &#123; super.onCreate(); refWatcher = LeakCanary.install(this); &#125;&#125; 不要忘记把自定义继承的12345678然后我们就可以去写**内存泄露**了(咳咳，说错了，是去发现内存泄露)说个很常见的内存泄露问题：*关于Context对象的使用*项目中很多地方都需要用到**Context**对象,有时候我们会直接使用**Activity**的**Context**对象，有时候会使用全局的**Context**对象。关于这个我们要说说关于在**Activity**中使用单例模式的问题，很多时候我们需要去维护一个全局的方法，很容易想到用单例模式，它也是设计模式中最简单易懂的一个，但是它如果使用不好就会产生**内存泄露**问题。* TextView的一个单例实现类 public class TextHelper { private static TextHelper mTextHelper; private Context mContext; private TextView mTextView; private TextHelper(Context context) { this.mContext = context; } public static TextHelper getTextHelper(Context context) { if (null == mTextHelper) { mTextHelper = new TextHelper(context); } return mTextHelper; } /** * 设置TextView的大小和颜色 * * @param textView */ @SuppressLint(&quot;NewApi&quot;) public void setText(TextView textView) { this.mTextView = textView; this.mTextView.setTextSize(20f); this.mTextView.setTextColor(mContext.getColor(R.color.black)); } } 123&gt; 这里因为我们需要引用到资源文件中的color文件，所以需要个**Context**对象* 在Activity中使用： TextHelper.getTextHelper(SDKActivity.this).setText(nameText); 1234567891011121314151617181920&gt; 这里我们使用了当前**Activity**的**Context**对象这里因为在**Activity**中使用了当前的**Context**对象，看上去没什么问题，但是如果我们退出当前Activity后(引入了**LeakCancary**的前提)，会在通知栏看到产生了个内存泄露通知&lt;img src=&quot;http://p0sgkjh7x.bkt.clouddn.com/D879CC01A4E508F2835F89036A03A0A6.jpg&quot; height=&quot;250&quot; width=&quot;150&quot;/&gt;然后我们通过查看**Leaks**中的列表问题&lt;img src=&quot;http://p0sgkjh7x.bkt.clouddn.com/F6A127ED4F1BAA1DFD5CE4F6B3C8012A.jpg&quot; height=&quot;250&quot; width=&quot;150&quot;/&gt;&gt; Leaks:由于App运行中产生了内存泄露然后显示在手机上，在这边是一个内存泄露的问题列表，然后我们可以通过查看每一项进行问题的查看&lt;img src=&quot;http://p0sgkjh7x.bkt.clouddn.com/94088C38003714DBF648267A164FF6B4.jpg&quot; height=&quot;250 &quot; width=&quot;150&quot; /&gt;这边就是我们通过leaked5.8查看的具体问题，可以看到Leaks已经帮我们把内存泄露的地方指出来了，这是因为我们的**Activity**在退出后它的**Context**对象被单例模式中的方法持有 着，但是**Activity**已经不存在了，这里就产生了内存泄露。&gt; 实际上这是个很简单但是又很容易犯的问题&gt; &gt; 同时我们也可以通过点击Leaks边上的**+**来进行更多信息的查看所以我们这里的话要解决这个内存泄露就要传入一个全局的**Context**对象 TextHelper.getTextHelper(Application.getInstance()).setText(nameText); 1或者是直接在单例模式中直接获取全局的**Context**对象 public class TextHelper { private static TextHelper mTextHelper; private Context mContext; private TextView mTextView; private TextHelper(Context context) { this.mContext = Application.getInstance(); } public static TextHelper getTextHelper() { if (null == mTextHelper) { mTextHelper = new TextHelper(); } return mTextHelper; } /** * 设置TextView的大小和颜色 * * @param textView */ @SuppressLint(&quot;NewApi&quot;) public void setText(TextView textView) { this.mTextView = textView; this.mTextView.setTextSize(20f); this.mTextView.setTextColor(mContext.getColor(R.color.black)); } } 12345678910这里就能避免由于**Context**对象的被持有导致的**内存泄露**。&gt; 实际上我们项目开发过程中会或多或少的产生**内存泄露**，这里只是举了一个简单的例子，我们只能通过去发现然后排查解决。#### Behind LeakCancary&gt; 在使用框架的同时也要关注下背后的实现过程和原理&gt; 我们通过对源码进行一步步的分解* 返回**RefWatcher**的过程 private RefWatcher refWatcher;refWatcher = LeakCanary.install(this); 1&gt; 通过**install()**方法 public static RefWatcher install(Application application) { return ((AndroidRefWatcherBuilder)refWatcher(application).listenerServiceClass(DisplayLeakService.class).excludedRefs(AndroidExcludedRefs.createAppDefaults().build())).buildAndInstall(); } 1&gt; 继续对**buildAndInstall()**进行分析 public RefWatcher buildAndInstall() { RefWatcher refWatcher = this.build(); if(refWatcher != RefWatcher.DISABLED) { LeakCanary.enableDisplayLeakActivity(this.context); ActivityRefWatcher.install((Application)this.context, refWatcher); } return refWatcher; } 1&gt; 在这里会返回一个**AndroidRefWatcher**，所以我们在对**Activity**进行内存泄露检查的时候，不需要专门添加代码，这里的**AndroidRefWatcher**会自动的帮我们进行检查 public final class ActivityRefWatcher { private final ActivityLifecycleCallbacks lifecycleCallbacks = new ActivityLifecycleCallbacks() { public void onActivityCreated(Activity activity, Bundle savedInstanceState) { } public void onActivityStarted(Activity activity) { } public void onActivityResumed(Activity activity) { } public void onActivityPaused(Activity activity) { } public void onActivityStopped(Activity activity) { } public void onActivitySaveInstanceState(Activity activity, Bundle outState) { } public void onActivityDestroyed(Activity activity) { //调用ActivityRefWatcher的watch方法 ActivityRefWatcher.this.onActivityDestroyed(activity); } }; } 123&gt; 在**ActivityRefWatcher**中我们发现会有关于**Activity**生命周期的回调监听并且在**onDestroy()**中会去添加**ActivityRefWatcher**的**watch**方法，但是这里也需要注意的是**registerActivityLifecycleCallbacks()**是在Api14以后才添加的方法，所以如果要在Api14以前检测就需要自己去重写onDestory并在里面添加RefWatcher.watch()方法如果是在**Fragment**中需要检查内存泄露情况的话需要我们自己实现**RefWatcher**的**watch**方法 public class BaseFragment extends Fragment { @Override public void onDestroy() { super.onDestroy(); //返回一个RefWatcher对象 RefWatcher refWatcher = Ys7App.getRefWatcher(getActivity()); refWatcher.watch(this); } } 12345&gt; 在这里有个疑问，为什么**Square**公司在设计**LeakCancary**的时候，考虑到了**Activity**，添加了对应的**ActivityRefWatcher**，但是对于碎片**Fragment**并没有去设计对应的**FragmentRefWatcher**方法,不知道是因为Fragment的生命周期过多还是其他的原因，也许我们可以自己根据**ActivityRefWatcher**的实现方法设计一套自己的**FragmentRefWatcher**，先留个想法...* RefWatcher是如何能够对内存泄露进行检测的通过观察RefWatcher的watch()方法 public void watch(Object watchedReference, String referenceName) {if(this != DISABLED) {…long watchStartNanoTime = System.nanoTime();String key = UUID.randomUUID().toString();this.retainedKeys.add(key);//创建一个KeyedWeakReference弱引用对象KeyedWeakReference reference = new KeyedWeakReference(watchedReference, key, referenceName, this.queue);this.ensureGoneAsync(watchStartNanoTime, reference);}} 1这里创建了一个**KeyedWeakReference**对象，这是个弱引用的对象 private void ensureGoneAsync(final long watchStartNanoTime, final KeyedWeakReference reference) {//执行操作，检查弱引用对象是否被清除this.watchExecutor.execute(new Retryable() { public Result run() { return RefWatcher.this.ensureGone(reference, watchStartNanoTime); }});} Result ensureGone(KeyedWeakReference reference, long watchStartNanoTime) {…if(this.debuggerControl.isDebuggerAttached()) { return Result.RETRY;} else if(this.gone(reference)) { return Result.DONE;} else { //手动调用GC this.gcTrigger.runGc(); this.removeWeaklyReachableReferences(); //如果弱引用对象还存在，则说明内存泄露了，生成hprof文件 if(!this.gone(reference)) { File heapDumpFile = this.heapDumper.dumpHeap(); … this.heapdumpListener.analyze(new HeapDump(heapDumpFile, reference.key, reference.name, this.excludedRefs, watchDurationMs, gcDurationMs, heapDumpDurationMs)); } } return Result.DONE;}//retainedKeys中是否包含弱引用对象的keyprivate boolean gone(KeyedWeakReference reference) { return !this.retainedKeys.contains(reference.key); }} 12在**WatchExector**的后台线程中执行检查弱引用对象是否被清除，如果没有清除，则调用一次GC，(这边能够检查弱引用对象还是根据**KeyedWeakReference**是以key-value形式存在的对象)如果弱引用对象没有被清除，则说明内存泄露了，系统就导出hprof文件,保存在app系统目录下 final class KeyedWeakReference extends WeakReference { //key-value形式存在 public final String key; public final String name; KeyedWeakReference(Object referent, String key, String name, ReferenceQueue&lt;Object&gt; referenceQueue) { super(Preconditions.checkNotNull(referent, &quot;referent&quot;), ... } ` 结论根据Square公司的数据说明他们在使用了LeakCancary后，减少了94%由OOM导致的cash。","tags":[{"name":"Android","slug":"Android","permalink":"https:mubai.site/tags/Android/"}]},{"title":"2017年年度总结+2018年目标展望","date":"2017-12-21T16:00:00.000Z","path":"2017-12-22-2017年年度总结/","text":"2017年转眼也只剩下几天了，想想是该对自己的一年进行个总结了，还有对2018年进行一个延伸。 话说2017年感觉自己过得有点乱，想来最多的原因还是没有一个很好的规划 2017年的自己可以总结为：工作、技术学习、业务学习、其他业余学习 工作 工作是主要的重点，毕竟作为一名公司人，上班才是最重要的一个环节 经纪通： 经纪通App是一款经纪人联动软件，支持在线报备客户、跟踪客户进度，坚持三天结佣、七天到账，让天下没有难卖的房 未公开内容… 筑家易： 筑家易App提供全新的购房体验，充分考虑到投资、自住、置换以及家装家居等需求，致力构建从房到家的移动互联网的产业链平台 未公开内容… 中策通： 中策通App是基于经纪通延伸出来的提供给第三方使用的产品 未公开内容… 经纪通重构： 主要是重构老版经纪通的代码，原有的项目代码结构混乱，耦合性太高 未公开内容… 楼掌柜分销： 楼掌柜分销是房产分销App，提供房产信息联动自由经纪人和企业用户，包括佣金结佣、房贷计算器、客户报备等 未公开内容… 工作总结：17年中主要是负责了5个App的功能迭代和产品优化，整个开发过程中尽管磕磕碰碰遇到了不同的问题，但是总体上来说还是朝着一个向上的趋势不断的进行着，而且最重要的是在问题中成长，一个问题的产生往往代表着自己某块知识点的缺失，解决问题的过程就是补充知识的过程，所以说整个17年工作中还是收获很大。 技术学习 作为一名软件开发人员(码农)，不断学习是必须的，不管是为了更好的工作还是更进一步的成长,下面是17年学习的语言，有些是有了初步的接入项目中使用，有些还是停留在学习中 Kotlin Kotlin是一个基于JVM的新的编程语言，由JetBrains开发，已正式成为Android官方支持开发语言。 楼掌柜分销App中用Kotlin语言开发 其他项目中简单的页面初步使用Kotlin进行开发 RxJava+RxAndroid 实现异步操作的库 筑家易App利用RxJava+RxAndroid封装网络请求框架 Python 大数据、机器学习的兴起，导致Python语言一度成为热门，而且Python入门简单、易读、易维护的风格更加受到开发者的欢迎和使用 利用Python获取最近天气情况 利用Python实现从网络获取图片并保存到本地 R语言 R 用于统计分析、绘图的语言和操作环境，R是属于GNU系统的一个自由、免费、源代码开放的软件，它是一个用于统计计算和统计制图的优秀工具 目前正处于学习中，后期可以使用R进行数据的统计分析 React Native Facebook推出的跨平台移动应用开发框架，使用Jsx、Css来开发移动应用支持iOS和Android。 目前关于React Native还停留在学习的阶段，后续学习更多后会在项目中接入使用 Groovy Groovy是一种基于JVM(Java虚拟机)的敏捷开发语言，它结合了Python、Ruby和Smalltalk的许多强大的特性,能够和Java代码很好的结合。 build.gradle中的多渠道打包 apk批量上传 利用Git+Jekyll搭建个人博客 写个人博客不仅仅是展示自我的时候，更是反问自己和提高自己的机会 通过git+jekyll初步搭建 使用jekyll的theme来使得博客更加人性化 陆陆续续维护个人博客20多篇 技术学习总结17年接触了很多的新技术，一些是新的语言，一些是项目中可以用到的新技术，在使用新技术的过程中发现了很多的问题，通过资料和文档一个个都解决了，解决的过程更是对新技术的进一步学习，总体来说新技术的学习才是避免自己不被淘汰的原因 业务学习 励志成为全栈，不能只会技术，业务方面也要去学习和了解 新房产业务 新房产业务既从线下转到线上在到线上转到线下最后是线上线下，形成一个闭环，基于移动互联网和大数据给房产服务形成一个完整的体系结构，原有的线下销售转到线上进行，线上的虚拟服务在到线下的真实服务最后到线上线下的的结合服务 CRM业务 CRM,既客户关系管理系统，是企业为提高核心竞争力，利用相应的信息技术以及互联网技术来协调企业与顾客之间在销售、营销和服务上的交互，从而提升其管理方式，向客户提高创新式的个性化的客户交互和服务的过程 业务学习总结一个开发不能只满足与自己的代码，要去兼顾业务方面的学，而且更重要的是要去学习业务的流程这样才能更好的开发出稳定、优秀的产品。最主要的是了解业务后能对自己的产品产生更多的情感，能对产品开发投入更多的精力，所以说一个开发学习业务是一个很重要的环节 其他业余学习 面对日涨愈高的房价，单靠工资想买得起房子真的很难 理财 理财包括：基金、股票、黄金、买房、p2p等 基金 股票 黄金 买房 p2p 新媒体 新媒体作为一种新的媒体形态，是相对于报刊、广播、电视等传统媒体以后发展起来的，通过互联网、无线通信网、有限网等渠道以及电脑、手机、数字电视剧等终端，向用户提供信息和娱乐的传播形态和媒体形态。 个人公众号 个人博客 业余学习总结业余学习一方面是为了提高自己的生活质量，一方面是为了扩充自己的知识面 2018年规划2018年目标会在17年总结的基础上进一步的延伸 工作 从目前的中级开发向高级开发迈进，以及向更高的专家级展望 解耦原来的项目代码 完成项目功能的迭代和优化 优化项目、提高稳定性、减少内存泄露、减少apk大小 项目中添加热修复，使用热更新提高用户体验 组件开发+模块开发+插件化开发等开发模式的引入和使用 敏捷开发+单元测试 技术学习 不断完善自己的技术学习栈 数据结构和算法 Html5+JavaScript+Css Php Java后台 Linux 业务学习 业务学习是体现自己和其他开发人员的优势区别之一 产品理念 用户体验 线上线下 其他业余学习 业余学习是为了更好的满足自己的生活 ps 设计","tags":[{"name":"总结","slug":"总结","permalink":"https:mubai.site/tags/总结/"}]},{"title":"安卓的进程保活","date":"2017-12-20T16:00:00.000Z","path":"2017-12-21-进程保活/","text":"安卓进程保活真的好烦啊… 我想每一个在实现安卓的进程保的开发者都是这样的想法吧(什么，你没有这个想法，那你就收下我的膝盖吧…) 在我们的应用开发中有时候需要我们的app时刻的运行着，比如IM类的、屏幕保护等等,这些都需要一直运行在后台中，如果被系统Kill了就没有办法提服务,所以就有了进程保活 进程的分类：(根据优先级排列) 前台进程 进程持有这些：可见的并且与用户交互的Activity、绑定在可见并且与用户交互的Activity的Service、通过startForeground()启动的Service、一个Service正在执行它的onCreat、onStart、onDestory、一个BroatcastReceiver正在执行它的onReceiver方法 一般系统不会去杀死这些前台进程 可见进程 进程持有这些：不在前台，但是可见的Activity、绑定在不在前台，可见Activity的Service 用户看得见，但是不能操作，一般系统也不会去杀死这些可见进程 服务进程 进程持有这些：通过startService启动的Service 在内存不足维持前台进程和可见进程的时候，服务进程会被杀死 后台进程 用户按了Home键和back键，程序不可见了，但是其实还是在运行的程序 系统很容易去杀死这些进程 空进程 这种进程里面不包含任何的东西，没有实际作用，最容易被杀死的进程，没有之一… 进程为什么被杀死进程被杀死的原因： 被系统杀死了 安卓系统是基于Linux系统的，继承了Linux的内存管理策略，进程退出后不会立马杀死，会在内存不够的时候在去按照进程的优先级去杀死进程腾出内存 被第三方软件杀死 360之类的 被用户手动杀死 系统自带的一键清理、手机设置应用管理器的ForceClose 进程保活的方法 提高进程的优先级 开启一个像素的Activity(QQ的保活方案) 启动前台Service 在进程杀死后，进行拉起 监听系统的广播，拉起进程(网络变化、解锁屏幕、开机等但是已经被N了) 双进程相互唤起 依靠系统唤起 多个app之间相互唤醒，阿里系列的app、腾讯系列的app 依靠第三方 各个终端对应的推送，小米的小米推送、华为的华为推送，其他的可以接入其他的其他推送 JobScheduler 5.0之后推出的进程死后复活一种方式 粘性服务与系统服务捆绑 账号同步唤醒，利用android自身的同步进制进行拉活 附：网上一个大神的关于进程保活的方案，通过对进程的分析、常见的进程保活以及到最后的nvtive实现的进程保活(从Android到Linux，从Java到C，看的我一脸懵逼…) 妈妈问我为什么跪着看 囧…","tags":[{"name":"Android","slug":"Android","permalink":"https:mubai.site/tags/Android/"}]},{"title":"插件化的必然","date":"2017-12-16T16:00:00.000Z","path":"2017-12-17-为何会有插件化的必然/","text":"一个项目，随着时间和业务的推移，会变得越来越庞大和臃肿，越来越多的功能堆积导致我们一次编译运行要等上半天，像我们公司的一个线上项目，原来打包发布的时候只有10M的apk，后来为了接入一个第三方的SDK，导致项目apk活生生撸到了40M，每次编译运行都要等个半天！囧…所以这时候产生了插件化,插件化使我们可以通过动态的加载、删除，那些独立的插件apk可以在线下载安装，有利于减少apk的体积同时也可以通过插件化时实现热修复。现在有很多热门的插件化方案：阿里的Atlas,滴滴的VirtualApk，360的RePlugin等。 说到插件化我们就不得不说说2个跟它很类似的模块化和组件化 模块化：模块化是根据业务对项目进行分离成莫干个模块的过程，例如一个消息模块、城市查询模块等。 组件化：组件化是根据功能来实现分离，例如一个下拉刷新组件、上拉加载组件等。 一个模块可以依赖多个组件，组件一般不会去依赖其他组件 然后我们在来说说插件化 插件化插件化和模块化差不多，但是它跟模块化的最大区别在于它可以打独立的apk包，而模块化不会去打成独立的apk，只会去生成model然后依赖到主app中","tags":[{"name":"架构","slug":"架构","permalink":"https:mubai.site/tags/架构/"}]},{"title":"安卓组件化到模块化","date":"2017-12-14T16:00:00.000Z","path":"2017-12-15-聊聊从安卓组件化到模块化的过程/","text":"","tags":[{"name":"架构","slug":"架构","permalink":"https:mubai.site/tags/架构/"}]},{"title":"初步解读安卓组件化","date":"2017-12-12T16:00:00.000Z","path":"2017-12-13-初步解读安卓组件化/","text":"以下的内容纯属个人理解，不对之处… 背景项目开发中，我们会用到许许多多系统的组件、自定义的组件，也许刚开始的时候我们只是重复的使用的组件(往往这些组件会在多个项目中重复的使用，毕竟国内的App说实话创意真的是挺少的)，但是随着我们开发经验的增加，有一天也许就有想能不能把这些组件进行封装出来，可以满足多个项目的需求呢，这时候就产生了组件化。 简介组件化，就是根据组件将项目进行分离成若干个组件，比如下拉刷新组件、上拉加载组件等等。这些组件不能单独的运行，必须依赖于主App中才能运行，但是可以依赖到不同项目的主App中。避免了重复的造轮子，提高了开发的效率(对于外包的项目有组件化简直不能再舒服了…) 概述这里先引一张个人项目的图 这里的lib_load和lib_refresh就是项目的刷新和加载的组件(关于上图的那几个mode可以去关于安卓的模块化进行查看)，它们是依附在app里的，只需要在build导入lib 就可以在app中使用 xw 未完待续 附言 组件化说是根据组件进行分离，但是有时候也可以根据功能进行分离(模块化：模块是根据功能进行分离的)，比如一个日间夜间模式切换、轮播图功能(轮播图说它是功能呢也可以，说是组件呢也没错)，所以说这里很多时候不会去那么的计较，毕竟每个人对组件的概念都是不一样的,有可能在你这里认为是一个组件，但是到他那里可能就是个模块了","tags":[{"name":"架构","slug":"架构","permalink":"https:mubai.site/tags/架构/"}]},{"title":"浅谈安卓项目中的从MVC到MVP在到MVVM架构模式","date":"2017-12-08T16:00:00.000Z","path":"2017-12-9-浅谈安卓项目中的从MVC到MVP在到MVVM架构模式/","text":"MVC MVC(模型Model-视图View-控制器Controller)的缩写，是一种软件的设计典范。主要是用来将业务逻辑和数据以及界面进行分离的架构方式。MVC最早是用来桌面程序上的，已经发展了几十年了，可以说得上是最经典的框架模式。 实际上MVC没有一个具体标准的说法，每个人都有着不同的理解！具体可以看下混乱的MVC架构 View：对应布局文件.xml Model：业务逻辑和实体模型 Controller：对应于Activity View可以与Model直觉交互Controller是基于行为的，并且可以被多个View共享，可以负责决定显示哪个View MVP MVP(模型Model-视图View-主持者Presenter)是MVC的进一步改进，原来的MVC的三层结构之间的联系性较高，对View和Model层来说分离的不够彻底。MVP中的P层则是完全起到连接V-M的作用，M和V层之间没有相互操作的关系。 在项目中，mvp是需要我们自己去封装 MVVM MVVM(模型Model-视图View-视图模型ViewModel)","tags":[{"name":"架构","slug":"架构","permalink":"https:mubai.site/tags/架构/"}]},{"title":"混乱的MVC架构模式相关","date":"2017-12-04T16:00:00.000Z","path":"2017-12-5-混乱的MVC架构/","text":"MVC(模型Model-视图View-控制器Controller，1982年)是一种软件设计的典范，它采用将业务逻辑、数据、界面进行分离的方式组织代码。但是它作为最基本的架构模式，至今已经发展了几十年，却没有一个明确的标准，每个人都有着自己的看法，对于它的实现方式也有着许多的不同。今天我们就来谈谈MVC是怎么混乱的。 简介 Model：模型，对应的在我们的项目中就是数据类(数据的存储、操作等) View：视图，可以理解为用来显示数据的界面，对于用户来说是最直观能看到的东西(一般对应项目中的布局xml) Controller：控制器，用来处理用户交互的部分，通常是从视图读取数据，控制用户的输入，想Model发送数据等等(具体可以去看我们的Activity，一般来说我们在项目中把Controoler对应我们Activity，它的作用我想大家都能够说出个一二三四来,我在这里就不多加内容) 关于混乱一千个读者就有一千个哈利波特，一千个乘客就有一千个老司机 ASP.NET MVC 这是ASP.NET MVC.aspx)中对于MVC的描述定义。 原谅我直接盗图… ASP.NET 对于这个示意图仅仅是通过几个箭头来表示之间的关系，但是我们可以从图片从得到我们所能看到的关系： 1.Controller即控制器它负责对View和Model进行管理，它能直接操作到View和Model 2.View来显示Model的数据","tags":[{"name":"架构","slug":"架构","permalink":"https:mubai.site/tags/架构/"}]},{"title":"设计模式","date":"2017-12-02T16:00:00.000Z","path":"2017-12-3-设计模式/","text":"设计模式的分类： 创建型模式： 工厂模式、抽象工厂模式、单例模式、建造者模式、原型模式 结构型模式： 适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式 行为型模式： 策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式 设计模式的六大原则： 核心思想还是高内聚低耦合 开闭原则 对扩展开放，对修改关闭 里氏代换原则 依赖倒转原则 接口隔离原则 使用多个隔离的接口，比使用单个接口要好，其实还是要降低耦合性 迪米特原则(最少知道原则) 一个类或者接口应该尽量少的和其他类或接口相互知道，使得系统功能模块相对独立 合成复用原则 尽量使用合成/聚合的方式，而不是使用继承 工厂模式工厂模式：把对象的创建放到一个工厂类中，通过参数或者是不同的方法来创建不同的对象，缺点在于每添加一个对象，都要去修改原来的工厂。 普通工厂模式 建立一个工厂类，对实现了同一接口的一些类进行实例的创建 123456789101112public class RunFactory &#123; public RunInterface runType(String type) &#123; if (&quot;A&quot;.endsWith(type)) &#123; return new ARuning(); &#125; else if (&quot;B&quot;.endsWith(type)) &#123; return new BRuning(); &#125; else &#123; return null; &#125; &#125;&#125; 多个工厂模式 对普通工厂模式的改进，在普通工厂模式中如果传递的参数出错，则不能正确创建对象，而多个工厂模式是提供了多个工厂方法，分别创建对象 123456789public class RunMoreFactory &#123; public RunInterface runA() &#123; return new ARuning(); &#125; public RunInterface runB() &#123; return new BRuning(); &#125;&#125; 静态工厂模式 对普通工厂模式和多个工厂模式的扩展，在静态工厂中提供静态的工厂方法，不需要创建实例，直接调用就可以 12345678910public class RunStaticFactory &#123; public static RunInterface runA() &#123; return new ARuning(); &#125; public static RunInterface runB() &#123; return new BRuning(); &#125;&#125; 好处 工厂模式看上去就是把new封装出来，虽然看上去很简单，但是实际上这恰恰就是通往架构师路上必须要学会的！因为我们要new一个实体对象实际上是一件需要非常谨慎的事情，不要随便的new，最好不要自己去new，让别人去new，传给你去调用。让谁去new，让专门的一个工厂去new。这就是工厂模式！new 其实是一种硬编码 抽象工厂抽象工厂：创建多个工厂类，每个对象的创建都由专门的一个工厂去创建，一个工厂保存一个new，符合不改代码原则 需要实现的接口： 123public interface FlyInterface &#123; void fly();&#125; 专门生产工厂的类： 123public interface FlyFactoryProduce &#123; FlyInterface produce();&#125; 工厂A： 1234567public class AFlyFactory implements FlyFactoryProduce &#123; @Override public FlyInterface produce() &#123; return new AFly(); &#125;&#125; 工厂B： 1234567public class BFlyFactory implements FlyFactoryProduce &#123; @Override public FlyInterface produce() &#123; return new BFly(); &#125;&#125; A实现： 123456public class AFly implements FlyInterface &#123; @Override public void fly() &#123; Log.d(&quot;AFly&quot;, &quot;AFly&quot;); &#125;&#125; B实现： 123456public class BFly implements FlyInterface &#123; @Override public void fly() &#123; Log.d(&quot;BFly&quot;, &quot;BFly&quot;); &#125;&#125; 调用： 12345FlyInterface AflyInterface = new AFlyFactory().produce();AflyInterface.fly();FlyInterface BflyInterface = new BFlyFactory().produce();BflyInterface.fly(); 单例模式单例模式：有时候，我们在程序中只需要某个类同时保留一个对象，不希望有更多的对象 特点： 单例模式只能有一个实例 单例类必须创建自己的唯一实例 单例类必须向其他对象提供这一实例 常见的单例模式实现方式： 懒汉，线程不安全 12345678910111213141516171819public class SingletonHelper &#123; private static SingletonHelper ourInstance = null; private SingletonHelper() &#123; &#125; /** * 懒汉，线程不安全 * * @return */ public static SingletonHelper getInstance() &#123; if (ourInstance == null) &#123; ourInstance = new SingletonHelper(); &#125; return ourInstance; &#125; &#125; 缺点在于多线程不能正常工作 懒汉，线程安全 1234567891011121314151617181920212223public class SingletonHelper &#123; private static SingletonHelper ourInstance = null; private SingletonHelper() &#123; &#125; /** * 懒汉，线程安全 * * @return */ public static SingletonHelper getInstance() &#123; if (ourInstance == null) &#123; synchronized (ourInstance) &#123; if (ourInstance == null) &#123; ourInstance = new SingletonHelper(); &#125; &#125; &#125; return ourInstance; &#125;&#125; 这种写法能在多线程中很好的工作，但是实际情况下，需要同步的时候非常少，因此会耗费一定资源 饿汉 1234567891011public class SingletonHelper &#123; private static SingletonHelper inInstance = new SingletonHelper(); private SingletonHelper() &#123; &#125; public static SingletonHelper getInInstance()&#123; return inInstance; &#125;&#125; 缺点一开始就进行实例化，没有能做到lazy-loading 饿汉，变种 12345678910111213141516public class SingletonHelper &#123; private static SingletonHelper ourInstance = null; static &#123; inInstance = new SingletonHelper(); &#125; private SingletonHelper() &#123; &#125; public static SingletonHelper getInInstance()&#123; return inInstance; &#125;&#125; 实际上跟饿汉没有什么很大区别，都是在类初始化的时候就进行实例化对象 静态内部类 12345678910111213141516171819public class SingletonHelper &#123; private static SingletonHelper ourInstance = null; private SingletonHelper() &#123; &#125; /** * 静态内部类 */ private static class SingletonHolder &#123; private static final SingletonHelper SINGLETON_HELPER = new SingletonHelper(); &#125; public static final SingletonHelper getOurInstance() &#123; return SingletonHolder.SINGLETON_HELPER; &#125;&#125; 枚举 1234567public enum SingleEnumHelper &#123; INSTANCE; public void otherMethod() &#123; &#125;&#125; 这种方式是Effective Java作者Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象，但是有个缺点在于枚举的使用 双重校验锁 12345678910111213141516171819202122public class SingletonHelper &#123; private volatile static SingletonHelper singletonHelper; private SingletonHelper() &#123; &#125; /** * 双重加锁 * * @return */ public static SingletonHelper getSingletonHelper() &#123; if (null == singletonHelper) &#123; synchronized (SingletonHelper.class) &#123; if (null == singletonHelper) &#123; singletonHelper = new SingletonHelper(); &#125; &#125; &#125; return singletonHelper; &#125; 关于单例参考： Java：单例模式的七种写法 Java单例模式(Singleton)以及实现","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https:mubai.site/tags/设计模式/"}]},{"title":"Retrofit相关","date":"2017-11-26T16:00:00.000Z","path":"2017-11-27-Retrofit相关/","text":"问题背景 在用Retrofit+RxJava向服务端请求数据的时候出现了异常 1Caused by: java.io.EOFException: End of input at line 1 column 问题所在原来的时候在请求其他接口的时候见过类似的Exception，是因为请求返回的数据跟接口定位需要返回的数据不匹配导致的(为什么不匹配就会导致异常，下面的问题分析会给出答案)。 然后就利用Paw去进行接口调试，发现服务端就是返回成功状态了，没有响应体Body！最重要的是服务端是接入第三方的不好让人去改他们的返回逻辑,然后只能客户端自己去处理这种情况。 问题排查为什么定义的返回类型不匹配就会导致异常呢，查看了Retrofit的配置方法发现在初始化的时候通过12 Retrofit retrofit = new Retrofit.Builder() .baseUrl(“”) .client(OkHttpManager.getOkHttpClient()) .addConverterFactory(GsonConverterFactory.create(GsonUtil.getGson())) .addCallAdapterFactory(RxJavaCallAdapterFactory.create()) .build(); 1234567891011121314151617181920##### 问题解决既然问题发现了，那就想着如何去解决了&gt; (当初第一个想法就是Gson解析错误，那就不用Gson了，但是项目已经开发了这么多，现在换个解析框架肯定来不及，而且成本也太高，最主要的是没法保证其他的解析框架就不好出现这个问题，所以这个想法也就是个想法)然后通过某度查找解决方法&gt; 虽然一直吐槽它，但是它的使用频率还是很高的，特别是在被墙的世界里这边也发现了几篇解决方案：&gt; [Retrofit 响应体无body时解析EOFException](http://blog.csdn.net/u011374875/article/details/51956113)&gt; &gt; [Android retrofit End of input at line 1 column 1 path](http://blog.csdn.net/it_talk/article/details/60767060)其中都给出了具体的解决方案* 自定义无Body的解析转换器，判断如果是无Body的时候调用此转换类 * 1.自定义无Body转换器 public class NullOnEmptyConverterFactory extends Converter.Factory { public static final NullOnEmptyConverterFactory create() { return new NullOnEmptyConverterFactory(); } public NullOnEmptyConverterFactory() { } @MethodInfo(date = &quot;2017-12-06 22:14:20&quot;, Desc = &quot;需要重写这里的responseBodyConverter&quot;) @Override public Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations, Retrofit retrofit) { Converter&lt;ResponseBody, ?&gt; delegate = retrofit.nextResponseBodyConverter(this, type, annotations); return new Converter&lt;ResponseBody, Object&gt;() { @Override public Object convert(ResponseBody value) throws IOException { /** * 当Body的Content-Length为0的时候就是没有Body的时候直接返回null */ if (value.contentLength() == 0) { return null; } /** * 这里如果有Body的时候正常返回 */ return delegate.convert(value); } }; } @MethodInfo(date = &quot;2017-12-06 22:15:49&quot;, Desc = &quot;这里的requestBodyConverter不需要重写&quot;) @Override public Converter&lt;?, RequestBody&gt; requestBodyConverter(Type type, Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) { return super.requestBodyConverter(type, parameterAnnotations, methodAnnotations, retrofit); } @MethodInfo(date = &quot;2017-12-06 22:16:36&quot;, Desc = &quot;这里的stringConverter不需要重写&quot;) @Override public Converter&lt;?, String&gt; stringConverter(Type type, Annotation[] annotations, Retrofit retrofit) { return super.stringConverter(type, annotations, retrofit); } } 12* 2.配置到Retrofit的Build过程中 Retrofit retrofit = new Retrofit.Builder() .baseUrl(&quot;&quot;) .client(OkHttpManager.getOkHttpClient()) /** * 这里需要注意要加在Gson解析器之前，否则还是会导致异常 */ .addConverterFactory(NullOnEmptyConverterFactory.create()) .addConverterFactory(GsonConverterFactory.create(GsonUtil.getGson())) .addCallAdapterFactory(RxJavaCallAdapterFactory.create()) .build(); 12 * 利用String接收无Body，添加```ScalarsConverterFactory * 这里只需要添加```1 Retrofit retrofit = new Retrofit.Builder() .baseUrl(&quot;&quot;) .client(OkHttpManager.getOkHttpClient()) .addConverterFactory(ScalarsConverterFactory.create()) .addConverterFactory(GsonConverterFactory.create(GsonUtil.getGson())) .addCallAdapterFactory(RxJavaCallAdapterFactory.create()) .build(); ``` 问题分析","tags":[{"name":"Android","slug":"Android","permalink":"https:mubai.site/tags/Android/"}]},{"title":"加密算法初探","date":"2017-11-19T16:00:00.000Z","path":"2017-11-20-加密算法/","text":"各种加密算法 公钥加密算法，计算机通信安全的基石，保证了加密数据不会被破解！ 对称加密 利用同一个密钥对信息进行加密和解密 好处：算法公开，简单、速度快，而且对称加密通常使用的是相对较小的密钥，密钥越大，加密越强，但是加密和解密的过程越慢。所以说密钥大小既要考虑到安全性又要照顾到效率。 缺点：对密钥的管理和分配，就是如何把密钥发送到需要解密你的加密信息的人手里是一个大问题，在发送密钥的过程中很容易被拦截篡改。 常见的对称加密算法：DES、3DES、AES、TDEA、Blowfish、RC5、IDEA DES：数据加密标准，64位密钥长度(其中8位的奇偶位，56位数据位，只有56位有效)对64位二进制数据库进行加密，每次加密进行16轮的编码 3DES：利用不同的三个密钥对数据进行三次加密，是DES的一个更加安全的变形。加密的过程是加密-解密-加密(这里不是加密-加密-加密，在于是为了与现有DES系统的向后兼容问题，因为当K1=K2时，三重DES的效果就和原来的DES一样),解密的过程是解密-加密-解密 AES：高级加密标准，下一代的加密算法标准，速度快，安全级别高，密钥有128、192和256位的 非对称加密 对数据的加密和解密采用的一对密钥，公钥和私钥 好处：对于密钥的管理更强，通常使用的是公钥进行加密然后双方都是用各自的私钥进行解密，安全性更高 缺点：加密过程慢 常见的非对称加密算法： RSA、ECC 总结 （1） 对称加密加密与解密使用的是同样的密钥，所以速度快，但由于需要将密钥在网络传输，所以安全性不高。 （2） 非对称加密使用了一对密钥，公钥与私钥，所以安全性高，但加密与解密速度慢。 （3） 解决的办法是将对称加密的密钥使用非对称加密的公钥进行加密，然后发送出去，接收方使用私钥进行解密得到对称加密的密钥，然后双方可以使用对称加密来进行沟通。","tags":[{"name":"算法","slug":"算法","permalink":"https:mubai.site/tags/算法/"}]},{"title":"Android设备网络连接情况","date":"2017-11-14T16:00:00.000Z","path":"2017-11-15-网络连接情况/","text":"Android系统中不同网络状态的获取和判断 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 获取当前的网络状态 ：没有网络-0：WIFI网络1：4G网络-4：3G网络-3：2G网络-2 * 自定义 * * @param context * @return */ public static int getAPNType(Context context) &#123; //结果返回值 int netType = 0; //获取手机所有连接管理对象 ConnectivityManager manager = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE); //获取NetworkInfo对象 NetworkInfo networkInfo = manager.getActiveNetworkInfo(); //NetworkInfo对象为空 则代表没有网络 if (networkInfo == null) &#123; return netType; &#125; //否则 NetworkInfo对象不为空 则获取该networkInfo的类型 int nType = networkInfo.getType(); if (nType == ConnectivityManager.TYPE_WIFI) &#123; //WIFI netType = 1; &#125; else if (nType == ConnectivityManager.TYPE_MOBILE) &#123; int nSubType = networkInfo.getSubtype(); TelephonyManager telephonyManager = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE); //3G 联通的3G为UMTS或HSDPA 电信的3G为EVDO if (nSubType == TelephonyManager.NETWORK_TYPE_LTE &amp;&amp; !telephonyManager.isNetworkRoaming()) &#123; netType = 4; &#125; else if (nSubType == TelephonyManager.NETWORK_TYPE_UMTS || nSubType == TelephonyManager.NETWORK_TYPE_HSDPA || nSubType == TelephonyManager.NETWORK_TYPE_EVDO_0 &amp;&amp; !telephonyManager.isNetworkRoaming()) &#123; netType = 3; //2G 移动和联通的2G为GPRS或EGDE，电信的2G为CDMA &#125; else if (nSubType == TelephonyManager.NETWORK_TYPE_GPRS || nSubType == TelephonyManager.NETWORK_TYPE_EDGE || nSubType == TelephonyManager.NETWORK_TYPE_CDMA &amp;&amp; !telephonyManager.isNetworkRoaming()) &#123; netType = 2; &#125; else &#123; netType = 2; &#125; &#125; return netType; &#125; 无线网络(wifi)5G网络4G网络3G网络2G网络弱网断网","tags":[{"name":"Android","slug":"Android","permalink":"https:mubai.site/tags/Android/"}]},{"title":"跑步","date":"2017-11-09T16:00:00.000Z","path":"2017-11-10-跑步/","text":"2017-6 曾经肥胖静好 2017-6月开始了第一次跑步，还记得是因为某一天站到称上，发现自己离开学校也就1年，然而体重却是长了不止10斤！有点担心自己在这么长下去就要提前进入油腻大叔的阶段。so对自己说要减肥！ 刚开始的时候还没想到跑步，毕竟当初学校期间最怂的还是1000米跑…然后就开始选择每天晚上在地上折腾自己，翻看着从网上扒拉下拉的各种各样的减肥动作，然后跟着开始一板一眼的模仿起来！效果的话说实话真不知道有没有😶 然后有一天看到朋友圈里有一个学长晒着他参加半马的照片，突然萌发了我也要去跑步的想法。至今还记得刚开始跑步的那天，6月份的7点多，已经没有那么的炎热，人行道上路灯映照着几个人影。我开始迈出自己关于的第一步。(这是平时晚上的一小步，却是跑步的一大步) 2018-4 跑步需要极限 从去年6月份开始，断断续续跑步也有了7-8个月了，这段时间从炎热的夏天到寒冷的冬天，经历过跑几步就满头大汗的夜晚也跑过几公里还觉得冷的冬夜，尽管如此，还是坚持了下来，看着体重秤上的数字慢慢的减少，不得不说是一种心情上的愉悦，但是我想更重要的是每次跑步过程中一次次跑出自己不敢想象的距离：从1公里到5公里，在到10公里、半马，这期间鬼知道自己是怎么坚持下来的，但是现在回想还是很有意思的。 2018年3月我看着咕咚上自己600多公里的跑步总路程，毅然决定报名人生中的第一个马拉松：杭州梦想小镇半程马拉松(虽然只是一个半马)，马拉松开始时间4-1开跑，这一个月时间我更换了自己的跑步路线和加强了自己的作息时间，只为了迎接这个人生中的第一次。 2018-4-1 早早的就赶到了入场口，做好了信息录入和准备工作，在起跑处看着来自五湖四海的跑友身穿各式各样的运动装，花式的跑马套装，觉得自己瞬间融入了他们，因为都是热爱跑步的可爱的人啊。随着一声枪响，前面特邀选手和A类选手先一步除非，B类选手的我们后一步起跑，看着跑道外面人山人海加油的人，觉得自己好荣幸。 前面10公里跑得还挺顺，后面10公里往后，觉得自己的脚指头有了疼痛的感觉，而且天气越来越热，太阳照射得张不开眼，汗水一直往眼睛里跑，每次过了一个补给点就一直盼望着下个饮水处，只能说后面的15公里是边跑边歇的。当冲过终点的那一刻，真的是只能用满足和累来形容了，满足的是内心，累的是身体。最终成绩：2小时10分。 ps：成绩不管如何，至少坚持跑下来了，而且跑完后在休息处，脱掉鞋发现右脚脚指头已经淤血了，可能是鞋子不合。难受.png 2019-3 跑步只能量力 现在的自己只能看着网上来来回回的视频满足一下内心的激动了，可能是跑步姿势的问题或者是鞋子的问题，现在左腿膝盖半月板磨损，只能修养了…","tags":[{"name":"闲文","slug":"闲文","permalink":"https:mubai.site/tags/闲文/"}]},{"title":"Annotation 注解原理及使用","date":"2017-11-02T16:00:00.000Z","path":"2017-11-3-Annotation/","text":"需要了解Restful设计规范、ORM框架 很多的开源库都用到了注解来简化代码提高开发效率 概念Annotation(注解):能够添加到Java源代码的元数据(为描述数据的数据)。类、方法、变量、参数、包都可以添加Annotation，可用来将元数据和程序元素相关联。 作用 标记，用来告诉编译器一些信息 编译时动态处理，如动态生成代码 运行时动态处理，如得到注解信息 分类 标注Annotation 系统自带的几个常见的Annotation 元Annotation 指用来自定义Annotation的Annotation 自定义Annotation 用户根据自己需求自定义的Annotation 定义时需要用到上面的元Annotation 自定义Annotation 1.通过@interface定义 2.注解配置参数名为注解类的方法名： 1.所以方法没有方法体，没有参数没有修饰符，实际只允许public &amp; abstract修饰符 2.方法返回值只能是基本类型 3.若只有一个默认属性，可以直接用value函数，一个属性都没有表示该Annotation为mark Annotation 3.可以用default表示默认值 4.注解定义 123456789101112131415//是否会保存到JavaDoc中@Documented//保留时间，source:源码时，class：编译时，runtime：运行时，默认为class，值为source大多为mark annotation，如@overrided等@Retention(RetentionPolicy.RUNTIME)//表示可以用来修饰哪些程序元素，如方法，变量，类，参数等等，如果没有标注则表示修饰所有@Target(ElementType.METHOD)//是否可以被继承，默认为false@Inheritedpublic @interface MethodInfo &#123; String author() default &quot;quickly520@126.com&quot;; String date(); String Desc() default &quot;自定义Annotation&quot;;&#125; 引用注解 注解的使用 12345678910111213141516171819/** * 获得当前进程的名字 * * @param context * @return */ @MethodInfo(author = &quot;quicklymost@gmail.com&quot; , date = &quot;2017-11-14&quot;, Desc = &quot;获得当前进程的名字&quot;) public static String getCurProcessName(Context context) &#123; int pid = android.os.Process.myPid(); ActivityManager activityManager = (ActivityManager) context .getSystemService(Context.ACTIVITY_SERVICE); for (ActivityManager.RunningAppProcessInfo appProcess : activityManager.getRunningAppProcesses()) &#123; if (appProcess.pid == pid) &#123; return appProcess.processName; &#125; &#125; return null; &#125; 是否引用了注解 对某个类进行注解添加 123@MethodInfo(date = &quot;2017-11-29 10:18:34&quot;)public class AnnotationUse &#123;&#125; 通过反射来检查类是否添加了注解 123456789101112private void isUseAnnotation() &#123; /** * 检查类是否有注解 */ if (AnnotationUse.class.isAnnotationPresent(MethodInfo.class)) &#123; /** * 通过反射来对AnnotationUse进行检查是否有注解 */ MethodInfo methodInfo = AnnotationUse.class.getAnnotation(MethodInfo.class); Log.d(&quot;App&quot;, &quot;methodInfo:&quot; + methodInfo); &#125; &#125; 通过注解来代替枚举 Google对枚举在Android中是不推荐使用的,枚举类型比起静态变量，会消耗2倍的内存 @IntDef IntDef是一种替换整数类型枚举的注解 @StringDef StringDef是一种替换字符串类型枚举的注解 123456789101112131415161718192021222324252627282930public class TypeCheck &#123; public static final int TYPE_MUSIC = 0; public static final int TYPE_PHOTO = 1; public static final int TYPE_TEXT = 2; public int itemType; /** * 无法确定传入的参数是否符合要求，这里可以利用IntDef/StringDef来对类型进行检查 */// public void MethodCheck(int itemType) &#123;// this.itemType = itemType;// &#125; @Retention(RetentionPolicy.SOURCE) @IntDef(&#123;TYPE_MUSIC, TYPE_PHOTO, TYPE_TEXT&#125;) public @interface typeCheck &#123; &#125; public TypeCheck(@typeCheck int itemType) &#123; this.itemType = itemType; &#125; @typeCheck public int getType() &#123; return itemType; &#125;&#125;","tags":[{"name":"Android","slug":"Android","permalink":"https:mubai.site/tags/Android/"}]},{"title":"WebView注意以及性能瓶颈","date":"2017-10-28T16:00:00.000Z","path":"2017-10-29-WebView注意事项以及性能瓶颈测试/","text":"webview注意事项： webview加载太慢 webview导致的内存泄露 webview的兼容性(不同的系统采用的不同内核导致的兼容性问题，特别是国内各个厂商对原生系统的定制化) webview加载太慢 webview加载慢的原因：webview在加载页面的时候，除了url的请求外，还有webview页面外部引用的js、css、字体、图片等请求，而且这些请求都是串行的，这些请求加上浏览器的解析、渲染页面等就导致了webview整体的加载时间变得很长，消耗的流量也很多。 webview 性能测试以及瓶颈分析webview常用缓存机制的使用场景和优势 浏览器缓存机制 Dom Storage Web Sql dataBase Appcache IndexDB File System Api 未完待续","tags":[{"name":"Android","slug":"Android","permalink":"https:mubai.site/tags/Android/"}]},{"title":"返回数据格式规范","date":"2017-10-24T16:00:00.000Z","path":"2017-10-25-Json数据格式规范/","text":"请求头123456Content-Type: application/json/** *不推荐使用使用表单格式: *application/x-www-form-urlencoded *无法提交有层级的参数 */ 返回12345Content-Type: application/json/** *返回头格式，请返回JSON格式 *不要返回 text/html，text/css 等不相关返回头 */ 请求为其他错误的Code的返回结果12345&#123; &quot;code&quot;: 400, &quot;data&quot;: null, &quot;message&quot;: &quot;error&quot;&#125; 请求为成功Code的返回结果 返回的result为一个数组，并且有数据时期望的结果 12345678910111213&#123; &quot;code&quot;: 200, &quot;data&quot;: &#123; &quot;result&quot;: [ &#123; &quot;house_id&quot;: 36, &quot;area&quot;: &quot;\\u6c5f\\u5e72\\u533a&quot; &#125; ], &quot;totals&quot;: 1 //不一定有 &#125;, &quot;message&quot;: &quot;&quot;&#125; 返回的result为一个数组，并且没有数据时期望的结果 12345678&#123; &quot;code&quot;: 200, &quot;data&quot;: &#123; &quot;result&quot;: [], //返回一个空的数组 &quot;totals&quot;: &quot;0&quot; &#125;, &quot;message&quot;: &quot;&quot;&#125; 返回的result为一个对象，并且有数据时期望的结果 12345678910&#123; &quot;code&quot;: 200, &quot;data&quot;: &#123; &quot;result&quot;: &#123; &quot;user_id&quot;: 11111, &quot;mobile&quot;: &quot;187xxxxxxxx&quot; &#125; &#125;, &quot;message&quot;: &quot;success&quot;&#125; 返回的result为一个对象，并且没有数据时期望的结果 1234567&#123; &quot;code&quot;: 200, &quot;data&quot;: &#123; &quot;result&quot;: null //返回一个空的对象 &#125;, &quot;message&quot;: &quot;null&quot;&#125;","tags":[{"name":"开发规范","slug":"开发规范","permalink":"https:mubai.site/tags/开发规范/"}]}]